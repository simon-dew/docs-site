<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>Java | Couchbase Docs (Staging)</title>
    <link rel="canonical" href="https://simon-dew.github.io/docs-site/DOC-4433/couchbase-lite/2.5/java.html">
    <link rel="stylesheet" href="../../_/css/site.css">
    <link rel="schema.dcterms" href="https://purl.org/dc/terms/">
    <meta name="dcterms.subject" content="couchbase-lite">
    <meta name="dcterms.identifier" content="1.4">
    <meta name="generator" content="Antora 1.1.1">
    <link rel="icon" href="../../_/img/favicon.ico" type="image/x-icon">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar" id="topbar">
    <div class="container">
      <div class="navbar-brand">
        <a class="navbar-item" href="https://www.couchbase.com"><img src="../../_/img/logo.svg" alt="Couchbase"></a>
        <button class="navbar-burger" data-target="topbar-menu">
          <span></span>
          <span></span>
          <span></span>
        </button>
      </div>
      <div id="topbar-menu" class="navbar-menu">
        <div class="navbar-start">
          <div class="navbar-item has-dropdown">
            <a class="navbar-link" href="https://simon-dew.github.io/docs-site/DOC-4433">Docs</a>
            <div class="navbar-dropdown explore">
              <div class="title">Couchbase Documentation Overview</div>
              <div class="cols">
                <ul>
                  <li class="heading"><a href="../../server/6.0/introduction/intro.html">Server</a></li>
                  <li><a href="../../server/6.0/n1ql/n1ql-language-reference/index.html">N1QL</a></li>
                  <li><a href="../../server/6.0/fts/full-text-intro.html">Full Text Search</a></li>
                  <li><a href="../../server/6.0/analytics/introduction.html">Analytics</a></li>
                  <li><a href="../../server/6.0/eventing/eventing-overview.html">Eventing</a></li>
                  <li><a href="../../operator/1.2/overview.html">Autonomous Operator</a></li>
                </ul>
                <ul>
                  <li class="heading">Mobile</li>
                  <li><a href="../2.5/index.html">Lite</a></li>
                  <li><a href="../../sync-gateway/2.5/index.html">Sync Gateway</a></li>
                </ul>
                <ul class="two-cols">
                  <li class="heading"><a href="../../server/6.0/sdk/overview.html">SDKs</a></li>
                  <li><a href="../../c-sdk/2.10/start-using-sdk.html">C</a></li>
                  <li><a href="../../dotnet-sdk/2.7/start-using-sdk.html">.NET</a></li>
                  <li><a href="../../go-sdk/1.5/start-using-sdk.html">Go</a></li>
                  <li><a href="../../java-sdk/2.7/start-using-sdk.html">Java</a></li>
                  <li><a href="../../nodejs-sdk/2.6/start-using-sdk.html">Node.js</a></li>
                  <li><a href="../../php-sdk/2.6/start-using-sdk.html">PHP</a></li>
                  <li><a href="../../python-sdk/2.5/start-using-sdk.html">Python</a></li>
                </ul>
                <ul>
                  <li class="heading"><a href="../../server/6.0/connectors/intro.html">Connectors</a></li>
                  <li><a href="../../elasticsearch-connector/4.0/index.html">Elasticsearch</a></li>
                  <li><a href="../../server/6.0/connectors/hadoop-1.2/hadoop.html">Hadoop</a></li>
                  <li><a href="../../kafka-connector/3.4/index.html">Kafka</a></li>
                  <li><a href="../../spark-connector/2.2/index.html">Spark</a></li>
                  <li><a href="../../talend-connector/index.html">Talend</a></li>
                  <li><a href="../../server/6.0/connectors/odbc-jdbc-drivers.html">ODBC/JDBC</a></li>
                </ul>
              </div>
            </div>
          </div>
          <div class="navbar-item has-dropdown">
            <a class="navbar-link component" href="index.html"><span class="title">Couchbase Lite</span> <span class="version">1.4</span></a>
            <div class="navbar-dropdown versions">
              <div class="cols">
                <ul>
                  <li><a class="navbar-item" href="../2.5/java.html">Couchbase Lite 2.5</a></li>
                  <li><a class="navbar-item" href="../2.1/java.html">Couchbase Lite 2.1</a></li>
                  <li><a class="navbar-item" href="../2.0/java.html">Couchbase Lite 2.0</a></li>
                  <li><a class="navbar-item" href="../1.3/java.html">Couchbase Lite 1.3</a></li>
                </ul>
              </div>
            </div>
          </div>
        </div>
        <div class="navbar-end">
          <div class="navbar-item">
            <a class="btn red-btn" href="https://www.couchbase.com/downloads">Downloads</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body container">
<nav class="nav">
<div class="nav-menu">
<ul class="nav-list">
  <li class="nav-item is-current-path is-active" data-depth="0">
    <span class="nav-line">
    <button class="nav-toggle"></button>
    <span class="nav-text">Couchbase Lite</span>
    </span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="index.html">What&#8217;s New</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="swift.html">Swift</a>
    </span>
  </li>
  <li class="nav-item is-current-page is-active" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="java.html">Java</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="csharp.html">C#</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="objc.html">Objective-C</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="rest-api.html">REST API</a>
    </span>
  </li>
</ul>
  </li>
</ul>
</div>
</nav>
<aside class="toc sidebar">
  <div class="toc-menu"></div>
</aside>
<main class="article" data-ceiling="topbar">
  <div class="article-banner">
    <p>A newer version of this documentation is available.</p>
    <a class="btn" href="../2.5/java.html">View Latest</a>
  </div>
  <div class="article-header">
<button class="nav-control"></button>
<nav class="crumbs" aria-label="breadcrumbs">
  <ul>
    <li class="crumb">Couchbase Lite</li>
    <li class="crumb"><a href="java.html">Java</a></li>
  </ul>
</nav>
<div class="tools" role="navigation">
  <ul>
    <li class="tool edit"><a href="https://github.com/couchbaselabs/docs-couchbase-lite/edit/release/1.4/modules/ROOT/pages/java.adoc" title="Edit Page" target="_blank" rel="noopener">Edit</a></li>
  </ul>
</div>
  </div>
<article class="doc">
<h1 class="page">Java</h1>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a>Getting Started</h2>
<div class="sectionbody">
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset1_gradle"></a>Gradle</p>
</li>
<li>
<p><a id="tabset1_maven"></a>Maven</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset1_gradle">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Expand the <strong>app</strong> folder and open the <strong>build.gradle</strong> file.</p>
<div class="imageblock">
<div class="content">
<img src="_images/android-build-gradle.png" alt="android build gradle" width="300">
</div>
</div>
</li>
<li>
<p>Add some required rules in the <strong>android</strong> section of the application&#8217;s Gradle file (usually at <strong>app/build.gradle</strong>).</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">android {
  // ...
  // workaround for duplicate files during packaging of APK issue
  // see https://groups.google.com/d/msg/adt-dev/bl5Rc4Szpzg/wC8cylTWuIEJ
  packagingOptions {
      exclude 'META-INF/ASL2.0'
      exclude 'META-INF/LICENSE'
      exclude 'META-INF/NOTICE'
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Next, add Couchbase Lite as a dependency in the <strong>dependencies</strong> section.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
  // ...
  compile 'com.couchbase.lite:couchbase-lite-android:1.4.1'
}</code></pre>
</div>
</div>
</li>
<li>
<p>In the Android Studio tool bar, click <strong>Sync Project with Gradle Files</strong>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Available libraries</strong></p>
</div>
<div class="paragraph">
<p>The following libraries can be used in an Android Studio project to import different components.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Gradle Dependency Line</th>
<th class="tableblock halign-left valign-top">Service</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>com.couchbase.lite:couchbase-lite-java-listener:1.4.1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">To access the database through HTTP (often used for hybrid development and peer-to-peer sync).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>com.couchbase.lite:couchbase-lite-android-forestdb:1.4.1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">To use ForestDB as the storage type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>com.couchbase.lite:couchbase-lite-android-sqlcipher:1.4.1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">To enable encryption on SQLite databases.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>com.couchbase.lite:couchbase-lite-java-javascript:1.4.1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JavaScript view (map/reduce) engine for the REST API.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Supported architectures</strong></p>
</div>
<div class="paragraph">
<p>The list of supported Android architectures depends on the storage type (i.e.
SQLite or ForestDB) you are using.
For SQLite databases, all architectures are supported:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">armeabi-v7a</th>
<th class="tableblock halign-left valign-top">x86</th>
<th class="tableblock halign-left valign-top">arm64-v8a</th>
<th class="tableblock halign-left valign-top">x86_64</th>
<th class="tableblock halign-left valign-top">mips64</th>
<th class="tableblock halign-left valign-top">armeabi</th>
<th class="tableblock halign-left valign-top">mips</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For ForestDB databases, the supported architectures are:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">armeabi-v7a</th>
<th class="tableblock halign-left valign-top">x86</th>
<th class="tableblock halign-left valign-top">arm64-v8a</th>
<th class="tableblock halign-left valign-top">x86_64</th>
<th class="tableblock halign-left valign-top">mips64</th>
<th class="tableblock halign-left valign-top">armeabi</th>
<th class="tableblock halign-left valign-top">mips</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tab-pane" aria-labelledby="tabset1_maven">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Open <strong>pom.xml</strong> in the IDE of your choice.</p>
</li>
<li>
<p>Add the following inside the <code>dependencies</code> XML tag.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
        &lt;groupId&gt;com.couchbase.lite&lt;/groupId&gt;
        &lt;artifactId&gt;couchbase-lite-java&lt;/artifactId&gt;
        &lt;version&gt;1.4.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</li>
<li>
<p>Sync the dependencies and start using Couchbase Lite in your project.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Available artifacts</strong></p>
</div>
<div class="paragraph">
<p>The following libraries can be used in a Java project to import different components.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Artifact name</th>
<th class="tableblock halign-left valign-top">Service</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>couchbase-lite-java-listener</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">To access the database through HTTP (often used for hybrid development and peer-to-peer sync).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>couchbase-lite-java-forestdb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">To use ForestDB as the storage type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>couchbase-lite-java-sqlcipher</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">To enable encryption on SQLite databases.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>couchbase-lite-java-javascript</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JavaScript view (map/reduce) engine for the REST API.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Other options</strong></p>
</div>
<div class="paragraph">
<p>You can find instructions for other build systems (Gradle etc.) on the <a href="https://mvnrepository.com/artifact/com.couchbase.lite/couchbase-lite-java">Maven repository page</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="starter-code"><a class="anchor" href="#starter-code"></a>Starter Code</h3>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset2_android-studio"></a>Android Studio</p>
</li>
<li>
<p><a id="tabset2_intellij-idea"></a>IntelliJ IDEA</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset2_android-studio">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a new Android Studio project and install Couchbase Lite by following the Gradle instructions above.</p>
<div class="imageblock">
<div class="content">
<img src="_images/android-studio-new-project.png" alt="android studio new project">
</div>
</div>
</li>
<li>
<p>Open <strong>MainActivity.java</strong> in Android Studio and add the following in the <code>onCreate</code> method.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Create a manager
Manager manager = null;
try {
    manager = new Manager(new AndroidContext(getApplicationContext()), Manager.DEFAULT_OPTIONS);
} catch (IOException e) {
    e.printStackTrace();
}
// Create or open the database named app
Database database = null;
try {
    database = manager.getDatabase(app);
} catch (CouchbaseLiteException e) {
    e.printStackTrace();
}
// The properties that will be saved on the document
MapString, Object properties = new HashMapString, Object();
properties.put(title, Couchbase Mobile);
properties.put(sdk, Android);
// Create a new document
Document document = database.createDocument();
// Save the document to the database
try {
    document.putProperties(properties);
} catch (CouchbaseLiteException e) {
    e.printStackTrace();
}
// Log the document ID (generated by the database)
// and properties
Log.d(app, String.format(Document ID :: %s, document.getId()));
Log.d(app, String.format(Learning %s with %s, (String) document.getProperty(title), (String) document.getProperty(sdk)));

// Create replicators to push  pull changes to  from Sync Gateway.
URL url = null;
try {
    url = new URL(http://10.0.2.2:4984/hello);
} catch (MalformedURLException e) {
    e.printStackTrace();
}
Replication push = database.createPushReplication(url);
Replication pull = database.createPullReplication(url);
push.setContinuous(true);
pull.setContinuous(true);

// Start replicators
push.start();
pull.start();</code></pre>
</div>
</div>
</li>
<li>
<p>Build and run.</p>
</li>
<li>
<p>Filter on the term <code>D/app</code> in LogCat and you should see the document ID and property printed to the console.</p>
<div class="imageblock">
<div class="content">
<img src="_images/android-studio-logging.png" alt="android studio logging">
</div>
</div>
<div class="paragraph">
<p>The document was successfully persisted to the database.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset2_intellij-idea">
<div class="paragraph">
<p>Create a new <strong>command line app</strong> in the IDE of your choice (in this example we&#8217;ll use <strong>IntelliJ IDEA CE</strong>).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/intellij-starter-proj.png" alt="intellij starter proj">
</div>
</div>
<div class="paragraph">
<p>By default, new projects in IntelliJ are not setup to download dependencies from Maven.
Right-click on the project and select the <strong>Add Framework Support</strong> menu.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/intellij-maven-support.png" alt="intellij maven support">
</div>
</div>
<div class="paragraph">
<p>In the pop-up window, select Maven as the build system to add it to the project.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/maven-popup.png" alt="maven popup">
</div>
</div>
<div class="paragraph">
<p>This step will create a new <strong>pom.xml</strong> file.
Add the following inside the <code>project</code> XML tag.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependencies&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;com.couchbase.lite&lt;/groupId&gt;
		&lt;artifactId&gt;couchbase-lite-java&lt;/artifactId&gt;
		&lt;version&gt;1.4.1&lt;/version&gt;
	&lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Open <strong>Main.java</strong> and add the following in the <code>main</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.couchbase.HelloCBL;

import com.couchbase.lite.*;
import com.couchbase.lite.replicator.Replication;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

public class Main {

    public static void main(String[] args) {

        // Enable logging
        Logger log = Logger.getLogger(app);
        log.setLevel(Level.ALL);
        JavaContext context = new JavaContext();

        // Create a manager
        Manager manager = null;
        try {
                manager = new Manager(context, Manager.DEFAULT_OPTIONS);
        } catch (IOException e) {
                e.printStackTrace();
        }

        // Create or open the database named app
        Database database = null;
        try {
                database = manager.getDatabase(app);
        } catch (CouchbaseLiteException e) {
                e.printStackTrace();
        }

        // The properties that will be saved on the document
        MapString, Object properties = new HashMapString, Object();
        properties.put(title, Couchbase Mobile);
        properties.put(sdk, Java);

        // Create a new document
        Document document = database.createDocument();

        // Save the document to the database
        try {
                document.putProperties(properties);
        } catch (CouchbaseLiteException e) {
                e.printStackTrace();
        }

        // Log the document ID (generated by the database)
        // and properties
        log.info(String.format(Document ID :: %s, document.getId()));
        log.info(String.format(Learning %s with %s, (String) document.getProperty(title), (String) document.getProperty(sdk)));

        // Create replicators to push  pull changes to  from Sync Gateway.
        URL url = null;
        try {
                url = new URL(http://localhost:4984/hello);
        } catch (MalformedURLException e) {
                e.printStackTrace();
        }
        Replication push = database.createPushReplication(url);
        Replication pull = database.createPullReplication(url);
        push.setContinuous(true);
        pull.setContinuous(true);

        // Start replicators
        push.start();
        pull.start();

    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Build and run.
Notice the document ID and property are printed to the console.
The document was successfully persisted to the database.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/java-log-results.png" alt="java log results">
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="api-references"><a class="anchor" href="#api-references"></a>API References</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="http://docs.couchbase.com/mobile/1.4.1/couchbase-lite-java/index.html">Java API References</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="manager"><a class="anchor" href="#manager"></a>Manager</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A <code>Manager</code> is the top-level object that manages a collection of Couchbase Lite <code>Database</code> instances.
You need to create a <code>Manager</code> instance before you can work with Couchbase Lite objects in your Application.</p>
</div>
<div class="sect2">
<h3 id="creating-a-manager"><a class="anchor" href="#creating-a-manager"></a>Creating a manager</h3>
<div class="paragraph">
<p>You create a Manager object by calling a constructor or initializer on the Manager class.</p>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset3_android"></a>Android</p>
</li>
<li>
<p><a id="tabset3_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset3_android">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">AndroidContext androidContext = new AndroidContext(getApplicationContext());
manager = new Manager(androidContext, Manager.DEFAULT_OPTIONS);</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset3_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">JavaContext context = new JavaContext();
manager = new Manager(context, Manager.DEFAULT_OPTIONS);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dude-where-s-my-database-file"><a class="anchor" href="#dude-where-s-my-database-file"></a>Dude, where&#8217;s my database file?</h3>
<div class="paragraph">
<p>The Manager creates a directory in the filesystem and stores databases inside it.
Normally, you don&#8217;t need to care where that is&#8201;&#8212;&#8201;your application shouldn&#8217;t be directly accessing those files.
But sometimes it does matter.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Android: The directory is the location returned by the Android Context object&#8217;s <code>getFilesDir()</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
One notable case where the location can be important is on iOS: Apple&#8217;s app review process tries to make sure that the only application data that will be backed up to iCloud is data created by the user.
So it&#8217;s a red flag when, on first launch, an app creates data in backed-up locations (including the Documents and Application Support directories) without user action.
Unfortunately, that will happen if your app starts a pull replication on launch, or installs a pre-populated database.
Some apps using Couchbase Lite have had their App Store approval held up for this reason!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>On Android, you can subclass <code>com.couchbase.lite.android.AndroidContext</code> and override its <code>getFilesDir</code> method to return the desired directory.</p>
</div>
</div>
<div class="sect2">
<h3 id="global-logging-settings"><a class="anchor" href="#global-logging-settings"></a>Global logging settings</h3>
<div class="paragraph">
<p>You can customize the global logging settings for Couchbase Lite via the <code>Manager</code> class.
Log messages are tagged, allowing them to be logically grouped by activity.
You can control whether individual tag groups are logged.</p>
</div>
<div class="paragraph">
<p>The available tags are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">In Java tag groups are enabled at level WARN by default.

Log tags

Log.TAG_BLOB_STORE //BlobStore
Log.TAG //CBLite
Log.TAG_CHANGE_TRACKER //ChangeTracker
Log.TAG_DATABASE //Database
Log.TAG_LISTENER //Listener
Log.TAG_MULTI_STREAM_WRITER //MultistreamWriter
Log.TAG_QUERY //Query
Log.TAG_REMOTE_REQUEST //RemoteRequest
Log.TAG_ROUTER //Router
Log.TAG_SYNC //Sync
Log.TAG_VIEW //View

Log levels

Log.VERBOSE
Log.DEBUG
Log.INFO
Log.WARN
Log.ERROR</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following code snippet enables logging for the <strong>Sync</strong> tag.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Manager.enableLogging("Sync", Log.VERBOSE);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="concurrency-support"><a class="anchor" href="#concurrency-support"></a>Concurrency Support</h3>
<div class="paragraph">
<p>In Java all Couchbase Lite objects may be shared freely between threads.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="database"><a class="anchor" href="#database"></a>Database</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A Database is a container and a namespace for documents, a scope for queries, and the source and target of replication.
Databases are represented by the <code>Database</code> class.</p>
</div>
<div class="paragraph">
<p>Most applications only need one database, but you can use the Manager to create as many as you need.
Multiple databases are independent of each other.
If your application supports switching between multiple users, each with their own separate content and settings, you should consider using a database for each user.
Otherwise, it&#8217;s usually best to stick with one database.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A database is not a table.
Couchbase Lite doesn&#8217;t have any equivalent of relational database tables: different types of documents all coexist in the same database.
Usually you use a "type" property to distinguish them.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A database has the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Its <strong>name</strong>.
The name must consist only of <em>lowercase</em> ASCII letters, digits, and the special characters <code>_$()+-/</code>.
It must also be less than 240 bytes and start with a lower case letter.</p>
</li>
<li>
<p>Documents.
Each document is identified uniquely by its ID.</p>
</li>
<li>
<p>Views.
Each view has a unique name, and a persistent index as well as map and reduce functions.</p>
</li>
<li>
<p>Filter functions.
These are used to replicate subsets of documents.</p>
</li>
<li>
<p>Replications.
Each replication specifies a remote database to sync documents to or from, and other parameters.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="creating-a-database"><a class="anchor" href="#creating-a-database"></a>Creating a database</h3>
<div class="sect3">
<h4 id="creating-an-empty-database"><a class="anchor" href="#creating-an-empty-database"></a>Creating an empty database</h4>
<div class="paragraph">
<p>You create a new empty database by simply accessing it, using the <code>databaseNamed</code> method&#8201;&#8212;&#8201;this method opens the database if it isn&#8217;t yet open, and creates it if it doesn&#8217;t yet exist.
See the next section, Opening a database, for details.
This way you don&#8217;t have to write any special code for the first launch of the app.</p>
</div>
</div>
<div class="sect3">
<h4 id="pulling-down-a-remote-database"><a class="anchor" href="#pulling-down-a-remote-database"></a>Pulling down a remote database</h4>
<div class="paragraph">
<p>Often you&#8217;ll want to create a local clone (or subset) of a database on a server.
To do this you simply create an empty database as above, then start a pull replication that will download the remote database into it.
The replication is asynchronous, but you can monitor its progress to find out when it&#8217;s done.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If possible, avoid blocking until the replication completes.
The user&#8217;s first-launch experience will be much more pleasant if s/he can begin using your app immediately instead of staring at a modal progress screen waiting for downloads to complete.
If you&#8217;ve implemented a data-driven UI, the content will appear incrementally as it downloads.
For example, the ToDoLite app initially displays no content, but the to-do lists and their items quickly appear as the replication progresses.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="installing-a-pre-built-database"><a class="anchor" href="#installing-a-pre-built-database"></a>Installing a pre-built database</h4>
<div class="paragraph">
<p>If your app needs to sync a lot of data initially, but that data is fairly static and won&#8217;t change much, it can be a lot more efficient to bundle a database in your application and install it on the first launch.
Even if some of the content changes on the server after you create the app, the app&#8217;s first pull replication will bring the database up to date.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is essentially trading setup time for app installation time.
If you install a 100MB database in your app, that of course adds to the time it takes to download and install the app.
But it can still be faster than replication since the 100MB database will simply be downloaded in bulk as part of the app archive, instead of going through the interactive sync protocol.
Also, the download happens when the user expects it to (while installing the app) rather than when s/he&#8217;s not (on first launch.)
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To use a prebuilt database, you need to set up the database, build the database into your app bundle as a resource, and install the database during the initial launch.</p>
</div>
<div class="paragraph">
<p><strong>Setting Up the Database:</strong> You need to make the database as small as possible.
Couchbase Lite keeps a revision history of every document and that takes up space.
When creating the database locally, you can make it smaller by storing each document (via a PUT request) only once, rather than updating it multiple times.
(You can double-check this by verifying that each document revision ID starts with <code>1-</code>.)</p>
</div>
<div class="paragraph">
<p>If you start with a snapshot of a live database from a server, then create a new, empty local database and replicate the source database into it.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
On iOS / Mac OS, the Couchbase Lite Xcode project has a target called LiteServ that builds a small Mac app that does nothing but run the REST API.
LiteServ is a useful tool for creating databases and running replications locally on your development machine.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Extracting and Building the Database:</strong> Next you need to find the database&#8217;s files.
The location of these is determined by the Manager instance;
it&#8217;s in a directory called <code>CouchbaseLite</code> whose default location is platform-specific.
(On iOS and Mac OS, it&#8217;s in the <code>Application Support</code> directory.)
The main database file has a .cblite extension.
If your database has attachments, you also need the "databasename attachments" directory that&#8217;s adjacent to it.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
iOS/Mac specific instructions: Add the database file and the corresponding attachments directory to your Xcode project.
If you add the attachments folder, make sure that in the Add Files sheet you select the Create folder references for any added folders radio button, so that the folder structure is preserved;
otherwise, the individual attachment files are all added as top-level bundle resources.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Installing the Database:</strong> After your app launches and creates a Database instance for its database, it needs to check whether the database exists.
If the database does not exist, the app should copy it from the app bundle.
The code looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// catalog.zip should unzip in the root folder as a CBL database (i.e catalog.cblite2)
Manager manager = new Manager(new AndroidContext(getApplicationContext()), Manager.DEFAULT_OPTIONS);
Database database = manager.getExistingDatabase("catalog");
if (database == null) {
    try {
        ZipUtils.unzip(getAssets().open("catalog.zip"), manager.getContext().getFilesDir());
    } catch (IOException e) {
        e.printStackTrace();
    }
    database = manager.getExistingDatabase("catalog");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="opening-a-database"><a class="anchor" href="#opening-a-database"></a>Opening a database</h3>
<div class="paragraph">
<p>You&#8217;ll typically open a database while initializing your app, right after instantiating the Manager object, and store a reference to the Database object as either a global variable or a property of your top-level application object (the app delegate on iOS or Mac OS).
Opening a database is as simple as calling the Manager&#8217;s <code>databaseNamed</code> method&#8201;&#8212;&#8201;this will first create a new empty database if one doesn&#8217;t already exist with that name.
It&#8217;s fine to call this method more than once: it will return the same Database instance every time.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
For compatibility reasons, <strong>database names cannot contain uppercase letters!</strong>
The only legal characters are lowercase ASCII letters, digits, and the special characters <code>_$()+-/</code>
</td>
</tr>
</table>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset4_android"></a>Android</p>
</li>
<li>
<p><a id="tabset4_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset4_android">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try {
     Manager manager = new Manager(new AndroidContext(mContext), Manager.DEFAULT_OPTIONS);
     this.db = manager.getDatabase("my-database");
 } catch (IOException e) {
     Log.e(TAG, "Cannot create database", e);
     return;
 }</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset4_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try {
     Manager manager = new Manager(new JavaContext("data"), Manager.DEFAULT_OPTIONS);
     this.db = manager.getDatabase("my-database");
 } catch (IOException e) {
     Log.e(TAG, "Cannot create database", e);
     return;
 }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you want to open only an existing database, without the possibility of creating a new one, call the related Manager method <code>existingDatabaseNamed</code> instead.
It returns null/nil (without an error or exception) if no database with that name exists.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="database-encryption"><a class="anchor" href="#database-encryption"></a>Database encryption</h3>
<div class="paragraph">
<p>Since Couchbase Lite 1.2, databases can be encrypted using SQLCipher;
an open source extension to SQLite that provides transparent encryption of database files.
The encryption specification is 256-bit AES.
The steps below outline how to enable it.</p>
</div>
<div class="sect3">
<h4 id="step-1-installing-sqlcipher"><a class="anchor" href="#step-1-installing-sqlcipher"></a>Step 1: Installing SQLCipher</h4>
<div class="paragraph">
<p>SQLCipher is an optional dependency.</p>
</div>
<div class="paragraph">
<p>Add the following in the application level build.gradle file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">dependencies {
    compile 'com.couchbase.lite:couchbase-lite-android:+'
    compile 'com.couchbase.lite:couchbase-lite-android-sqlcipher:+'
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="step-2-enabling-encryption"><a class="anchor" href="#step-2-enabling-encryption"></a>Step 2: Enabling encryption</h4>
<div class="paragraph">
<p>At this point, Couchbase Lite won&#8217;t work any differently.
Databases are still unencrypted by default.
To enable encryption, you must register an encryption key when opening the database with the openDatabase method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String key = "password123456";
DatabaseOptions options = new DatabaseOptions();
options.setCreate(true);
options.setEncryptionKey(key);
Database database = manager.openDatabase("db", options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the database does not exist (and <code>options.create</code> is true) it will be created encrypted with the given key.</p>
</div>
<div class="paragraph">
<p>If the database already exists, the key will be used to decrypt it (and to encrypt future changes).
If the key does not match the one previously used, opening the database will fail;
the error/exception will have status code 401.</p>
</div>
<div class="paragraph">
<p>To change the encryption key, you must first open the database using the <code>openDatabase</code> method with the existing key and if the operation is successful, use the <code>changeEncryptionKey</code> method providing the new key.
Passing <code>nil</code> as the value will disable encryption.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="storage-engines"><a class="anchor" href="#storage-engines"></a>Storage engines</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The following section describes how to set up ForestDB, which will be deprecated in the next major release of Couchbase Mobile.
For present and future development, we recommend to use the default storage type, SQLite.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are two storage engines available with Couchbase Lite: SQLite and ForestDB.
In the case of SQLite, it will use the system dependency already available on most platforms (iOS, Android, Windows&#8230;&#8203;).
To use ForestDB, the project must include the ForestDB storage dependency (see instructions below.)</p>
</div>
<div class="sect3">
<h4 id="what-is-forestdb"><a class="anchor" href="#what-is-forestdb"></a>What is ForestDB?</h4>
<div class="paragraph">
<p>ForestDB is a persistent key-value storage library, it&#8217;s a key-value map where the keys and values are binary blobs.</p>
</div>
<div class="sect4">
<h5 id="benefits-of-using-forestdb"><a class="anchor" href="#benefits-of-using-forestdb"></a>Benefits of using ForestDB</h5>
<div class="ulist">
<ul>
<li>
<p>Faster (2x to 5x as fast, depending on the operation and data set)</p>
</li>
<li>
<p>Better concurrency (writers never block readers)</p>
</li>
<li>
<p>Lower RAM footprint (data caches are shared between threads)</p>
</li>
<li>
<p>Database compaction is automatic and runs periodically in the background</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Add the following in the application level <code>build.gradle</code> file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">dependencies {
    compile 'com.couchbase.lite:couchbase-lite-android:+'
    compile 'com.couchbase.lite:couchbase-lite-android-forestdb:+'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="choosing-a-storage-engine"><a class="anchor" href="#choosing-a-storage-engine"></a>Choosing a storage engine</h4>
<div class="sect4">
<h5 id="for-new-databases"><a class="anchor" href="#for-new-databases"></a>For new databases</h5>
<div class="paragraph">
<p>At runtime, you need to tell the <code>Manager</code> you want to use ForestDB, by setting its <code>storageType</code> to ForestDB.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">manager.setStorageType("ForestDB");</code></pre>
</div>
</div>
<div class="paragraph">
<p>This only applies to new databases.
Existing local database files will always open with the same storage engine that created them.</p>
</div>
</div>
<div class="sect4">
<h5 id="upgrading-databases-to-forestdb"><a class="anchor" href="#upgrading-databases-to-forestdb"></a>Upgrading databases to ForestDB</h5>
<div class="paragraph">
<p>It&#8217;s possible to upgrade an existing local database file from SQLite to ForestDB.
You can use this option if you have an already-shipping app and want your existing installs to use ForestDB as well as new installs.
To do this, you use an alternate method to open your database, one that allows you to specify a set of options.</p>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset5_android"></a>Android</p>
</li>
<li>
<p><a id="tabset5_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset5_android">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Manager manager = new Manager(new AndroidContext(this), null);

DatabaseOptions options = new DatabaseOptions();
options.setCreate(true);
options.setStorageType("ForestDB");
Database database = manager.openDatabase("my-database", options);</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset5_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Manager manager = new Manager(new JavaContext("data"), Manager.DEFAULT_OPTIONS);

DatabaseOptions options = new DatabaseOptions();
options.setCreate(true);
options.setStorageType("ForestDB");
Database database = manager.openDatabase("my-database", options);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Setting the options' <code>storageType</code> property forces the database to use the ForestDB format.
If it&#8217;s currently in SQLite format, it will be converted in place before being opened.
(The next time, it will just open normally, since it&#8217;s already ForestDB.)</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="concurrency-support-2"><a class="anchor" href="#concurrency-support-2"></a>Concurrency support</h3>
<div class="paragraph">
<p>It is safe to call Couchbase Lite from multiple threads on the Android / Java platform.
If you find any thread safety related issues, please report a bug.</p>
</div>
</div>
<div class="sect2">
<h3 id="database-notifications"><a class="anchor" href="#database-notifications"></a>Database notifications</h3>
<div class="paragraph">
<p>You can register for notifications when documents are added/updated/deleted from a database.
In practice, applications don&#8217;t use these as much as live queries and document change notifications;
still this facility can be useful if you want a lightweight way to tell whenever anything&#8217;s changed in a database.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try {
     Database db = manager.getExistingDatabase("my-database");

     if(db != null) {
         db.addChangeListener(new ChangeListener() {
             public void changed(ChangeEvent event) {
                 for (DocumentChange change : event.getChanges()) {
                    /* Access the document revision related to that change. */
                    Map&lt;String, Object&gt; properties = change.getAddedRevision().getBody().getProperties();
                 }
             }
         });
     }

 } catch (IOException e) {
     Log.e(TAG, "Cannot delete database", e);
     return;
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above shows how to access the revision linked to the document change that is being processed.
The notifications may not be delivered immediately after the document changes.
Notifications aren&#8217;t delivered during a transaction;
they&#8217;re buffered up for delivery after the transaction completes.</p>
</div>
</div>
<div class="sect2">
<h3 id="database-housekeeping"><a class="anchor" href="#database-housekeeping"></a>Database housekeeping</h3>
<div class="paragraph">
<p>Refer to the <a href="#revision">Revision</a> guide to learn about compaction and pruning to manage the database size.</p>
</div>
</div>
<div class="sect2">
<h3 id="deleting-a-database"><a class="anchor" href="#deleting-a-database"></a>Deleting a database</h3>
<div class="paragraph">
<p>The <code>delete</code> method permanently deletes a database&#8217;s file and all its attachments.
After this, you should immediately set your Database reference to nil/null and not call it again.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try {
     myDatabase.delete();
} catch (IOException e) {
     Log.e(TAG, "Cannot delete database", e);
     return;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="document"><a class="anchor" href="#document"></a>Document</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In a <em>document database</em> such as Couchbase Lite, the primary entity stored in a database is called a <strong>document</strong> instead of a "row" or "record".
This reflects the fact that a document can store more data, with more structure, than its equivalent in other databases.</p>
</div>
<div class="paragraph">
<p>In Couchbase Lite, a document&#8217;s <strong>body</strong> takes the form of a JSON object&#8201;&#8212;&#8201;a collection of key/value pairs where the values can be different types of data such as numbers, strings, arrays or even nested objects.
Every document is identified by a <strong>document ID</strong>, which can be automatically generated (as a UUID) or determined by the application;
the only constraints are that it must be unique within the database, and it can&#8217;t be changed.</p>
</div>
<div class="paragraph">
<p>In addition, a document can contain attachments, named binary blobs that are useful for storing large media files or other non-textual data.
Couchbase Lite supports attachments of unlimited size, although the Sync Gateway currently imposes a 20MB limit for attachments synced to it.</p>
</div>
<div class="paragraph">
<p>Couchbase Lite keeps track of the change history of every document, as a series of revisions.
This is somewhat like a version control system such as Git or Subversion, although its main purpose is not to be able to access old data, but rather to assist the replicator in deciding what data to sync and what documents have conflicts.
Every time a document is created or updated, it is assigned a new unique <strong>revision ID</strong>.
The IDs of past revisions are available, and the contents of past revisions may be available, but only if the revision was created locally and the database has not yet been compacted.</p>
</div>
<div class="paragraph">
<p>To summarize, a document has the following attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A document ID</p>
</li>
<li>
<p>A current revision ID (which changes every time the document is updated)</p>
</li>
<li>
<p>A history of past revision IDs (usually linear, but will form a branching tree if the document has or has had conflicts)</p>
</li>
<li>
<p>A body in the form of a JSON object, i.e. a set of key/value pairs</p>
</li>
<li>
<p>Zero or more named binary attachments</p>
</li>
<li>
<p>Creating, Reading, Updating and Deleting documents (CRUD)</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="creating-reading-updating-and-deleting-documents-crud"><a class="anchor" href="#creating-reading-updating-and-deleting-documents-crud"></a>Creating, Reading, Updating and Deleting documents (CRUD)</h3>
<div class="paragraph">
<p>Couchbase Lite of course supports the typical database "CRUD" operations on documents: Create, Read, Update, Delete.</p>
</div>
<div class="sect3">
<h4 id="creating-documents"><a class="anchor" href="#creating-documents"></a>Creating documents</h4>
<div class="paragraph">
<p>You can create a document with or without giving it an ID.
If you don&#8217;t need or want to define your own ID, call the Database method <code>createDocument</code>, and the ID will be generated randomly in the form of a Universally Unique ID (UUID), which looks like a string of hex digits.
The uniqueness ensures that there is no chance of an accidental collision by two client apps independently creating different documents with the same ID, then replicating to the same server.</p>
</div>
<div class="paragraph">
<p>The following example shows how to create a document with an automatically-assigned UUID:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Map&lt;String, Object&gt; properties = new HashMap&lt;String, Object&gt;();
properties.put("type", "list");
properties.put("title", title);
properties.put("created_at", currentTimeString);
properties.put("owner", "profile:" + userId);
properties.put("members", new
ArrayList&lt;String&gt;());
Document document = database.createDocument();
document.putProperties(properties);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you do want to choose the document&#8217;s ID, just call the Database method <code>getDocument</code>, just as you would to retrieve an existing document.
If the document doesn&#8217;t exist yet, you still get a valid Document object, it just doesn&#8217;t have any revisions or contents yet.
The first time you save the document, it will be added persistently to the database.
If a document does already exist with the same ID, saving the document will produce a conflict error.</p>
</div>
<div class="paragraph">
<p>The following example shows how to create a document with an custom ID:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Map&lt;String, Object&gt; properties = new HashMap&lt;String, Object&gt;();
properties.put("title", "Little, Big");
properties.put("author", "John Crowley");
properties.put("published", 1982);
Document document = database.getDocument("978-0061120053");
try {
    document.putProperties(properties);
} catch (CouchbaseLiteException e) {
    Log.e(TAG, "Cannot save document", e);
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
It&#8217;s up to you whether to assign your own IDs or use random UUIDs.
If the documents are representing entities that already have unique IDs&#8201;&#8212;&#8201;like email addresses or employee numbers&#8201;&#8212;&#8201;then it makes sense to use those, especially if you need to ensure that there can&#8217;t be two documents representing the same entity.
For example, in a library cataloging app, you wouldn&#8217;t want two librarians to independently create duplicate records for the same book, so you might use the book&#8217;s ISBN as the document ID to enforce uniqueness.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="reading-documents"><a class="anchor" href="#reading-documents"></a>Reading documents</h4>
<div class="paragraph">
<p>To retrieve a Document object given its ID, call the Database method <code>getDocument</code>.
As described in the previous section, if there is no document with this ID, this method will return a valid but empty Document object.
(If you would rather get a null/nil result for a nonexistent document, call <code>existingDocumentWithID</code> instead.)</p>
</div>
<div class="paragraph">
<p>Document objects, like document IDs, are unique.
That means that there is never more than one Document object in memory that represents the same document.
If you call <code>getDocument</code> multiple times with the same ID, you get the same Document object every time.
This helps conserve memory, and it also makes it easy to compare Document object references (pointers)&#8201;&#8212;&#8201;you can just use <code>==</code> to check whether two references refer to the same document.</p>
</div>
<div class="paragraph">
<p>Loading a Document object doesn&#8217;t immediately read its properties from the database.
Those are loaded on demand, when you call an accessor method like <code>getProperties</code> (or access the Objective-C property <code>properties</code>).
The properties are represented using whatever platform type is appropriate for a JSON object.
In Objective-C they&#8217;re an <code>NSDictionary</code>, in Java a <code>Map&lt;String,Object&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a simple example of getting a document&#8217;s properties:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Document doc = database.getDocument(myDocId);
// We can directly access properties from the document object:
doc.getProperty("title");
// Or go through its properties dictionary:
Map&lt;String, Object&gt; properties = doc.getProperties();
String owner = (String) properties.get("owner");</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>getProperties</code> method is actually just a convenient shortcut for getting the Document&#8217;s <code>currentRevision</code> and then getting its <code>properties</code>&#8201;&#8212;&#8201;since a document usually has multiple revisions, the properties really belong to a revision.
Every existing document has a current revision (in fact that&#8217;s how you can tell whether a document exists or not).
Almost all the time you&#8217;ll be accessing a document&#8217;s current revision, which is why the convenient direct properties accessor exists.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="updating-documents"><a class="anchor" href="#updating-documents"></a>Updating documents</h4>
<div class="paragraph">
<p>There are two methods that update a document: <code>putProperties</code> and <code>update</code>.
We&#8217;ll cover them both, then explain why they&#8217;re different.</p>
</div>
<div class="paragraph">
<p><code>putProperties</code> is simpler: given a new JSON object, it replaces the document&#8217;s body with that object.
Actually what it does is creates a new revision with those properties and makes it the document&#8217;s current revision.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Document doc = database.getDocument(myDocID);
Map&lt;String, Object&gt; properties = new HashMap&lt;String, Object&gt;();
properties.putAll(doc.getProperties());
properties.put("title", title);
properties.put("notes", notes);
try {
    doc.putProperties(properties);
} catch (CouchbaseLiteException e) {
    e.printStackTrace();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>update</code> instead takes a callback function or block (the details vary by language).
It loads the current revision&#8217;s properties, then calls this function, passing it an <code>UnsavedRevision</code> object, whose properties are a mutable copy of the current ones.
Your callback code can modify this object&#8217;s properties as it sees fit;
after it returns, the modified revision is saved and becomes the current one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Document doc = database.getDocument(myDocId);
doc.update(new Document.DocumentUpdater() {
    @Override
    public boolean update(UnsavedRevision newRevision) {
        Map&lt;String, Object&gt; properties = newRevision.getProperties();
        properties.put("title", title);
        properties.put("notes", notes);
        newRevision.setUserProperties(properties);
        return true;
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Whichever way you save changes, you need to consider the possibility of <strong>update conflicts</strong>.
Couchbase Lite uses Multiversion Concurrency Control (MVCC) to guard against simultaneous changes to a document.
(Even if your app code is single-threaded, the replicator runs on a background thread and can be pulling revisions into the database at the same time you&#8217;re making changes).</p>
</div>
<div class="paragraph">
<p>Here&#8217;s the typical sequence of events that creates an update conflict:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Your code reads the document&#8217;s current properties, and constructs a modified copy to save</p>
</li>
<li>
<p>Another thread (perhaps the replicator) updates the document, creating a new revision with different properties</p>
</li>
<li>
<p>Your code updates the document with its modified properties</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Clearly, if your update were allowed to proceed, the change from step 2 would be overwritten and lost.
Instead, the update will fail with a conflict error.
Here&#8217;s where the two API calls differ:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>putProperties simply returns the error to you to handle.
You&#8217;ll need to detect this type of error, and probably handle it by re-reading the new properties and making the change to those, then trying again.</p>
</li>
<li>
<p>update is smarter: it handles the conflict error itself by re-reading the document, then calling your block again with the updated properties, and retrying the save.
It will keep retrying until there is no conflict.</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Of the two techniques, calling update may be a bit harder to understand initially, but it actually makes your code simpler and more reliable.
We recommend it.
(Just be aware that your callback block can be called multiple times.)
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="deleting-documents"><a class="anchor" href="#deleting-documents"></a>Deleting documents</h4>
<div class="paragraph">
<p>The <code>delete</code> method (<code>deleteDocument:</code> in Objective-C) deletes a document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Document task = (Document) database.getDocument("task1");
task.delete();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Deleting a document actually just creates a new revision (informally called a "tombstone") that has the special <code>_deleted</code> property set to <code>true</code>.
This ensures that the deletion will replicate to the server, and then to other endpoints that pull from that database, just like any other document revision.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It&#8217;s possible for the delete call to fail with a conflict error, since it&#8217;s really just a special type of putProperties.
In other words, something else may have updated the document at the same time you were trying to delete it.
It&#8217;s up to your app whether it&#8217;s appropriate to retry the delete operation.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you need to preserve one or more fields in a document that you want to <code>delete</code> (like a record of who deleted it or when it was deleted) you can avoid the delete method;
just update the document and set the <code>UnsavedRevision</code><code>'s `deletion</code> property to <code>true</code>, or set JSON properties that include a <code>"_deleted"</code> property with a value of <code>true</code>.
You can retain all of the fields, as shown in the following example, or you can remove specified fields so that the tombstone revision contains only the fields that you need.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Document doc = database.getDocument(myDocId);
doc.update(new Document.DocumentUpdater() {
    @Override
    public boolean update(UnsavedRevision newRevision) {
        newRevision.setIsDeletion(true);
        Map&lt;String, Object&gt; properties = newRevision.getUserProperties();
        properties.put("deleted_at", currentTimeString);
        newRevision.setUserProperties(properties);
        return true;
    }
})</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="document-expiration-ttl"><a class="anchor" href="#document-expiration-ttl"></a>Document expiration (TTL)</h3>
<div class="paragraph">
<p>Documents in a local database can have an expiration time.
After that time, they are automatically purged from the database - this completely removes them, freeing the space they occupied.
This feature was introduced in Couchbase Lite 1.3.</p>
</div>
<div class="paragraph">
<p>The following example sets the TTL for a document to 5 seconds from the current time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Date tll = new Date(System.currentTimeMillis() + 5000);
Document doc = database.createDocument();
Map&lt;String, Object&gt; properties = new HashMap&lt;String, Object&gt;();
properties.put("foo", "bar");
doc.putProperties(properties);
doc.setExpirationDate(ttl);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Expiration timing is not highly precise.
The times are stored with one-second granularity, and the timer that triggers expiration may be delayed slightly by the operating system or by other activity on the database thread.
Expiration won&#8217;t happen while the app is not running;
this means it may be triggered soon after the app is activated or launched, to catch up with expiration times that have already passed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As with the existing explicit <strong>purge</strong> mechanism, this applies only to the local database;
it has nothing to do with replication.
This expiration time is not propagated when the document is replicated.
The purge of the document does not cause it to be deleted on any other database.
If the document is later updated on a remote database that the local database pulls from, the new revision will be pulled and the document will reappear.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="document-change-notifications"><a class="anchor" href="#document-change-notifications"></a>Document change notifications</h3>
<div class="paragraph">
<p>You can register for notifications when a particular document is updated or deleted.
This is very useful if you&#8217;re display a user interface element whose content is based on the document: use the notification to trigger a redisplay of the view.</p>
</div>
<div class="paragraph">
<p>You can use change events for the following purposes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>To be notified when new revisions are added to a document</p>
</li>
<li>
<p>To be notified when a document is deleted</p>
</li>
<li>
<p>To be notified when a document enters into a conflicted state</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Document doc = database.createDocument();
doc.addChangeListener(new Document.ChangeListener() {
    @Override
    public void changed(Document.ChangeEvent event) {
        DocumentChange docChange = event.getChange();
        String msg = "New revision added: %s. Conflict: %s";
        msg = String.format(msg,
        docChange.getAddedRevision(), docChange.isConflict());
        Log.d(TAG, msg);
        documentChanged.countDown();
    }
});
doc.createRevision().save();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="conflicts"><a class="anchor" href="#conflicts"></a>Conflicts</h3>
<div class="paragraph">
<p>So far we&#8217;ve been talking about a conflict as an error that occurs when you try to update a document that&#8217;s been updated since you read it.
In this scenario, Couchbase Lite is able to stop the conflict before it happens, giving your code a chance to re-read the document and incorporate the other changes.</p>
</div>
<div class="paragraph">
<p>However, there&#8217;s no practical way to prevent a conflict when the two updates are made on different instances of the database.
Neither app even knows that the other one has changed the document, until later on when replication propagates their incompatible changes to each other.
A typical scenario is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Molly creates DocumentA; the revision is 1-5ac</p>
</li>
<li>
<p>DocumentA is synced to Naomi&#8217;s device; the latest revision is still 1-5ac</p>
</li>
<li>
<p>Molly updates DocumentA, creating revision 2-54a</p>
</li>
<li>
<p>Naomi makes a different change to DocumentA, creating revision 2-877</p>
</li>
<li>
<p>Revision 2-877 is synced to Molly&#8217;s device, which already has 2-54a, putting the document in conflict</p>
</li>
<li>
<p>Revision 2-54a is synced to Naomi&#8217;s device, which already has 2-877, similarly putting the local document in conflict</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>At this point, even though DocumentA is in a conflicted state, it needs to have a current revision.
That is, when your app calls <code>getProperties</code>, Couchbase Lite has to return something.
It chooses one of the two conflicting revisions (2-877 and 2-54a) as the "winner".
The choice is deterministic, which means that every device that is faced with the same conflict will pick the same winner, without having to communicate.
In this case it just compares the revision IDs "2-54a" and "2-877" and picks the higher one, "2-877".</p>
</div>
<div class="paragraph">
<p>To be precise, Couchbase Lite uses the following rules to handle conflicts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The winner is the undeleted leaf revision on the longest revision branch (i.e. with the largest prefix number in its revision ID).</p>
</li>
<li>
<p>If there are no undeleted leaf revisions, the deletion (tombstone) on the longest branch wins.</p>
</li>
<li>
<p>If there&#8217;s a tie, the winner is the one whose revision ID sorts higher in a simple ASCII comparison.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Couchbase Lite does not automatically merge the contents of conflicts.
Automated merging would run the risk of giving wrong or undesired results in many cases;
only you know your document schemas well enough to decide how conflicts should be merged.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In some cases this simple "one revision wins" rule is good enough.
For example, in a grocery list if two people rename the same item, one of them will just see that their change got overwritten, and may do it over again.
But usually the details of the document content are more important, so the application will want to detect and resolve conflicts.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Resolving conflicts can also save the space in the database.
Conflicting revisions stay in the database indefinitely until resolved, even surviving compactions.
Therefore, it makes sense to deal with the conflict by at least deleting the non-winning revision.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Another reason to resolve conflicts is to implement business rules.
For example, if two sales associates update the same customer record and it ends up in conflict, you might want the sales manager to resolve the conflict and "hand merge" the two conflicting records so that no information is lost.</p>
</div>
<div class="paragraph">
<p>There are two alternative ways to resolve a conflict:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Pick a winner.</strong> Just decide which of the two changes should win, and delete the other one.
The deleted revision will no longer be eligible as a conflict winner, so there won&#8217;t be any more conflict.</p>
</li>
<li>
<p><strong>Merge.</strong> Consider the contents of both conflicting revisions and construct a new revision that incorporates both.
The details are, of course, application-dependent, and might even require user interaction.
Then resolve the conflict by saving the merged revision, then deleting the old losing conflict revision.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows how to resolve a conflict:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">final Document doc = database.getDocument(myDocID);
final List&lt;SavedRevision&gt; conflicts = doc.getConflictingRevisions();
if (conflicts.size() &gt; 1) {
        // There is more than one current revision, thus a conflict!
        database.runInTransaction(new TransactionalTask() {
                @Override
                public boolean run() {
                        try {
                                // Come up with a merged/resolved document in some way that's
                                // appropriate for the app. You could even just pick the body of
                                // one of the revisions.
                                Map&lt;String, Object&gt; mergedProps = mergeRevisions(conflicts);
                                // Delete the conflicting revisions to get rid of the conflict:
                                SavedRevision current = doc.getCurrentRevision();
                                for (SavedRevision rev : conflicts) {
                                        UnsavedRevision newRev = rev.createRevision();
                                        if (rev.getId().equals(current.getId())) {
                                                newRev.setProperties(mergedProps);
                                        } else {
                                                newRev.setIsDeletion(true);
                                        }
                                        // saveAllowingConflict allows 'rev' to be updated even if it
                                        // is not the document's current revision.
                                        newRev.save(true);
                                }
                        } catch (CouchbaseLiteException e) {
                                return false;
                        }
                        return true;
                }
        });
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="document-conflict-faq"><a class="anchor" href="#document-conflict-faq"></a>Document Conflict FAQ</h3>
<div class="sect3">
<h4 id="what-if-both-devices-make-the-same-change-to-the-document-is-that-a-conflict"><a class="anchor" href="#what-if-both-devices-make-the-same-change-to-the-document-is-that-a-conflict"></a>What if both devices make the same change to the document? Is that a conflict?</h4>
<div class="paragraph">
<p>No.
The revision ID is derived from a digest of the document body.
So if two databases save identical changes, they end up with identical revision IDs, and Couchbase Lite (and the Sync Gateway) treat these as the same revision.</p>
</div>
</div>
<div class="sect3">
<h4 id="i-deleted-a-document-but-the-it-s-still-in-the-database-only-now-its-properties-are-different-what-happened"><a class="anchor" href="#i-deleted-a-document-but-the-it-s-still-in-the-database-only-now-its-properties-are-different-what-happened"></a>I deleted a document, but the it&#8217;s still in the database, only now its properties are different. What happened?</h4>
<div class="paragraph">
<p>Sounds like the document was in conflict and you didn&#8217;t realize it.
You deleted the winning revision, but that made the other (losing) revision become the current one.
If you delete the document again, it&#8217;ll actually go away.</p>
</div>
</div>
<div class="sect3">
<h4 id="how-can-i-get-the-properties-of-the-common-ancestor-revision-to-do-a-three-way-merge"><a class="anchor" href="#how-can-i-get-the-properties-of-the-common-ancestor-revision-to-do-a-three-way-merge"></a>How can I get the properties of the common ancestor revision, to do a three-way merge?</h4>
<div class="paragraph">
<p>You can&#8217;t always.
Couchbase Lite isn&#8217;t a version-control system and doesn&#8217;t preserve old revision bodies indefinitely.
But if the ancestor revision used to exist in your local database, and you haven&#8217;t yet compacted the database, you can still get its properties.
Get the <code>parentRevision</code> property of the current revision to get the ancestor, then see if its <code>properties</code> are still non-null.</p>
</div>
</div>
<div class="sect3">
<h4 id="how-can-i-tell-if-a-document-has-a-conflict"><a class="anchor" href="#how-can-i-tell-if-a-document-has-a-conflict"></a>How can I tell if a document has a conflict?</h4>
<div class="paragraph">
<p>Call its <code>getConflictingRevisions</code> method and see if more than one revision is returned.</p>
</div>
</div>
<div class="sect3">
<h4 id="how-can-i-tell-if-there-are-any-conflicts-in-the-database"><a class="anchor" href="#how-can-i-tell-if-there-are-any-conflicts-in-the-database"></a>How can I tell if there are any conflicts in the database?</h4>
<div class="paragraph">
<p>Use an all-documents query with the <code>onlyConflicts</code> mode.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="purging-documents"><a class="anchor" href="#purging-documents"></a>Purging documents</h3>
<div class="paragraph">
<p>Purging a document is different from deleting it;
it&#8217;s more like forgetting it.
The <code>purge</code> method removes all trace of a document (and all its revisions and their attachments) from the local database.
It has no effect on replication or on remote databases, though.</p>
</div>
<div class="paragraph">
<p>Purging is mostly a way to save disk space by forgetting about replicated documents that you don&#8217;t need anymore.
It has some slightly weird interactions with replication, though.
For example, if you purge a document, and then later the document is updated on the remote server, the next replication will pull the document into your database again.</p>
</div>
</div>
<div class="sect2">
<h3 id="special-properties"><a class="anchor" href="#special-properties"></a>Special Properties</h3>
<div class="paragraph">
<p>The body of a document contains a few special properties that store metadata about the document.
For the most part you can ignore these since the API provides accessor methods for the same information, but it can still be helpful to know what they are if you encounter them.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>_id</code>: The document ID.</p>
</li>
<li>
<p><code>_rev</code>: The revision ID.</p>
</li>
<li>
<p><code>_attachments</code>: Metadata about the document&#8217;s attachments.</p>
</li>
<li>
<p><code>_deleted</code>: Only appears in a deletion (tombstone) revision, where it has the value <code>true</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A leading underscore always denotes a reserved property.
Don&#8217;t use an underscore prefix for any of your own properties, and don&#8217;t change the value of any reserved property.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="revision"><a class="anchor" href="#revision"></a>Revision</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Couchbase Lite uses revisions to resolve conflicts detected during replication.
One significant difference from other databases is document versioning.
Couchbase Lite uses a technique called Multiversion Concurrency Control (MVCC) to manage conflicts between multiple writers.
This is the same technique used by version-control systems like Git or Subversion, and by WebDAV.
Document versioning is similar to the check-and-set mechanism (CAS) of Couchbase Server, except that in Couchbase Lite versioning is required rather than optional and the token is a UUID rather than an integer.</p>
</div>
<div class="paragraph">
<p>Every document has a special field called <code>_rev</code> that contains the revision ID.
The revision ID is assigned automatically each time the document is saved.
Every time a document is updated, it gets a different and unique revision ID.</p>
</div>
<div class="paragraph">
<p>When you save an update to an existing document, you must include its current revision ID.
If the revision ID you provide isn&#8217;t the current one, the update is rejected.
When this happens, it means some other endpoint snuck in and updated the document before you.
You need to fetch the new version, reconcile any changes, incorporate the newer revision ID, and try again.</p>
</div>
<div class="paragraph">
<p>Keep in mind that Couchbase Lite is not a version control system and you must not use the versioning feature in your application.
They&#8217;re there only to help with concurrency and resolving conflicts during replication.</p>
</div>
<div class="sect2">
<h3 id="resolving-conflicts"><a class="anchor" href="#resolving-conflicts"></a>Resolving Conflicts</h3>
<div class="paragraph">
<p>Revisions form a tree data structure since they can have multiple branches.
In the case where there are multiple branches, one or more conflicts exist and should be resolved per the application requirements.</p>
</div>
</div>
<div class="sect2">
<h3 id="tombstones"><a class="anchor" href="#tombstones"></a>Tombstones</h3>
<div class="paragraph">
<p>The reason that tombstone revisions exist is so that deletes can be sync&#8217;d to other databases.
If revisions were simply deleted with a naive approach, then there would be no easy way to sync up with other databases that contained the revision.</p>
</div>
<div class="paragraph">
<p>There is a special field in a revision&#8217;s JSON called <code>_deleted</code> which determines whether the revision is a tombstone revision or not.
A consequence of this fact is that tombstone revisions can hold arbitrary amounts of metadata, which can be useful for an application.
If the full metadata of the document is preserved in the tombstone revision, then a document could easily be restored to it&#8217;s last known good state after it&#8217;s been deleted at some point.</p>
</div>
<div class="paragraph">
<p>For examples of deleting revisions via adding a tombstone revision, refer to the guide on Documents.</p>
</div>
</div>
<div class="sect2">
<h3 id="saved-vs-unsaved-revision"><a class="anchor" href="#saved-vs-unsaved-revision"></a>Saved vs Unsaved Revision</h3>
<div class="paragraph">
<p>Here are the main differences between Saved and Unsaved Revision objects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Unsaved revisions have not yet been persisted to the database.</p>
</li>
<li>
<p>Saved revisions have already been persisted to the database.</p>
</li>
<li>
<p>Unsaved revisions are useful for adding attachments.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Unsaved Revisions are mainly useful for manipulating attachments, since they provide the only means to do so via the API.
See Attachments for examples of adding/removing attachments.</p>
</div>
</div>
<div class="sect2">
<h3 id="pruning"><a class="anchor" href="#pruning"></a>Pruning</h3>
<div class="paragraph">
<p>Pruning is the process that deletes the metadata and/or JSON bodies associated with old non-leaf revisions.
Leaf revisions are not impacted.
The process runs automatically every time a revision is added.
The <strong>maxRevTreeDepth</strong> value defaults to 20, which means that the metadata and JSON bodies of the last 20 revisions are retained in Couchbase Lite as shown on the animation below.</p>
</div>
<div class="paragraph">
<p>If there are conflicting revisions, the document may end up with <strong>disconnected branches</strong> after the pruning process.
In the animation below, the document has a conflicting branch (revisions 3 - 7).
When the current revision (or longest branch) reaches the 23rd update, the conflicting branch is cut off.
The revision tree is not in a corrupted state and the logic that chooses the winning revision still applies.
But it may make it impossible to do certain merges to resolve conflicts and occupy disk space that could have been free-ed if the conflict was resolved early on.</p>
</div>
</div>
<div class="sect2">
<h3 id="compaction"><a class="anchor" href="#compaction"></a>Compaction</h3>
<div class="paragraph">
<p>Compaction is defined as the process of purging the JSON bodies of non-leaf revisions.
As shown on the diagram below, only properties with a leading underscore (<code>_</code> is the character to denote properties reserved for Couchbase) are kept to construct the revision tree.</p>
</div>
<div class="paragraph">
<p>Compaction can only be invoked manually via the <code>Database.compact()</code> method.
The compaction process does not remove JSON bodies of leaf nodes.
Hence, it is important to resolve conflicts in your application in order to re-claim disk space when the compaction process is executed.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="attachment"><a class="anchor" href="#attachment"></a>Attachment</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Attachments store data associated with a document, but are not part of the document&#8217;s JSON object.
Their primary purpose is to make it efficient to store large binary data in a document.
Binary data stored in JSON has to be base64-encoded into a string, which inflates its size by 33%.
Also, binary data blobs are often large (think of camera images or audio files), and big JSON documents are slow to parse.</p>
</div>
<div class="paragraph">
<p>Attachments are uninterpreted data (blobs) stored separately from the JSON body.
A document can have any number of attachments, each with a different name.
Each attachment is also tagged with a MIME type, which isn&#8217;t used by Couchbase Lite but can help your application interpret its contents.
On Couchbase Lite, attachments can be arbitrarily large, and are only read on demand, not when you load a <code>Document</code> object.
On Sync Gateway, the maximum content size is 20 MB per attachment.
If a document&#8217;s attachment is over 20 MB, the document will be replicated but not the attachment.</p>
</div>
<div class="paragraph">
<p>Attachments also make replication more efficient.
When a document that contains pre-existing attachments is synced, only attachments that have changed since the last sync are transferred over the network.
In particular, changes to document JSON values will <strong>not</strong> cause Couchbase Lite to re-send attachment data when the attachment has not changed.</p>
</div>
<div class="paragraph">
<p>In the native API, attachments are represented by the <code>Attachment</code> class.
Attachments are available from a <code>Revision</code> object.
From a <code>Document</code>, you get to the attachments via its <code>currentRevision</code>.</p>
</div>
<div class="sect2">
<h3 id="reading-attachments"><a class="anchor" href="#reading-attachments"></a>Reading attachments</h3>
<div class="paragraph">
<p>The <code>Revision</code> class has a number of methods for accessing attachments:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>attachmentNames</code> returns the names of all the attachments.</p>
</li>
<li>
<p><code>attachmentNamed</code> returns an <code>Attachment</code> object given its name.</p>
</li>
<li>
<p><code>attachments</code> returns all the attachments as <code>Attachment</code> objects.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Once you have an <code>Attachment</code> object, you can access its name, MIME type and content length.
The accessors for the content vary by platform: on iOS it&#8217;s available as an <code>NSData</code> object or as an <code>NSURL</code> pointing to a read-only file;
in Java you read the data from an <code>InputStream</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Load an JPEG attachment from a document into a Drawable:
Document doc = database.getDocument("Robin");
Revision rev = doc.getCurrentRevision();
Attachment att = rev.getAttachment("photo.jpg");
if (att != null) {
    InputStream is = att.getContent();
    Drawable d = Drawable.createFromStream(is, "src name");
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="writing-and-deleting-attachments"><a class="anchor" href="#writing-and-deleting-attachments"></a>Writing (and deleting) attachments</h3>
<div class="paragraph">
<p>To create an attachment, first create a mutable <code>UnsavedRevision</code> object by calling <code>createRevision</code> on the document&#8217;s <code>currentRevision</code>.
Then call <code>setAttachment</code> on the new revision to add an attachment.
(You can of course also change the JSON by modifying the revision&#8217;s properties.)
Finally you call <code>save</code> to save the new revision.</p>
</div>
<div class="paragraph">
<p>Updating an attachment&#8217;s content (or type) works exactly the same way: the <code>setAttachment</code> method will replace any existing attachment with the same name.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Add an image in a callback after invoking the Android Camera activity
protected void onActivityResult(int requestCode, int resultCode, Intent data){
    InputStream stream = null;
    if (requestCode == REQUEST_CODE &amp;&amp; resultCode == Activity.RESULT_OK) {
        InputStream stream = getContentResolver().openInputStream(data.getData());
        // Add or update an image to a document as a JPEG attachment:
        Document doc = database.getDocument("Robin");
        UnsavedRevision newRev = doc.getCurrentRevision().createRevision();
        newRev.setAttachment("photo.jpg", "image/jpeg", stream);
        newRev.save();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To delete an attachment, just call <code>removeAttachment</code> instead of <code>setAttachment</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Remove an attachment from a document:
Document doc = database.getDocument("Robin");
UnsavedRevision newRev = doc.getCurrentRevision().createRevision();
newRev.removeAttachment("photo.jpg");
// (You could also update newRev.properties while you're here)
newRev.save();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="attachment-storage"><a class="anchor" href="#attachment-storage"></a>Attachment storage</h3>
<div class="paragraph">
<p>In general, you don&#8217;t need to think about where and how Couchbase Lite is storing data.
But since attachments can occupy a lot of space, it can be helpful to know where that space is and how it&#8217;s managed.</p>
</div>
<div class="paragraph">
<p>Attachments aren&#8217;t stored in the database file itself.
Instead they are individual files, contained in a directory right next to the database file.
Each attachment file has a cryptic name that is actually a SHA-1 digest of its contents.</p>
</div>
<div class="paragraph">
<p>As a consequence of the naming scheme, attachments are de-duplicated: if multiple attachments in the same database have exactly the same contents, the data is only stored once in the filesystem.</p>
</div>
<div class="paragraph">
<p>Updating a document&#8217;s attachment does <strong>not</strong> immediately remove the old version of the attachment.
And deleting a document does not immediately delete its attachments.
An attachment file has to remain on disk as long as there are any document revisions that reference it, And a revision persists until the next database compaction after it&#8217;s been replaced or deleted.
(Orphaned attachment files are deleted from disk as part of the compaction process.)
So if you&#8217;re concerned about the space taken up by attachments, you should compact the database frequently, or at least after making changes to large attachments.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="view"><a class="anchor" href="#view"></a>View</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A View is a persistent index of documents in a database, which you then query to find data.
Couchbase Lite doesn&#8217;t have a query language like SQL;
instead, it uses a technique called map/reduce to generate indexes (views) according to arbitrary app-defined criteria.
Queries can then look up a range of rows from a view, and either use the rows' keys and values directly or get the documents they came from.</p>
</div>
<div class="paragraph">
<p>The main component of a view (other than its name) is its <strong>map function</strong>.
This function is written in the same language as your app&#8212;&#8203;most likely Objective-C or Java&#8212;&#8203;so it&#8217;s very flexible.
It takes a document&#8217;s JSON as input, and <strong>emits</strong> (outputs) any number of key/value pairs to be indexed.
The view generates a complete index by calling the map function on every document in the database, and adding each emitted key/value pair to the index, sorted by key.
For example, a map function might grind through an address-book database and produce a set of mappings from names to phone numbers.
The resulting index is persistent, and updated incrementally as documents change.
(It&#8217;s very much like the type of index a SQL database creates internally to optimize queries.)</p>
</div>
<div class="paragraph">
<p>A view may also have a <strong>reduce function</strong>.
If present, it can be used during queries to combine multiple rows into one.
It can be used to compute aggregate values like totals or averages, or to group rows by common criteria (like collecting all the artists in a record collection).
We&#8217;ll explain reduce functions later on.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<strong>A view is not a query, it&#8217;s an index.</strong>
Views are persistent, and need to be updated (incrementally) whenever documents change, so having large numbers of them can be expensive.
Instead, it&#8217;s better to have a smaller number of views that can be queried in interesting ways.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="creating-and-initializing-views"><a class="anchor" href="#creating-and-initializing-views"></a>Creating and initializing views</h3>
<div class="paragraph">
<p><code>View</code> objects belong to a <code>Database</code>.
You create or find a view by calling the database&#8217;s <code>viewNamed</code> method, which will create and return a new <code>View</code> if none exists by that name.</p>
</div>
<div class="paragraph">
<p>Even though a view is persistent, its map and reduce functions aren&#8217;t: they&#8217;re just function pointers (or blocks, or inner classes) and have to be registered at runtime, before the view is queried.
It&#8217;s good practice to set up views when your app starts up, right after opening the database:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Create a view and register its map function:
View phoneView = database.getView("phones");
phoneView.setMap(new Mapper() {
    @Override
    public void map(Map&lt;String, Object&gt; document, Emitter emitter) {
        List&lt;String&gt; phones = (List) document.get("phones");
        for (String phone : phones) {
            emitter.emit(phone, document.get("name"));
        }
    }
}, "2");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>version</code> parameter to <code>setMapBlock</code> takes a bit of explanation.
During development, and as you update the app, you may change the behavior of a map function.
This invalidates any existing index generated by that function, so the next time the app runs, the view should rebuild the index from scratch using the new function.
Unfortunately the view indexer can&#8217;t tell that the map function has changed because it can&#8217;t see its source code! Instead, you have to provide a version string that the indexer can compare, and you must change that string whenever you change the function.
The easiest thing to remember is just to set the version to "1" initially, and then increment it every time you edit any source code in the map function (or any function of yours that it calls).</p>
</div>
</div>
<div class="sect2">
<h3 id="querying-views"><a class="anchor" href="#querying-views"></a>Querying views</h3>
<div class="paragraph">
<p>You query a view by using a <code>Query</code> object that you create from a <code>View</code> by calling <code>createQuery</code>.
This is a big topic, and is covered in a separate article on the <code>Query</code> class.</p>
</div>
</div>
<div class="sect2">
<h3 id="map-functions"><a class="anchor" href="#map-functions"></a>Map functions</h3>
<div class="sect3">
<h4 id="understanding-map-functions"><a class="anchor" href="#understanding-map-functions"></a>Understanding map functions</h4>
<div class="paragraph">
<p>As discussed in the introduction, a map function&#8217;s job is to look at a document&#8217;s JSON contents and from them produce (emit) zero or more key/value pairs to be indexed.
If you know SQL, you can think of it as corresponding to the expressions that immediately follow the <code>SELECT</code> and <code>WHERE</code> keywords, only more powerful because you have the full power of a programming language available.</p>
</div>
<div class="paragraph">
<p>For discussion purposes, here&#8217;s a simple map function in JavaScript:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">function(doc) {
    if (doc["type"] == "person")
        emit(doc["name"], doc["phone"]);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function works with a database that contains, among other things, documents representing people, which are tagged with a <code>type</code> property whose value is &#8220;person&#8221;.
(This use of a <code>type</code> property is a common idiom.)
Every person document contains <code>name</code> and <code>phone</code> properties.
The map function simply checks whether the document represents a person, and if it does, it calls <code>emit</code> to add the name and phone number to the index.</p>
</div>
<div class="paragraph">
<p>The resulting index maps names to phone numbers.
You can query it to look up someone by name and find their phone number.
You can also query it to get ranges of names, in alphabetical order, which is very useful for driving GUI list views.</p>
</div>
</div>
<div class="sect3">
<h4 id="rules-for-the-map-function"><a class="anchor" href="#rules-for-the-map-function"></a>Rules for the map function</h4>
<div class="paragraph">
<p>The map function is called by the indexer to help generate an index, and it has to meet certain requirements, otherwise the index won&#8217;t be consistent.
It&#8217;s important to understand some rules so you can create a proper map function, otherwise your queries can misbehave in strange ways.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>It must be a "https://en.wikipedia.org/wiki/Pure_function[pure]" function:</strong> That means any time it&#8217;s called with the same input, it must produce exactly the same output.
In other words, it can&#8217;t use any external state, just its input JSON.</p>
</li>
<li>
<p><strong>It can&#8217;t have side effects:</strong> It shouldn&#8217;t change any external state, because it&#8217;s unpredictable when it&#8217;s called or how often it&#8217;s called or in what order documents are passed to it.</p>
</li>
<li>
<p><strong>It must be thread-safe:</strong> It may be called on a background thread belonging to the indexer, or even in parallel on several threads at once.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In particular, avoid these common mistakes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Don&#8217;t do anything that depends on the current date and time&#8201;&#8212;&#8201;that breaks the first rule, since your function&#8217;s output can change depending on the date/time it&#8217;s called.
Common mistakes include emitting the current time as a timestamp, emitting a person&#8217;s age, or emitting only documents that have been modified in the past week.</p>
</li>
<li>
<p>Don&#8217;t try to "parameterize" the map function by referring to an external variable whose value you change when querying.
It won&#8217;t work.
People sometimes try this because they want to find various subsets of the data, like all the items of a particular color.
Instead, emit all the values of that property, and use a key range in the query to pick out the rows with the specific value you want.</p>
</li>
<li>
<p>Don&#8217;t make any assumptions about when the map function is called.
That&#8217;s an implementation detail of the indexer.
(For example, it&#8217;s not called every time a document changes.)</p>
</li>
<li>
<p>Avoid having the map function call out into complex external code.
That code might change later on to be stateful or have side effects, breaking your map function.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="keys-and-values"><a class="anchor" href="#keys-and-values"></a>Keys and values</h4>
<div class="paragraph">
<p>Both the key and value passed to <code>emit</code> can be any JSON-compatible objects: not just strings, but also numbers, booleans, arrays, dictionaries/maps, and the special JSON <code>null</code> object (which is distinct from a null/nil pointer.)
In addition, the value emitted, but <em>not</em> the key, can be a null/nil pointer.
(It&#8217;s pretty common to not need a value in a view, in which case it&#8217;s more efficient to not emit one.)</p>
</div>
<div class="paragraph">
<p>Keys are commonly strings, but it turns out that arrays are a very useful type of key as well.
This is because of the way arrays are sorted: given two array keys, the first items are compared first, then if those match the second items are compared, and so on.
That means that you can use array keys to establish multiple levels of sorting.
If the map function emits keys of the form <em>[lastname, firstname]</em>, then the index will be sorted by last name, and entries with the same last name will be sorted by first name, just as if you&#8217;d used <em>ORDER BY lastname, firstname</em> in SQL.</p>
</div>
<div class="paragraph">
<p>Here are the exact rules for sorting (collation) of keys.
The most significant factor is the key&#8217;s object type;
keys of one type always sort before or after keys of a different type.
This list gives the types in order, and states how objects of that type are compared:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>null</p>
</li>
<li>
<p>false, true (in that order)</p>
</li>
<li>
<p>Numbers, in numeric order of course</p>
</li>
<li>
<p>Strings, case-insensitive.
The exact ordering is specified by the <a href="http://www.unicode.org/unicode/reports/tr10/">Unicode Collation Algorithm</a>.
This is <strong>not</strong> the same as ASCII ordering, so the results might surprise you&#8201;&#8212;&#8201;for example, all symbols, including "~", sort before alphanumeric characters.</p>
</li>
<li>
<p>Arrays, compared item-by-item as described above.</p>
</li>
<li>
<p>Maps/dictionaries, also compared item-by-item.
Unfortunately the order of items is ambiguous (since JSON doesn&#8217;t specify any ordering of keys, and most implementations use hash tables which randomize the order) so using these as keys isn&#8217;t recommended.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="the-source-document-and-redirection"><a class="anchor" href="#the-source-document-and-redirection"></a>The source document, and redirection</h4>
<div class="paragraph">
<p>In addition to its key and value, every index row also remembers the ID of the document that emitted it.
This can be accessed at query time via the <code>QueryRow.documentID</code> property, or more commonly via the shortcut <code>QueryRow.document</code> which uses the ID to load the Document object.</p>
</div>
<div class="paragraph">
<p>It can sometimes be useful to redirect this reference, i.e. to make the index row point to a different document instead.
You do this by emitting a value that&#8217;s a dictionary with a key <code>_id</code> whose value is the document ID you want the row to reference.
The <code>QueryRow.documentID</code> and accessors will then use this document ID instead.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// This example indexes documents that record Facebook-style "likes".
// When querying, the document we really want to look at is the post being
// liked, so we redirect the emitted row at that document.
view.setMap(new Mapper() {
    @Override
    public void map(Map&lt;String, Object&gt; document, Emitter emitter) {
        if (document.get("type").equals("like")) {
            String associatedID = (String) document.get("likedPostID");
            List&lt;Object&gt; key = new ArrayList&lt;Object&gt;();
            key.add(document.get("creator"));
            key.add(document.get("date"));
            HashMap&lt;String, Object&gt; value = new HashMap&lt;String, Object&gt;();
            value.put("_id", associatedID);
            emitter.emit(key, value);
        }
    }
}, "1");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even if you&#8217;ve used the redirect technique, at query time you can still recover the ID of the actual document that emitted the row, by using the <code>QueryRow.sourceDocumentID</code> property.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reduce-functions"><a class="anchor" href="#reduce-functions"></a>Reduce functions</h3>
<div class="sect3">
<h4 id="understanding-reduce-functions"><a class="anchor" href="#understanding-reduce-functions"></a>Understanding reduce functions</h4>
<div class="paragraph">
<p>Reduce functions are the other half of the map/reduce technique.
They&#8217;re optional, and less commonly used.
A reduce function post-processes the indexed key/value pairs generated by the map function, by aggregating the values together.
Very commonly it counts them, or (if the values are numeric) totals or averages them.
The reduce function boils down data the way a chef reduces a sauce.
Or if you&#8217;re a SQL user, reduce functions are like SQL aggregation operators like <code>COUNT</code> or <code>AVERAGE</code> (only you get to define your own).</p>
</div>
<div class="paragraph">
<p>In general, most views don&#8217;t need reduce functions, so don&#8217;t feel like you&#8217;re missing something if you haven&#8217;t written one.
But if you find yourself writing a query and counting the returned rows or adding up their values, you could do that more efficiently with a reduce function.</p>
</div>
<div class="paragraph">
<p><strong>A reduce function takes an ordered list of key/value pairs, aggregates them together into a single object, and returns that object.</strong>
Here&#8217;s an example, building on the phone-numbers example up above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Create a view and register its map and reduce functions:
View phoneView = database.getView("phones");
phoneView.setMapReduce(new Mapper() {
    @Override
    public void map(Map&lt;String, Object&gt; document, Emitter emitter) {
        List&lt;String&gt; phones = (List) document.get("phones");
        for (String phone : phones) {
            emitter.emit(phone, document.get("name"));
        }
    }
}, new Reducer() {
    @Override
    public Object reduce(List&lt;Object&gt; keys, List&lt;Object&gt; values, boolean rereduce) {
       return new Integer(values.size());
    }
}, "2");</code></pre>
</div>
</div>
<div class="paragraph">
<p>For efficiency, the key/value pairs are passed in as two parallel arrays.
This reduce block just counts the number of values and returns that number as an object.
We could query this view, with reduce enabled, and get the total number of phone numbers in the database.
Or by specifying a key range we could find the number of phone numbers in that range, for example the number in a single area code.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s just the body of a reduce function that totals up numbers.
(This function would belong in a different view, whose map function emitted numeric values.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">double total = 0;
for (Double value : values) {
    total += value.doubleValue();
}
return new Double(total);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This totaling is common enough that <code>CBLView</code> provide a utility to do it for you, the <code>totalValues</code> method.</p>
</div>
</div>
<div class="sect3">
<h4 id="rereducing"><a class="anchor" href="#rereducing"></a>Rereducing</h4>
<div class="paragraph">
<p>The previous section ignored the boolean <code>rereduce</code> parameter that&#8217;s passed to the reduce function.
What&#8217;s it for? Unfortunately, from your perspective as a reduce-function-writer it&#8217;s just there to make your job a bit harder.
The reason it exists is because it&#8217;s part of a major optimization that makes reducing more efficient for the query engine.</p>
</div>
<div class="paragraph">
<p>Think of a view with a hundred million rows in its index.
To run a reduced query against the whole index (with no startKey or endKey) the database will have to read all hundred million keys and values into memory at once, so it can pass them all to your reduce function.
That&#8217;s a lot of overhead, and on a mobile device it&#8217;s likely to crash your app.</p>
</div>
<div class="paragraph">
<p>Instead, the database will read the rows in chunks.
It&#8217;ll read some number of rows into memory, send them to your reduce function, release them from memory, then go on to the next rows.
This scales very well, but now there&#8217;s the problem of what to do with the multiple reduced values returned by your function.
Reducing is supposed to produce one end result, not several! The answer is to reduce the list of reduced values&#8201;&#8212;&#8201;to <code>re-reduce</code>.</p>
</div>
<div class="paragraph">
<p>The rereduce parameter is there to tell your reduce function that it&#8217;s being called in this special <code>re-reduce mode</code>.
<strong>When re-reducing there are no keys, and the values are the ones already returned by previous runs of the same reduce function.</strong>
The function&#8217;s job is, once again, to combine the values into a single value and return it.</p>
</div>
<div class="paragraph">
<p>Sometimes you can handle re-reduce mode exactly like reduce mode.
The second reduce block shown above (the one that totals up the values) can do this.
Since its input values are numbers, and its output is a number, the re-reduce is done the same way as the reduce, and it can just ignore the <code>rereduce</code> flag.</p>
</div>
<div class="paragraph">
<p>But sometimes re-reduce has to work differently, because the output of the reduce stage doesn&#8217;t look like the indexed values.
The first reduce example&#8201;&#8212;&#8201;the one that just counts the rows&#8201;&#8212;&#8201;is an example.
To re-reduce a list of row counts, you can&#8217;t just count them, you have to add them.
Let&#8217;s revisit that example and add proper support for re-reducing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Create a view and register its map and reduce functions:
View phoneView = database.getView("phones");
phoneView.setMapReduce(new Mapper() {
    @Override
    public void map(Map&lt;String, Object&gt; document, Emitter emitter) {
        List&lt;String&gt; phones = (List) document.get("phones");
        for (String phone : phones) {
            emitter.emit(phone, document.get("name"));
        }
    }
}, new Reducer() {
    @Override
    public Object reduce(List&lt;Object&gt; keys, List&lt;Object&gt; values, boolean rereduce) {
        if (rereduce) {
            return View.totalValues(values);
        } else {
            return new Integer(values.size());
        }
    }
}, "2");</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the <code>rereduce</code> flag is off, this just counts the raw values as before.
But when the flag is on, it knows it&#8217;s been given an array of row counts, so it invokes the <code>totalValues</code> method to add them up.</p>
</div>
<div class="paragraph">
<p>Now that you know how re-reduce works, we should let you know <strong>that Couchbase Lite 1.0 doesn&#8217;t actually use re-reduce</strong>&#8201;&#8212;&#8201;your reduce function will always be given index rows, never already-reduced values.
The <code>rereduce</code> parameter is in the API for future expansion, because in the future Couchbase Lite will use it.
For now, it&#8217;s up to you whether you want to ignore re-reduce (and maybe find that your reduce function breaks in the future) or code defensively and implement it now even though it isn&#8217;t used yet.</p>
</div>
</div>
<div class="sect3">
<h4 id="rules-for-the-reduce-function"><a class="anchor" href="#rules-for-the-reduce-function"></a>Rules for the reduce function</h4>
<div class="paragraph">
<p>The reduce function has the same restrictions as the map function (see above):
It must be a "pure" function that always produce the same output given the same input.
It must not have side effects.
And it must be thread-safe.
In addition:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Its output should be no larger than its input.</strong>
Usually this comes naturally.
But it is legal to return an array or dictionary, and sometimes people have tried to make reduce functions that transform the input values without actually making them any smaller.
The problem with this is that it scales badly, and as the size of the index grows, the indexer will eventually run out of memory and fail.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="development-considerations"><a class="anchor" href="#development-considerations"></a>Development considerations</h3>
<div class="sect3">
<h4 id="map-function-design"><a class="anchor" href="#map-function-design"></a>Map function design</h4>
<div class="paragraph">
<p><strong>When to emit a whole document as the value?</strong> In some places you&#8217;ll see code that does something like <code>emit(key, doc)</code>, i.e. emitting the document&#8217;s entire body as the value.
(Some people seem to do this by reflex whenever they don&#8217;t have a specific value in mind.)
It&#8217;s not necessarily bad, but most of the time you shouldn&#8217;t do it.
The benefit is that, by having the document&#8217;s properties right at hand when you process a query row, it can make querying a little bit faster (saving a trip to the database to load the document).
But the downside is that it makes the view index a lot larger, which can make querying slower.
So whether it&#8217;s a net gain or loss depends on the specific use case.
We recommend that you just set the value to <code>null</code> if you don&#8217;t need to emit any specific value.</p>
</div>
<div class="paragraph">
<p><strong>Is it OK is the same key is emitted more than once?</strong> The index allows duplicate keys, whether emitted by the same document or different documents.
A query will return all of those key/value pairs if they match.
They&#8217;ll be sorted by the ID of the document that was responsible for emitting them;
if a doc emits the same key multiple times, the order is undefined.</p>
</div>
<div class="paragraph">
<p><strong>When is the map function called?</strong> View indexes are updated on demand when queried.
So after a document changes, the next query made to a view will cause that view&#8217;s map function to be called on the doc&#8217;s new contents, updating the view index.
(But remember that you shouldn&#8217;t write any code that makes assumptions about when map functions are called.)</p>
</div>
<div class="paragraph">
<p><strong>If a document has conflicts, which conflicting revision gets indexed?</strong> The document&#8217;s <code>currentRevision</code>, sometimes called the "winning" revision, is the one that you see in the API if you don&#8217;t request a revision by ID.</p>
</div>
</div>
<div class="sect3">
<h4 id="performance"><a class="anchor" href="#performance"></a>Performance</h4>
<div class="paragraph">
<p><strong>How to improve your view indexing:</strong> The main thing you have control over is the performance of your map function, both how long it takes to run and how many objects it allocates.
Try profiling your app while the view is indexing and see if a lot of time is spent in the map function;
if so, optimize it.
See if you can short-circuit the map function and give up early if the document isn&#8217;t a type that will produce any rows.
Also see if you could emit less data.
(If you&#8217;re emitting the entire document as a value, don&#8217;t.)</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="query"><a class="anchor" href="#query"></a>Query</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A <strong>query</strong> is the action of looking up results from a view&#8217;s index.
In Couchbase Lite, queries are objects of the <code>Query</code> class.
To perform a query you create one of these, customize its properties (such as the key range or the maximum number of rows) and then run it.
The result is a <code>QueryEnumerator</code>, which provides a list of <code>QueryRow</code> objects, each one describing one row from the view&#8217;s index.</p>
</div>
<div class="paragraph">
<p>There&#8217;s also a special type of query called an <strong>all-docs query</strong>.
This type of query isn&#8217;t associated with any view;
or rather, you can think of it as querying an imaginary view that contains one row for every document in the database.
You use an all-docs query to find all the documents in the database, or the documents with keys in a specific range, or even the documents with a specific set of keys.
It can also be used to find documents with conflicts.</p>
</div>
<div class="paragraph">
<p>Couchbase Lite also provides <strong>live queries</strong>.
Once created, a live query remains active and monitors changes to the view&#8217;s index, notifying observers whenever the query results change.
Live queries are very useful for driving UI components like table views.</p>
</div>
<div class="sect2">
<h3 id="creating-and-configuring-queries"><a class="anchor" href="#creating-and-configuring-queries"></a>Creating and configuring queries</h3>
<div class="paragraph">
<p><code>Query</code> objects are created by a <code>View</code><code>'s `createQuery</code> method, and by a <code>Database</code><code>'s `createAllDocumentsQuery</code> method.
In its default state a <code>Query</code> object will return every row of the index, in increasing order by key.
But there are several properties you can configure to change this, before you run the query.
Here are the most basic and common ones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>startKey</code>: the key to start at.
The default value, <code>null</code>, means to start from the beginning.</p>
</li>
<li>
<p><code>endKey</code>: the last key to return.
The default value, <code>null</code>, means to continue to the end.</p>
</li>
<li>
<p><code>descending</code>: If set to <code>true</code>, the keys will be returned in reverse order.
(This also reverses the meanings of the <code>startKey</code> and <code>endKey</code> properties, since the query will now start at the highest keys and end at lower ones!)</p>
</li>
<li>
<p><code>limit</code>: If nonzero, this is the maximum number of rows that will be returned.</p>
</li>
<li>
<p><code>skip</code>: If nonzero, this many rows will be skipped (starting from the <code>startKey</code> if any.)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Some more advanced properties that aren&#8217;t used as often:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>keys</code>: If provided, the query will fetch only the rows with the given keys (and <code>startKey</code> and <code>endKey</code> will be ignored).</p>
</li>
<li>
<p><code>startKeyDocID</code>: If multiple index rows match the startKey, this property specifies that the result should start from the one(s) emitted by the document with this ID, if any.
(Useful if the view contains multiple identical keys, making .startKey ambiguous.)</p>
</li>
<li>
<p><code>endKeyDocID</code>: If multiple index rows match the endKey, this property specifies that the result should end with from the one(s) emitted by the document with this ID, if any.
(Useful if the view contains multiple identical keys, making .startKey ambiguous.)</p>
</li>
<li>
<p><code>indexUpdateMode</code>: Changes the behavior of index updating.
By default the index will be updated if necessary before the query runs.
You can choose to skip this (and get possibly-stale results), with the option of also starting an asynchronous background update of the index.</p>
</li>
<li>
<p><code>prefixMatchLevel</code>: If nonzero, enables prefix matching of string or array keys.</p>
<div class="ulist">
<ul>
<li>
<p>A value of 1 treats the endKey itself as a prefix: if it&#8217;s a string, keys in the index that come after the endKey, but begin with the same prefix, will be matched.
(For example, if the endKey is <code>"foo"</code> then the key <code>"foolish"</code> in the index will be matched, but not <code>"fong"</code>.)
Or if the endKey is an array, any array beginning with those elements will be matched.
(For example, if the endKey is <code>[1]</code>, then <code>[1, "x"]</code> will match, but not <code>[2]</code>.)
If the key is any other type, there is no effect.</p>
</li>
<li>
<p>A value of 2 assumes the endKey is an array and treats its final item as a prefix, using the rules above.
(For example, an endKey of <code>[1, "x"]</code> will match <code>[1, "xtc"]</code> but not <code>[1, "y"]</code>.)</p>
</li>
<li>
<p>A value of 3 assumes the key is an array of arrays, etc.</p>
<div class="paragraph">
<p>Note that if the <code>.descending</code> property is also set, the search order is reversed and the above discussion applies to the <code>startKey</code>, <strong>not</strong> the <code>endKey</code>.</p>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are other advanced properties that only apply to reducing and grouping:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>mapOnly</code>: If set to true, prevents the reduce function from being run, so you get all of the index rows instead of an aggregate.
Has no effect if the view has no reduce function.</p>
</li>
<li>
<p><code>groupLevel</code>: If greater than zero, enables grouping of rows.
The value specifies the number of items in the value array that will be grouped.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Set up a query for a view that indexes blog posts, to get the latest:
Query query = database.getView("postsByDate").createQuery();
query.setDescending(true);
query.setLimit(20);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="all-documents-queries"><a class="anchor" href="#all-documents-queries"></a>All-documents queries</h3>
<div class="paragraph">
<p>An all-docs query isn&#8217;t associated with a view;
or rather, you can think of it as querying an imaginary view that contains one row for every document in the database, whose key is the document ID.
It supports all the standard view options, so you can query ranges of document IDs, reverse the order, and even query a specific set of documents using the <code>keys</code> property.</p>
</div>
<div class="paragraph">
<p>All-docs queries also have a special property called <code>allDocsMode</code> that can customize their behavior.
Its values are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>allDocs</code>: The default mode.
Returns all non-deleted documents.</p>
</li>
<li>
<p><code>includeDeleted</code>: In this mode, deleted documents are included as well.</p>
</li>
<li>
<p><code>showConflicts</code>: In this mode, each <code>QueryRow</code><code>'s `conflictingRevisions</code> property can be used to find whether it&#8217;s in conflict and what the IDs of the conflicting revisions are.</p>
</li>
<li>
<p><code>onlyConflicts</code>: Like <code>showConflicts</code>, but <em>only</em> conflicted documents are returned.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>(<em>These are not flags.</em>
You can only choose one.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Let's find the documents that have conflicts so we can resolve them:
Query query = database.createAllDocumentsQuery();
query.setAllDocsMode(Query.AllDocsMode.ONLY_CONFLICTS);
QueryEnumerator result = query.run();
for (Iterator&lt;QueryRow&gt; it = result; it.hasNext(); ) {
    QueryRow row = it.next();
    if (row.getConflictingRevisions().size() &gt; 0) {
        Log.w("MYAPP", "Conflict in document: %s", row.getDocumentId());
        beginConflictResolution(row.getDocument());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="running-queries"><a class="anchor" href="#running-queries"></a>Running queries</h3>
<div class="paragraph">
<p>After a <code>Query</code> object is set up just right, you call its <code>run</code> method to get the results.
These are returned as a <code>QueryEnumerator</code> object, which mainly serves as an enumerable collection of <code>QueryRow</code> objects.</p>
</div>
<div class="paragraph">
<p>Each <code>QueryRow</code> has two main properties, its <code>key</code> and its <code>value</code>.
These are what were emitted to the index.
(Or in the case of an all-docs query, the key is the same as the document ID.)
It also has a <code>documentID</code> property that identifies the document that the key and value were emitted from, although usually you&#8217;d access the <code>document</code> property instead, which gives you the <code>Document</code> object directly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Let's query a view that maps product names to prices,
// starting with the "M"s and showing 100 widgets:
Query query = database.getView("widgetsByName").createQuery();
query.setStartKey("m");
query.setLimit(100);
QueryEnumerator result = query.run();
for (Iterator&lt;QueryRow&gt; it = result; it.hasNext(); ) {
    QueryRow row = it.next();
    Log.w("MYAPP", "Widget named %s costs $%f", row.getKey(), ((Double)row.getValue()).doubleValue());
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="re-running-queries-and-livequery"><a class="anchor" href="#re-running-queries-and-livequery"></a>Re-running queries, and LiveQuery</h3>
<div class="paragraph">
<p>It&#8217;s OK to run the same Query again.
You can even change its settings before the next run.
But if you find yourself wanting to re-run a query over and over to check for updates, there are some optimizations to consider.</p>
</div>
<div class="paragraph">
<p>First, there&#8217;s a quick check to see whether the previous query results are still up to date.
If you keep the QueryEnumerator object and check its <code>stale</code> property, a <code>false</code> value means that the view index hasn&#8217;t changed and re-running the query won&#8217;t give you a different result set.</p>
</div>
<div class="paragraph">
<p>Second, even if the enumerator says it&#8217;s stale and you re-run the query, the new results might not be any different.
The <code>stale</code> method is conservative and might report false positives, and even if the index did change, your query might not include any of the changed rows.
You can quickly check if the new QueryEnumerator you got is equivalent to the old one by comparing the objects for equality (e.g.
using <code>equals</code> in Java, or <code>-isEqual:</code> in Objective-C).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Check whether the query result set has changed:
if (queryResult == null || queryResult.isStale()) {
    QueryEnumerator newResult = query.run();
    if (!queryResult.equals(newResult)) {
        queryResult = newResult;
        updateMyUserInterface();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s a class that actually does this work for you, called <code>LiveQuery</code>.
A live query stays active and monitors the database and view index for changes.
When there&#8217;s a change it re-runs itself automatically, and if the query results changed it notifies any observers.
LiveQuery is a great way to build reactive user interfaces, especially table/list views, that keep themselves up to date.
For example, as the replicator runs and pulls new data from the server, a LiveQuery-driven UI will automatically update to show the data without the user having to manually refresh.
This helps your app feel quick and responsive.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private void initializeQuery() {
    // Set up my live query during view initialization:
    Query query = database.getView("widgets").createQuery();
    query.setLimit(100);
    LiveQuery liveQuery = query.toLiveQuery();
    this.liveQuery = liveQuery;
    liveQuery.addChangeListener(new LiveQuery.ChangeListener() {
        @Override
        public void changed(LiveQuery.ChangeEvent event) {
            if (event.getSource().equals(this.liveQuery)) {
                this.displayRows(event.getRows());
            }
        }
    });
    this.liveQuery.start();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="querying-key-ranges"><a class="anchor" href="#querying-key-ranges"></a>Querying key ranges</h3>
<div class="paragraph">
<p>There are some subtleties to working with key ranges (<code>startKey</code> and <code>endKey</code>).
The first is that if you reverse the order of keys, by setting the <code>reverse</code> property, then the <code>startKey</code> needs to be <em>greater than</em> the <code>endKey</code>.
That&#8217;s the reason they&#8217;re named <em>start</em> and <em>end</em>, rather than <em>min</em> and <em>max</em>.
In the following example, note that the key range starts at 100 and ends at 90;
if we&#8217;d done it the other way around, we&#8217;d have gotten an empty result set.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Set up a query for the highest-rated movies:
Query query = database.getView("postsByDate").createQuery();
query.setDescending(true);
query.setStartKey(new Integer(100));
query.setEndKey(new Integer(90));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Second is the handling of compound (array) keys.
When a view&#8217;s keys are arrays, it&#8217;s very common to want to query all the rows that have a specific value (or value range) for the first element.
The start key is just a one-element array with that value in it, but it&#8217;s not obvious what the <em>end</em> key should be.
What works is an array that&#8217;s like the starting key but with a second object appended that&#8217;s greater than any possible value.
For example, if the start key is (in JSON) <code>["red"]</code> then the end key could be <code>["red", "ZZZZ"]</code> &#8230;&#8203;because none of the possible second items could be greater than "ZZZZ", right?
Unfortunately this has obvious problems.
The correct stop value to use turns out to be an empty object/dictionary, <code>{}</code>, making the end key <code>["red", {}]</code>.
This works because the sort order in views puts dictionaries last.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Assume the view's keys are like [color, model]. We want all the red ones.
Query query = database.getView("carsByColorAndModel").createQuery();
query.setStartKey("red");
query.setEndKey(Arrays.asList("red", new HashMap&lt;String, Object&gt;()));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reducing"><a class="anchor" href="#reducing"></a>Reducing</h3>
<div class="paragraph">
<p>If the view has a reduce function, it will be run <em>by default</em> when you query the view.
This means that all rows of the output will be aggregated into a single row with no key, whose value is the output of the reduce function.
(See the View documentation for a full description of what reduce functions do.)</p>
</div>
<div class="paragraph">
<p>(It&#8217;s important to realize that the reduce function runs on the rows that <em>would be output</em>, not all the rows in the view.
So if you set the <code>startKey</code> and/or <code>endKey</code>, the reduce function runs only on the rows in that key range.)</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t want the reduce function to be used, set the query&#8217;s <code>mapOnly</code> property to <code>true</code>.
This gives you the flexibility to use a single view for both detailed results and statistics.
For example, adding a typical row-count reduce function to a view lets you get the full results (with <code>mapOnly=true</code>) or just the number of rows (with <code>mapOnly=false</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// This view's keys are order dates, and values are prices.
// The reduce function computes an average of the input values.
Query query = database.getView("ordersByDateView").createQuery();
query.setStartKey("2014-01-01");
query.setEndKey("2014-02-01");
// First run without reduce to get the individual orders for January '14:
query.setMapOnly(true);
QueryEnumerator result = query.run();
for (Iterator&lt;QueryRow&gt; it = result; it.hasNext(); ) {
    QueryRow row = it.next();
    Log.w("MYAPP", "On %s: order for $%f", row.getKey(), ((Double)row.getValue()).doubleValue());
}
// Now run with reduce to get the average order price for January '14:
query.setMapOnly(false);
QueryEnumerator result = query.run();
QueryRow aggregate = result.next();
Log.w("MYAPP", "Average order was $%f", ((Double)aggregate.getValue()).doubleValue());</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="grouping-by-key"><a class="anchor" href="#grouping-by-key"></a>Grouping by key</h3>
<div class="paragraph">
<p>The <code>groupLevel</code> property of a query allows you to collapse together (aggregate) rows with the same keys or key prefixes.
And you can compute aggregated statistics of the grouped-together rows by using a reduce function.
One very powerful use of grouping is to take a view whose keys are arrays representing a hierarchy&#8201;&#8212;&#8201;like <code>[genre, artist, album, track]</code> for a music library&#8201;&#8212;&#8201;and query a single level of the hierarchy for use in a navigation UI.</p>
</div>
<div class="paragraph">
<p>In general, <code>groupLevel</code> requires that the keys be arrays;
rows with other types of keys will be ignored.
When the <code>groupLevel</code> is <em>n</em>, the query combines rows that have equal values in the first n items of the key into a single row whose key is the n-item common prefix.</p>
</div>
<div class="paragraph">
<p><code>groupLevel=1</code> is slightly different in that it supports non-array keys: it compares them for equality.
In other words, if a view&#8217;s keys are strings or numbers, a query with <code>groupLevel=1</code> will return a row for each <em>unique</em> key in the index.</p>
</div>
<div class="paragraph">
<p>We&#8217;ve talked about the keys of grouped query rows, but what are the values?
The <code>value</code> property of each row will be the result of running the view&#8217;s reduce function over all the rows that were aggregated;
or if the view has no reduce function, there&#8217;s no value.
(See the View documentation for information on reduce functions.)</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an interesting example.
We have a database of the user&#8217;s music library, and a view containing a row for every audio track, with key of the form <code>[genre, artist, album, trackname]</code> and value being the track&#8217;s duration in seconds.
The view has a reduce function that simply totals the input values.
The user&#8217;s drilled down into the genre "Mope-Rock", then artist "Radiohead", and now we want to display the albums by this artist, showing each album&#8217;s running time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Query query = database.getView("hierarchyView").createQuery();
query.setGroupLevel(3);
query.setStartKey(Arrays.asList("Mope-Rock", "Radiohead"));
query.setEndKey(Arrays.asList("Mope-Rock", "Radiohead", new HashMap&lt;String, Object&gt;()));
// groupLevel=3 will return [genre, artist, album] keys.
List&lt;String&gt; albumTitles = new ArrayList&lt;String&gt;();
List&lt;String&gt; albumTimes = new ArrayList&lt;String&gt;();
QueryEnumerator result = query.run();
for (Iterator&lt;QueryRow&gt; it = result; it.hasNext(); ) {
    QueryRow row = it.next();
    List&lt;String&gt; key = (List) row.getKey();
    albumTitles.add(key.get(2)); // title is 3rd item of key
    albumTimes.add((String)row.getValue()); // value is album's running time
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="replication"><a class="anchor" href="#replication"></a>Replication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A Replication object represents a replication (or "sync") task that transfers changes between a local database and a remote one.
To replicate, you first get a new Replication object from a Database, then configure its settings, then tell it to start.
The actual replication runs asynchronously on a background thread;
you can monitor its progress by observing notifications posted by the Replication object when its state changes, as well as notifications posted by the database when documents are changed by the replicator.</p>
</div>
<div class="paragraph">
<p>A typical application will create a pair of replications (push and pull) at launch time, both pointing to the URL of a server run by the application vendor.
These stay active continuously during the lifespan of the app, uploading and downloading documents as changes occur and when the network is available.</p>
</div>
<div class="paragraph">
<p>(Of course, atypical applications can use replication differently.
The architecture is very flexible, supporting one-way replication, peer-to-peer replication, and replication between multiple devices and servers in arbitrary directed graphs.
An app might also choose to replicate only once in a while, or only with a subset of its documents.)</p>
</div>
<div class="paragraph">
<p>The application code doesn&#8217;t have to pay attention to the details: it just knows that when it makes changes to the local database they will eventually be uploaded to the server, and when changes occur on the server they will eventually be downloaded to the local database.
The app&#8217;s job is to make the UI reflect what&#8217;s in the local database, and to reflect user actions by making changes to local documents.
If it does that, replication will Just Work without much extra effort.</p>
</div>
<div class="sect2">
<h3 id="types-of-replications"><a class="anchor" href="#types-of-replications"></a>Types of replications</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Push vs Pull:</strong> A push replication uploads changes from the local database to the remote one;
a pull downloads changes from the remote database to the local one.</p>
</li>
<li>
<p><strong>One-shot vs Continuous:</strong> By default a replication runs long enough to transfer all the changes from the source to the target database, then quits.
A continuous replication, on the other hand, will stay active indefinitely, watching for further changes to occur and transferring them.</p>
</li>
<li>
<p><strong>Filtered:</strong> Replications can have filters that restrict what documents they&#8217;ll transfer.
This can be useful to limit the amount of a large remote database that&#8217;s downloaded to a device, or to keep some local documents private.
A special type of filter used with the Couchbase Sync Gateway is the set of <strong>channels</strong> that a pull replication will download from.
It&#8217;s also possible to limit a replication to an explicit set of document IDs.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="creating-replications"><a class="anchor" href="#creating-replications"></a>Creating replications</h3>
<div class="paragraph">
<p>You create a Replication object by calling the Database methods <code>createPullReplication</code> or <code>createPushReplication</code>.
Both of these take a single parameter, the URL of the remote database to sync with.
As the names imply, each method creates a replication that transfers changes in one direction only;
if you want bidirectional sync, as most apps do, you should create one of each.</p>
</div>
<div class="paragraph">
<p>Next you can customize the replication settings.
The most common change is to set the <code>continuous</code> property to <code>true</code>.
You may also need to supply authentication credentials, like a username/password or a Facebook token.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">URL url = new URL("https://example.com/mydatabase/");
Replication push = database.createPushReplication(url);
Replication pull = database.createPullReplication(url);
pull.setContinuous(true);
push.setContinuous(true);
Authenticator auth = new BasicAuthenticator(username, password);
push.setAuthenticator(auth);
pull.setAuthenticator(auth);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You will also probably want to monitor the replication&#8217;s progress, particularly because this will tell you if errors occur, but also if you want to display a progress indicator to the user.
The API for registering as an observer is platform-specific.</p>
</div>
<div class="paragraph">
<p>Once everything is set, you call start to <code>start</code> the replication.
If the replication is continuous, it&#8217;ll keep running indefinitely.
Otherwise, the replication will eventually stop when it&#8217;s transferred everything.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">push.addChangeListener(new Replication.ChangeListener() {
    @Override
    public void changed(Replication.ChangeEvent event) {
        // will be called back when the push replication status changes
    }
});
pull.addChangeListener(new Replication.ChangeListener() {
    @Override
    public void changed(Replication.ChangeEvent event) {
        // will be called back when the pull replication status changes
    }
});
push.start();
pull.start();
this.push = push;
this.pull = pull;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="filtered-replications"><a class="anchor" href="#filtered-replications"></a>Filtered replications</h3>
<div class="paragraph">
<p>You can restrict a replication to only a subset of the available documents, by writing a filter function.
There are several types of filtered replication, based on the direction and the type of server.</p>
</div>
<div class="sect3">
<h4 id="filtered-push-replications"><a class="anchor" href="#filtered-push-replications"></a>Filtered push replications</h4>
<div class="paragraph">
<p>During a push replication, the candidate documents live in your local database, so the filter function runs locally.
You define it as a native function (a block in Objective-C, an inner class method in Java), assign it a name, and register it with the Database object.
You then set the filter&#8217;s name as the <code>filter</code> property of the Replication object.</p>
</div>
<div class="paragraph">
<p>The replicator passes your filter function a SavedRevision object.
The function can examine the document&#8217;s ID and properties, and simply returns true to allow the document to be replicated, or false to prevent it from being replicated.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
The filter function will be called on the replicator&#8217;s background thread, so it should be thread-safe.
Ideally it shouldn&#8217;t reference any external state, but this isn&#8217;t strictly required.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The filter function can also be given parameters.
The parameter values are specified in the <code>Replication.filterParams</code> property as a dictionary/map, and passed to the filter function.
This way you can write a generalized filter that can be used with different replications, and also avoid referencing external state from within the function.
For example, a function could filter documents created in any year, accepting the specific year as a parameter.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Define a filter that matches only docs with a given "owner" property.
// The value to match is given as a parameter named "name":
db.setFilter("byOwner", new ReplicationFilter() {
    @Override
    public boolean filter(SavedRevision revision, Map&lt;String, Object&gt; params) {
        String nameParam = (String) params.get("name");
        return nameParam != null &amp;&amp; nameParam.equals(revision.getProperty("owner"));
    }
});
//
// Set up a filtered push replication using the above filter block,
// that will push only docs whose "owner" property equals "Waldo":
Replication push = db.createPushReplication(url);
push.setFilter("byOwner");
Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();
params.put("name", "Waldo");
push.setFilterParams(params);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="filtered-pull-from-sync-gateway"><a class="anchor" href="#filtered-pull-from-sync-gateway"></a>Filtered pull from Sync Gateway</h4>
<div class="paragraph">
<p>Channels are used to filter documents being pulled from the Sync Gateway.
Every document stored in a Sync Gateway database is tagged with a set of named channels by the Gateway&#8217;s app-defined sync function.
Every pull replication from the Gateway is already implicitly filtered by the set of channels that the user&#8217;s account is allowed to access;
you can filter it further by creating an array of channel names and setting it as the value of the channels property of a pull Replication.
Only documents tagged with those channels will be downloaded.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Set up a channel-filtered pull replication that will pull only
// docs in the "sales" channel from the Sync Gateway:
db.createPullReplication(url);
List&lt;String&gt; channels = new ArrayList&lt;String&gt;();
channels.add("sales");
pull.setChannels(channels);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Replication properties changed after it has already started won&#8217;t have any effect.
If you wish to change replication properties such as channels, authentication, etc, you must create a new replication object using the <code>createPushReplication</code> or <code>createPullReplication</code> method.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="filtered-pull-from-couchdb-pouchdb-or-cloudant"><a class="anchor" href="#filtered-pull-from-couchdb-pouchdb-or-cloudant"></a>Filtered pull from CouchDB, PouchDB or Cloudant</h4>
<div class="paragraph">
<p>Since Couchbase Lite 1.2, filter functions in pull replications with non-Couchbase databases are no longer available.
There is an incompatibility in the way the <code>filter</code> parameter is handled in the <code>POST /{db}/_changes</code> request (see <a href="https://github.com/couchbase/couchbase-lite-ios/issues/1139">#1139</a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="filtering-by-document-ids"><a class="anchor" href="#filtering-by-document-ids"></a>Filtering by document IDs</h4>
<div class="paragraph">
<p>In one-shot <strong>pull</strong> replications with Sync Gateway, it&#8217;s possible to specify a list of document IDs (this feature is not available for replications in continuous mode, see <a href="https://github.com/couchbase/sync_gateway/issues/1703">#1703</a>).
The code below pulls the documents with ID "123" and "xyz" if they exist and the user has access to them.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">List&lt;String&gt; docIDs = new ArrayList&lt;&gt;();
docIDs.add("123");
docIDs.add("xyz");

Replication pull = database.createPullReplication(mSyncGatewayUrl);
pull.setDocIds(docIDs);
pull.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>For <strong>push</strong> replications with Sync Gateway, this functionality is available in one-shot and continuous replications.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="observing-and-monitoring-replications"><a class="anchor" href="#observing-and-monitoring-replications"></a>Observing and monitoring replications</h3>
<div class="paragraph">
<p>Since a replication runs asynchronously, if you want to know when it completes or when it gets an error, you&#8217;ll need to register as an observer to get notifications from it.
The details of this are platform-specific.</p>
</div>
<div class="paragraph">
<p>A replication has a number of properties that you can access, especially from a notification callback, to check on its status and progress:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>status</code>: An enumeration that gives the current state of the replication.
The values are Stopped, Offline, Idle and Active.</p>
<div class="ulist">
<ul>
<li>
<p>Stopped: A one-shot replication goes into this state after all documents have been transferred or a fatal error occurs.
(Continuous replications never stop.)</p>
</li>
<li>
<p><strong>Offline</strong>: The remote server is not reachable.
Most often this happens because there&#8217;s no network connection, but it can also occur if the server&#8217;s inside an intranet or home network but the device isn&#8217;t.
(The replication will monitor the network state and will try to connect when the server becomes reachable.)</p>
</li>
<li>
<p><strong>Idle</strong>: Indicates that a continuous replication has "caught up" and transferred all documents, but is monitoring the source database for future changes.</p>
</li>
<li>
<p><strong>Active</strong>: The replication is actively working, either transferring documents or determining what needs to be transferred.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>lastError</code>: The last error encountered by the replicator.
(Not all errors are fatal, and a continuous replication will keep running even after a fatal error, by waiting and retrying later.)</p>
</li>
<li>
<p><code>completedChangesCount</code>, <code>changesCount</code>: The number of documents that have been transferred so far, and the estimated total number to transfer in order to catch up.
The ratio of these can be used to display a progress meter.
Just be aware that changesCount may be zero if the number of documents to transfer isn&#8217;t known yet, and in a continuous replication both values will reset to zero when the status goes from Idle back to Active.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">final ProgressDialog progressDialog = ProgressDialog.show(MainActivity.this, "Please wait ...", "Syncing", false);
pull.addChangeListener(new Replication.ChangeListener() {
    @Override
    public void changed(Replication.ChangeEvent event) {
        // The replication reporting the notification is either
        // the push or the pull, but we want to look at the
        // aggregate of both the push and pull.
        // First check whether replication is currently active:
        boolean active = (pull.getStatus() == Replication.ReplicationStatus.REPLICATION_ACTIVE) ||
        (push.getStatus() == Replication.ReplicationStatus.REPLICATION_ACTIVE);
        if (!active) {
            progressDialog.dismiss();
        } else {
            double total = push.getCompletedChangesCount() + pull.getCompletedChangesCount();
            progressDialog.setMax(total);
            progressDialog.setProgress(push.getChangesCount() + pull.getChangesCount());
        }
    }
});</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="detecting-unauthorized-credentials"><a class="anchor" href="#detecting-unauthorized-credentials"></a>Detecting unauthorized credentials</h4>
<div class="paragraph">
<p>The replication listener can also be used to detect when credentials are incorrect or access to Sync Gateway requires authentication.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">push = database.createPushReplication(url);
push.addChangeListener(new Replication.ChangeListener() {
    @Override
    public void changed(Replication.ChangeEvent event) {
        if (event.getError() != null) {
            Throwable lastError = event.getError();
            if (lastError instanceof RemoteRequestResponseException) {
                RemoteRequestResponseException exception = (RemoteRequestResponseException) lastError;
                if (exception.getCode() == 401) {
                    // Authentication error
                }
            }
        }
    }
});</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="data-modeling"><a class="anchor" href="#data-modeling"></a>Data Modeling</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you&#8217;re familiar with data modeling for relational databases, you&#8217;ll notice differences in the way it is done for Couchbase Lite.</p>
</div>
<div class="paragraph">
<p>Couchbase Lite is a document database.
Unlike traditional relational databases, data is stored in documents rather than in table rows.
A document is a JSON object containing a number of key-value pairs.
Entities, and relationships between entities, are managed within the document itself.</p>
</div>
<div class="sect2">
<h3 id="the-basics"><a class="anchor" href="#the-basics"></a>The Basics</h3>
<div class="paragraph">
<p>A starting point for data modeling in Couchbase Lite is to look at a denormalized entity stored in a single document.
Consider modeling a contact record stored in a relational database in a CONTACTS table, of the form:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">ID</th>
<th class="tableblock halign-left valign-top">FIRST_NAME</th>
<th class="tableblock halign-left valign-top">LAST_NAME</th>
<th class="tableblock halign-left valign-top">EMAIL</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">John</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Smith</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">john.smith@couchbase.com</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The equivalent representation in JSON document form would be something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">{
   "id": "contact100",
   "type": "contact",
   "first_name":"John",
   "last_name ":"Smith",
   "email": "john.smith@couchbase.com"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Functionally related properties can be grouped using an embedded document.
If we wanted to store address information for our contact, it could be modeled as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">{
   "id": "contact100",
   "type": "contact",
   "first_name": "John",
   "last_name ": "Smith",
   "email": "john.smith@couchbase.com",
   "address": {
      "address_line": "123 Main Street",
      "city": "Mountain View",
      "country": "US"
   }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="one-to-many-relationships"><a class="anchor" href="#one-to-many-relationships"></a>One-to-Many Relationships</h3>
<div class="paragraph">
<p>Things get interesting when the contact record has more than one related record that we want to model.
There are two main options for modeling one-to-many relationships in a document database&#8201;&#8212;&#8201;as embedded documents, and as related documents.</p>
</div>
<div class="sect3">
<h4 id="using-embedded-documents"><a class="anchor" href="#using-embedded-documents"></a>Using Embedded Documents</h4>
<div class="paragraph">
<p>When a contact can have more than one address, the addresses would commonly be stored in a relational database using a separate ADDRESSES table:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">ID</th>
<th class="tableblock halign-left valign-top">CONTACT_ID</th>
<th class="tableblock halign-left valign-top">ADDRESS_LINE</th>
<th class="tableblock halign-left valign-top">CITY</th>
<th class="tableblock halign-left valign-top">COUNTRY</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">123 Main Street</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mountain View</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">US</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">201</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">123 Market</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">San Francisco</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">US</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>In a document database, the address information could instead be stored as an array of embedded documents within the contact document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">{
   "id": "contact100",
   "type": "contact",
   "first_name": "John",
   "last_name" : "Smith",
   "email": "john.smith@couchbase.com",
   "addresses": [
    {
      "address_line": "123 Main Street",
      "city": "Mountain View",
      "country": "US"
    },
    {
      "address_line": "123 Market",
      "city": "San Francisco",
      "country": "US"
    }
   ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The embedded document approach reduces the amount of work that your application needs to do in order to work with the Contact object&#8201;&#8212;&#8201;there is no additional query required to retrieve the embedded information.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-related-documents"><a class="anchor" href="#using-related-documents"></a>Using Related Documents</h4>
<div class="paragraph">
<p>There are scenarios where the embedded document approach isn&#8217;t ideal, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Large number of related entities.</em>
Embedding a large number of related entities results in a large document.
This can result in slower document handling, as the entire document needs to be passed around when making updates.</p>
</li>
<li>
<p><em>Concurrency.</em>
When multiple users are working on a single document, there&#8217;s a higher risk of conflicts being introduced.
Related documents can be used to isolate updates being made by different users.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The most common implementation for related documents is the belongsTo pattern.
Consider the scenario where any user can assign a task to a contact, and a contact can end up with a large number of volatile task records.
Here we define a new task document, which includes the contact key that the task record belongs to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">{
  "id": "task300",
  "type": "task",
  "contact_id": "contact100"
  "description": "Task details",
  "status": "complete"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Under this implementation, users can modify task records concurrently without introducing conflict scenarios for the related contact record.
It can also support a large number of task records per contact without impacting the size of the related contact record.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="peer-to-peer"><a class="anchor" href="#peer-to-peer"></a>Peer-to-Peer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Two instances of Couchbase Lite can directly sync with each other without a server (peer-to-peer).
At least one of them must use the Couchbase Lite Listener library, which enables any Couchbase Lite database to become the remote in a replication by listening on a TCP port and by exposing the standard replication endpoints on that port.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/docs-listener-diagram.png" alt="docs listener diagram">
</div>
</div>
<div class="paragraph">
<p>It becomes an alternate entry-point into the data store.
Another peer can therefore use the URL and port number in the replicator to sync data to and from the database currently listening.</p>
</div>
<div class="paragraph">
<p>Some typical Listener use cases include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Synchronizing with selected peer devices on the same LAN network.</p>
</li>
<li>
<p>Offline/online: use peer-to-peer in conjunction with Sync Gateway.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="installing-the-listener-library"><a class="anchor" href="#installing-the-listener-library"></a>Installing the Listener library</h3>
<div class="paragraph">
<p>Refer to the <a href="#installation">Installation</a> section to install the Listener component.
The Couchbase Lite Listener is coupled to Couchbase Lite.
Both frameworks should always have the same release version.</p>
</div>
</div>
<div class="sect2">
<h3 id="configuring"><a class="anchor" href="#configuring"></a>Configuring</h3>
<div class="paragraph">
<p>To begin using the Listener you must create an instance by specifying a manager instance and port number.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Manager manager = new Manager((Context) getApplicationContext(), Manager.DEFAULT_OPTIONS);
Credentials credentials = new Credentials("hello", "pw123");
listener = new LiteListener(manager, 55000, credentials);
Thread thread = new Thread(listener);
thread.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Make sure to keep a reference to the listener instance in your application otherwise it may be garbage collected and unexpectedly stop listening for incoming HTTP requests.
In the example above, the listener instance is initialized as an instance property of the class.</p>
</div>
<div class="paragraph">
<p>Basic authentication is the recommended approach for protecting database access on the LAN.
The listening peer can optionally be initialized with a list of username/password pairs.
The peer that intends to run the replication must provide the same username/password <code>http://username:password@hostname:port/dbname</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="discovery"><a class="anchor" href="#discovery"></a>Discovery</h3>
<div class="paragraph">
<p>Once you have set up the Listener as an endpoint for other peers to replicate to or from, you can use different discovery methods to browse for peers and subscribe to those of interest.</p>
</div>
<div class="paragraph">
<p>This section covers two ways to discover peers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Using a QR code to encode the peer&#8217;s remote URL.</p>
</li>
<li>
<p>DNS Service Discovery (DNS-SD, aka Bonjour).</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="qr-code"><a class="anchor" href="#qr-code"></a>QR code</h4>
<div class="sect4">
<h5 id="photodrop"><a class="anchor" href="#photodrop"></a>PhotoDrop</h5>
<div class="paragraph">
<p><a href="https://github.com/couchbaselabs/photo-drop">PhotoDrop</a> is a P2P sharing app similar to the iOS AirDrop feature that you can use to send photos across devices.
The source code is available for iOS and Android.
The QR code is used for advertising an adhoc endpoint URL that a sender can scan and send photos to.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dns-sd"><a class="anchor" href="#dns-sd"></a>DNS-SD</h4>
<div class="paragraph">
<p>DNS Service Discovery is a <a href="https://www.ietf.org/rfc/rfc6763.txt">standard</a> for discovering services based on a service type.
It&#8217;s usually coupled with <a href="https://tools.ietf.org/html/rfc6762">Multicast DNS</a>, which allows devices to broadcast their existence and services on a LAN without requiring a DNS server.
These technologies are usually referred to as Bonjour, which is Apple&#8217;s name for its implementation, but they&#8217;re available under other names on most operating systems.
Android calls them Network Service Discovery.</p>
</div>
<div class="paragraph">
<p>The first step to using Bonjour for peer discovery is to advertise a service with the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Type:</strong> Bonjour can be used by many other types of devices on the LAN (printers, scanners, other apps etc).
The service type is a way to interact only with peers whose service type is the same.</p>
</li>
<li>
<p><strong>Name:</strong> A string to serve as identifier for other peers.
It should be unique for each peer.
It does not need to be human-readable.</p>
</li>
<li>
<p><strong>Port:</strong> The port number the Listener is running on.</p>
</li>
<li>
<p><strong>Metadata:</strong> Optional data that will be sent in the advertizment packets (the size limit is around 1.5KB).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To browse for peers on the network, each implementation has an asynchronous API to get notified as peers go online and offline from the network.
Given this method of device discovery is platform specific, we recommend to follow the guides below.
Once a peer device is discovered and the hostname is resolved, you can start a push and/or pull replication in the same way you would with Sync Gateway.</p>
</div>
<div class="sect4">
<h5 id="resources"><a class="anchor" href="#resources"></a>Resources</h5>
<div class="paragraph">
<p>Useful resources to work with mDNS include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Bonjour for iOS and Mac applications:</strong> The Couchbase Lite SDK exposes part of the Bonjour API for an easier integration.
The official documentation for iOS and Mac applications can be found in the <a href="https://developer.apple.com/library/mac/documentation/Networking/Conceptual/NSNetServiceProgGuide/Introduction.html">NSNetService Programming Guide</a>.</p>
</li>
<li>
<p><strong>NSD for Android applications:</strong> The de facto framework for Android is called Network Service Discovery (NSD) and is compatible with Bonjour since Android 4.1.
The official guide can be found in the <a href="https://developer.android.com/training/connect-devices-wirelessly/nsd.html">Android NSD guide</a>.</p>
</li>
<li>
<p><strong>JmDNS:</strong> Implementation in Java that can be used in Android and Java applications (<a href="https://github.com/jmdns/jmdns">official repository</a>).</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="bonjour-browsers"><a class="anchor" href="#bonjour-browsers"></a>Bonjour browsers</h5>
<div class="paragraph">
<p>Bonjour browsers are useful to monitor devices broadcasting a particular service on the LAN (<a href="http://www.macupdate.com/app/mac/13388/bonjour-browser">OS X Bonjour browser</a>, <a href="https://itunes.apple.com/gb/app/discovery-bonjour-browser/id305441017">iOS app</a>, <a href="http://hobbyistsoftware.com/bonjourbrowser">Windows browser</a>)</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="connecting"><a class="anchor" href="#connecting"></a>Connecting</h3>
<div class="paragraph">
<p>Once the IP address of another device is known you can start replicating data to or from that peer.
However, there are some good practice guidelines to follow in order to replicate the changes as they are persisted to a particular node.</p>
</div>
<div class="sect3">
<h4 id="filter-functions"><a class="anchor" href="#filter-functions"></a>Filter functions</h4>
<div class="paragraph">
<p>It may be desirable to use <a href="#filtered-replications">filtered replications</a> to replicate only the documents of interest to another peer.
Filter functions in a peer-to-peer context are executed when the start method on the replication object is called.
This is a major difference with the Sync Function available on Sync Gateway that builds the access rules when documents are saved to the Sync Gateway database.</p>
</div>
</div>
<div class="sect3">
<h4 id="port-allocation"><a class="anchor" href="#port-allocation"></a>Port allocation</h4>
<div class="paragraph">
<p>If the port number passed to the Listener is hardcoded, there is a small chance that another application may already be using it.
To avoid this scenario, specifying a value of 0 for the port in the Listener constructor will let the TCP stack pick a random available port.</p>
</div>
</div>
<div class="sect3">
<h4 id="remote-uuid"><a class="anchor" href="#remote-uuid"></a>Remote UUID</h4>
<div class="paragraph">
<p>The replication algorithm keeps track of what was last synchronized with a particular remote database.
To identify a remote, it stores a hash of the remote URL <a href="http://hostname:port/dbname" class="bare">http://hostname:port/dbname</a> and other properties such as filters, filter params etc.
In the context of peer-to-peer, the IP address will frequently change which will result in a replication starting from scratch and sending over every single document although they may have already been replicated in the past.
You can override the method of identifying a remote database using the remoteUUID property of the replicator.
If specified, it will be used in place of the remote URL for calculating the remote checkpoint in the replication process.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="security"><a class="anchor" href="#security"></a>Security</h3>
<div class="paragraph">
<p>In addition to using basic authentication, it is also possible to enable SSL over peer-to-peer connections.</p>
</div>
<div class="sect3">
<h4 id="ssl-for-peer-to-peer"><a class="anchor" href="#ssl-for-peer-to-peer"></a>SSL for Peer-to-peer</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">No code example is currently available.</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Listener is now serving SSL using an automatically generated identity.</p>
</div>
<div class="sect4">
<h5 id="wait-is-this-secure"><a class="anchor" href="#wait-is-this-secure"></a>Wait, Is This Secure?</h5>
<div class="paragraph">
<p>Yes and no.
It encrypts the connection, which is unquestionably much better than not using SSL.
But unlike the usual SSL-in-a-browser approach you&#8217;re used to, it doesn&#8217;t identify the server/listener to the client.
The client has to take the cert on faith the first time it connects.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="release-notes"><a class="anchor" href="#release-notes"></a>Release Notes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="deprecation-notices"><a class="anchor" href="#deprecation-notices"></a>Deprecation notices</h3>
<div class="paragraph">
<p>The following features are being deprecated in Couchbase Mobile 1.4 and will be unsupported in 2.0.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ForestDB</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following platforms are being deprecated in Couchbase Mobile 1.4 and will be unsupported in 2.0.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Android API Level &lt; 16</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="1-4-4-release"><a class="anchor" href="#1-4-4-release"></a>1.4.4 release</h3>
<div class="ulist">
<div class="title">Bugs</div>
<ul>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1684"><strong>#1684</strong></a> Expected `:status' header not present</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-android/issues/994"><strong>#994</strong></a> In _attachments revpos values are keep changing when do pull replication</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-android/issues/1724"><strong>#1724</strong></a> 1.4 : Getting Exception in setExpirationDate</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="1-4-1-release"><a class="anchor" href="#1-4-1-release"></a>1.4.1 release</h3>
<div class="ulist">
<div class="title">Performance Improvements</div>
<ul>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1608">#1608</a> Purge does not remove row from 'docs' table</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1623">#1623</a> Potential bug: Push replication becomes slower as local DB grows</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1630">#1630</a> View indexing is very slow, due to mis-optimized SQLite query</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Enhancements</div>
<ul>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/290">#290</a> 1.x: [Memory] Memory leak in allReplicators</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/639">#639</a> 1.x: Enhance ChangeTracker Error handling (port latest codes from iOS)</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Bugs</div>
<ul>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1372">#1372</a> Router unable to route request to do_GET_DesignDocument (ForestDB)</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1483">#1483</a> 1.x: java.lang.OutOfMemoryError: Failed to allocate a 24 byte allocation with 329648 free bytes and 321KB until OOM; failed due to fragmentation&#8230;&#8203;</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1604">#1604</a> 1.x: Leftover replication threads prevent application exit.</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1605">#1605</a> 1.x: peer to peer replication with attachments does not work with android client</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1627">#1627</a> Replicator does not close a connection immediately after stopping the replication.</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1629">#1629</a> Wrong return code for listener causes problems with puller and deleted items</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1631">#1631</a> Stopped replicator is restarted by network reachability</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1637">#1637</a> 1.x: RejectedExecutionException is through from Replicator</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1652">#1652</a> 1.x - LiveQuery: row.getDocument().getProperties() return null if document is deleted during indexing</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1660">#1660</a> 1.x: Peer to Peer: InvocationTargetException in Router.java with PhotoDrop sample app</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1663">#1663</a> 1.x: Channel removal potentially disrupts attachments</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1617">#1617</a> The specified SyncGatewaySession value with in POST /_replicate is not used.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="1-4-release"><a class="anchor" href="#1-4-release"></a>1.4 release</h3>
<div class="ulist">
<div class="title">API change</div>
<ul>
<li>
<p>An <code>isDeletion</code> property is now available on the <code>DatabaseChange</code> object to identify if a change is tombstone document.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Enhancements</div>
<ul>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1087">#1087</a> LiteServ app for Java</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1543">#1543</a> Make CBLDatabaseChange.isDeletion public?</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1554">#1554</a> 1.0.2d is being rejected by Google Play</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Bugs</div>
<ul>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/911">#911</a> Multiple duplicate replication change events sent in pull replication</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1334">#1334</a> Change tracker stopped during continuous replication error thrown when cookie expires</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1385">#1385</a> CBLReplicatorExecutor still exists after stopping the replicator</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1470">#1470</a> IOS pull replication from Android</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1471">#1471</a> Attachments failed to replicate when deleted and recreated</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1481">#1481</a> ConnectionError: ('Connection aborted.', error(54, 'Connection reset by peer'))</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1493">#1493</a> Test failure ViewsTest.failingTestAllDocumentsLiveQuery on Jenkins</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1495">#1495</a> Changes feed skipping changes on rapid long poll</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1498">#1498</a> Was not able to delete the database directory, Status: 500 (HTTP 500 Internal Server Error)</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1510">#1510</a> Mixing HashMap and TreeMap for properties in Document.
HashMap allows to generate non-canonical JSON.</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1534">#1534</a> Push Replication Fails With createTarget Set</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1535">#1535</a> ForestDB Views Issue :Router: Router unable to route request to do_GET_DesignDocument(java.lang.NullPointerException)</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1539">#1539</a> Small load - ConnectionError: ('Connection aborted.', error(54, 'Connection reset by peer'))</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1540">#1540</a> _replicate REST API with one-shot returns immediately.</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1549">#1549</a> 1.4-12 ConnectionError: ('Connection aborted.', error(54, 'Connection reset by peer')) during doc add</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1550">#1550</a> Test Failure: testAndroid2MLimit</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1551">#1551</a> Test failure: testMultipleLiveQueries</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1552">#1552</a> P2P fails between android and macosx</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1553">#1553</a> Test Failure: testGetDocumentWithLargeJSON</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1557">#1557</a> List not syncing during test fest (Need to reproduce).</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1558">#1558</a> Listener returning different error codes for negative tests 1.3.1 vs 1.4</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1563">#1563</a> Database deletion failing with 1.4-25</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1564">#1564</a> P2P sanity test failing</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1575">#1575</a> SSL with allowSelfSignedSSLCertificates() method</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1576">#1576</a> [Functional Test] Socket timeout when pushing docs to LiteServ</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1578">#1578</a> Image attachment not sync&#8217;ing from .NET to Android</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1581">#1581</a> Replication failures when running Sync Gateway in distributed index</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1585">#1585</a> ForestDB + Encryption - SIGSEGV during database deletion</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1588">#1588</a> Investigate test_verify_open_revs_with_revs_limit_push_conflict failure</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1589">#1589</a> Investigate possible push replication issue</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1590">#1590</a> Investigate failure at client.stop_replication()</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1592">#1592</a> Find root cause of ConnectionError: ('Connection aborted.', error(54, 'Connection reset by peer'))</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1593">#1593</a> Missing changes on changes feed (Mac &#8592; Android) pull replication</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1595">#1595</a> Database error with peer-2-peer-sanity test</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1597">#1597</a> P2P - ForestDB Error: forceInsert()</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-java-core/issues/1599">#1599</a> Updates not propagating to SQLite Client</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</article>
</main>
</div>
<footer class="footer">
  <div class="container">
    <div class="footer-links">
      <div class="col">
        <div class="footer-logo">
          <a href="https://www.couchbase.com" class="icon">
            <img src="../../_/img/logo.svg" alt="Couchbase">
          </a>
        </div>
        <div class="contact">
          <p class="address">3250 Olcott Street
Santa Clara, CA 95054
United States</p>
          <a href="https://www.couchbase.com/contact" class="btn white-btn">Contact Us</a>
          <a class="tel" href="tel:1-650-417-7500">1-650-417-7500</a>
        </div>
      </div>
      <div class="col">
        <ul>
          <li><span class="heading">Company</span></li>
          <li><a href="https://www.couchbase.com/about">About</a></li>
          <li><a href="https://www.couchbase.com/leadership">Leadership</a></li>
          <li><a href="https://www.couchbase.com/news-and-press-releases">News &amp; Press</a></li>
          <li><a href="https://www.couchbase.com/careers">Careers</a></li>
          <li><a href="https://www.couchbase.com/resources/events">Events</a></li>
          <li><a href="https://www.couchbase.com/contact">Contact Us</a></li>
          <li><a href="https://www.couchbase.com/request-pricing">Pricing</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><span class="heading">Support</span></li>
          <li><a href="https://developer.couchbase.com" target="_blank" rel="noopener">Developer Portal</a></li>
          <li><a href="https://docs.couchbase.com" target="_blank" rel="noopener">Documentation</a></li>
          <li><a href="https://forums.couchbase.com" target="_blank" rel="noopener">Forums</a></li>
          <li><a href="https://www.couchbase.com/services">Professional Services</a></li>
          <li><a href="https://support.couchbase.com" target="_blank" rel="noopener">Support Login</a></li>
          <li><a href="https://learn.couchbase.com/store" target="_blank" rel="noopener">Training</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><span class="heading">Quicklinks</span></li>
          <li><a href="https://blog.couchbase.com" target="_blank" rel="noopener">Blog</a></li>
          <li><a href="https://www.couchbase.com/downloads">Downloads</a></li>
          <li><a href="https://www.couchbase.com/get-started-developing-nosql">Get Started</a></li>
          <li><a href="https://learn.couchbase.com/store?utf8=%E2%9C%93&ss=1&ct=78327&commit=Filter" target="_blank" rel="noopener">Online Training</a></li>
          <li><a href="https://www.couchbase.com/resources">Resources</a></li>
          <li><a href="https://www.couchbase.com/nosql-resources/why-nosql">Why NoSQL</a></li>
          <li><a href="https://www.couchbase.com/resources/security">Security</a></li>
          <li><a href="https://www.couchbase.com/resources/gdpr">GDPR</a></li>
        </ul>
      </div>
      <div class="col">
        <ul class="social-icons">
          <li>
            <a href="https://www.facebook.com/Couchbase" class="icon">
              <svg width="50px" height="50px" viewBox="26.363 116.363 560.215 560.215"><path d="m586.58 209.58c0-48.96-44.252-93.212-93.212-93.212h-373.79c-48.96 0-93.212 44.252-93.212 93.212v373.79c0 48.96 44.252 93.212 93.212 93.212h186.42v-211.85h-68.732v-93.212h68.732v-36.72c0-63.083 47.077-119.58 105.45-119.58h75.323v93.212h-75.323c-8.474 0-17.889 10.357-17.889 25.422v37.662h93.212v93.212h-93.212v211.85h99.803c48.96 0 93.212-44.252 93.212-93.212v-373.79z"/></svg>
            </a>
          </li>
          <li>
            <a href="https://twitter.com/couchbase" class="icon">
              <svg width="50px" height="50px" viewBox="32.012 176.622 542.326 437.815"><path d="m574.34 227.46c-19.772 8.474-41.428 15.065-64.025 17.889 22.597-14.123 40.486-35.778 48.96-61.2-21.655 13.182-45.194 21.655-70.615 27.305-20.714-21.655-48.96-34.837-80.972-34.837-61.2 0-111.1 49.902-111.1 111.1 0 8.474 0.942 16.948 2.825 25.422-92.271-5.649-174.18-49.902-229.74-117.69-9.415 16.006-15.065 35.778-15.065 55.551 0 38.603 19.772 72.498 49.902 92.271-17.889-0.942-35.778-5.649-50.843-14.123v0.942c0 53.668 38.603 98.862 89.446 109.22-9.415 2.825-18.831 3.766-29.188 3.766-7.532 0-14.123-0.942-20.714-1.883 14.123 44.252 55.551 76.265 103.57 77.206-37.662 30.129-85.68 48.018-138.41 48.018-9.415 0-17.889-0.941-26.363-1.883 48.96 32.012 107.34 49.902 170.42 49.902 204.31 0 316.36-169.48 316.36-316.36v-14.123c21.656-14.125 40.487-33.897 55.551-56.494z"/></svg>
            </a>
          </li>
          <li>
            <a href="https://www.linkedin.com/company/couchbase" class="icon">
              <svg width="50px" height="50px" viewBox="31.071 119.188 539.537 540.443"><path d="m531.97 119.19h-461.35c-21.655 0-39.545 16.948-39.545 38.603v463.24c0 21.655 17.889 38.603 39.545 38.603h460.41c21.655 0 39.545-16.948 39.545-38.603v-463.24c0.942-21.656-16.947-38.603-38.603-38.603zm-337.07 451.94h-81.914v-243.86h81.914v243.86zm-40.486-276.81c-28.246 0-46.135-18.831-46.135-42.369s17.889-42.369 46.135-42.369 45.194 17.889 45.194 42.369c0.942 23.538-16.948 42.369-45.194 42.369zm335.19 276.81h-81.914v-129.93c0-32.954-12.24-55.551-41.428-55.551-22.597 0-35.778 15.065-41.428 30.129-1.883 5.649-2.825 12.24-2.825 19.772v136.52h-81.914s0.942-221.26 0-243.86h81.914v34.837c11.298-16.948 30.129-40.486 73.44-40.486 53.668 0 94.154 34.837 94.154 110.16l1e-3 138.41zm-168.54-208.08s0.941-0.941 0 0z"/></svg>
            </a>
          </li>
          <li>
            <a href="https://plus.google.com/+CouchbaseServer" class="icon">
              <svg width="50px" height="50px" viewBox="36.72 225.573 542.326 343.67"><path d="m209.02 363.05v68.732h93.212c-15.065 44.252-37.662 68.732-93.212 68.732-56.492 0-100.74-46.135-100.74-102.63s44.252-102.63 100.74-102.63c30.129 0 48.96 10.357 66.849 25.422 14.123-14.123 13.182-16.006 48.96-49.902-31.071-28.246-71.557-45.194-115.81-45.194-95.096-0.94-172.3 76.266-172.3 171.36s77.206 172.3 172.3 172.3c142.17 0 177.01-124.28 165.71-206.2-33.896-1e-3 -165.71-1e-3 -165.71-1e-3zm310.71 3.766v-59.317h-42.369v59.317h-61.2v42.369h61.2v61.2h42.369v-61.2h59.317v-42.369h-59.317z"/></svg>
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="footer-terms">
      <span>2018 COUCHBASE All rights reserved.</span>
      <a href="https://www.couchbase.com/privacy-policy">Privacy Policy</a>
      <a href="https://www.couchbase.com/terms-of-use">Terms of Use</a>
      <a href="https://www.couchbase.com/cookie-policy">Cookie Policy</a>
      <a href="https://info.couchbase.com/unsubscribe-or-manage-preferences.html" target="_blank" rel="noopener">Marketing Preference Center</a>
    </div>
  </div>
</footer>
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
