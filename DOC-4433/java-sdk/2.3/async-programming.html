<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>Asynchronous Progamming Using the Java SDK with Couchbase Server | Couchbase Docs (Staging)</title>
    <link rel="canonical" href="https://simon-dew.github.io/docs-site/DOC-4433/java-sdk/2.7/async-programming.html">
    <link rel="stylesheet" href="../../_/css/site.css">
    <link rel="schema.dcterms" href="https://purl.org/dc/terms/">
    <meta name="dcterms.subject" content="java-sdk">
    <meta name="dcterms.identifier" content="2.3">
    <meta name="generator" content="Antora 1.1.1">
    <link rel="icon" href="../../_/img/favicon.ico" type="image/x-icon">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar" id="topbar">
    <div class="container">
      <div class="navbar-brand">
        <a class="navbar-item" href="https://www.couchbase.com"><img src="../../_/img/logo.svg" alt="Couchbase"></a>
        <button class="navbar-burger" data-target="topbar-menu">
          <span></span>
          <span></span>
          <span></span>
        </button>
      </div>
      <div id="topbar-menu" class="navbar-menu">
        <div class="navbar-start">
          <div class="navbar-item has-dropdown">
            <a class="navbar-link" href="https://simon-dew.github.io/docs-site/DOC-4433">Docs</a>
            <div class="navbar-dropdown explore">
              <div class="title">Couchbase Documentation Overview</div>
              <div class="cols">
                <ul>
                  <li class="heading"><a href="../../server/6.0/introduction/intro.html">Server</a></li>
                  <li><a href="../../server/6.0/n1ql/n1ql-language-reference/index.html">N1QL</a></li>
                  <li><a href="../../server/6.0/fts/full-text-intro.html">Full Text Search</a></li>
                  <li><a href="../../server/6.0/analytics/introduction.html">Analytics</a></li>
                  <li><a href="../../server/6.0/eventing/eventing-overview.html">Eventing</a></li>
                  <li><a href="../../operator/1.2/overview.html">Autonomous Operator</a></li>
                </ul>
                <ul>
                  <li class="heading">Mobile</li>
                  <li><a href="../../couchbase-lite/2.5/index.html">Lite</a></li>
                  <li><a href="../../sync-gateway/2.5/index.html">Sync Gateway</a></li>
                </ul>
                <ul class="two-cols">
                  <li class="heading"><a href="../../server/6.0/sdk/overview.html">SDKs</a></li>
                  <li><a href="../../c-sdk/2.10/start-using-sdk.html">C</a></li>
                  <li><a href="../../dotnet-sdk/2.7/start-using-sdk.html">.NET</a></li>
                  <li><a href="../../go-sdk/1.5/start-using-sdk.html">Go</a></li>
                  <li><a href="../../java-sdk/2.7/start-using-sdk.html">Java</a></li>
                  <li><a href="../../nodejs-sdk/2.6/start-using-sdk.html">Node.js</a></li>
                  <li><a href="../../php-sdk/2.6/start-using-sdk.html">PHP</a></li>
                  <li><a href="../../python-sdk/2.5/start-using-sdk.html">Python</a></li>
                </ul>
                <ul>
                  <li class="heading"><a href="../../server/6.0/connectors/intro.html">Connectors</a></li>
                  <li><a href="../../elasticsearch-connector/4.0/index.html">Elasticsearch</a></li>
                  <li><a href="../../server/6.0/connectors/hadoop-1.2/hadoop.html">Hadoop</a></li>
                  <li><a href="../../kafka-connector/3.4/index.html">Kafka</a></li>
                  <li><a href="../../spark-connector/2.2/index.html">Spark</a></li>
                  <li><a href="../../talend-connector/index.html">Talend</a></li>
                  <li><a href="../../server/6.0/connectors/odbc-jdbc-drivers.html">ODBC/JDBC</a></li>
                </ul>
              </div>
            </div>
          </div>
          <div class="navbar-item has-dropdown">
            <a class="navbar-link component" href="start-using-sdk.html"><span class="title">Java SDK</span> <span class="version">2.3</span></a>
            <div class="navbar-dropdown versions">
              <div class="cols">
                <ul>
                  <li><a class="navbar-item" href="../2.7/async-programming.html">Java SDK 2.7</a></li>
                  <li><a class="navbar-item" href="../2.6/async-programming.html">Java SDK 2.6</a></li>
                  <li><a class="navbar-item" href="../2.5/async-programming.html">Java SDK 2.5</a></li>
                  <li><a class="navbar-item" href="../2.4/async-programming.html">Java SDK 2.4</a></li>
                  <li><a class="navbar-item" href="../2.2/java-intro.html">Java SDK 2.2</a></li>
                  <li><a class="navbar-item" href="../2.1/java-intro.html">Java SDK 2.1</a></li>
                </ul>
                <ul class="related">
                  <li><a class="navbar-item" href="../../c-sdk/2.10/async-programming.html">C SDK</a></li>
                  <li><a class="navbar-item" href="../../dotnet-sdk/2.7/async-programming.html">.NET SDK</a></li>
                  <li><a class="navbar-item" href="../../go-sdk/1.5/async-programming.html">Go SDK</a></li>
                  <li><a class="navbar-item" href="../../nodejs-sdk/2.6/async-programming.html">Node.js SDK</a></li>
                  <li><a class="navbar-item" href="../../php-sdk/2.6/async-programming.html">PHP SDK</a></li>
                  <li><a class="navbar-item" href="../../python-sdk/2.5/async-programming.html">Python SDK</a></li>
                </ul>
              </div>
            </div>
          </div>
        </div>
        <div class="navbar-end">
          <div class="navbar-item">
            <a class="btn red-btn" href="https://www.couchbase.com/downloads">Downloads</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body container">
<nav class="nav">
<div class="nav-menu">
<ul class="nav-list">
  <li class="nav-item is-active" data-depth="0">
    <span class="nav-line">
    <button class="nav-toggle"></button>
    <span class="nav-text">Hello World!</span>
    </span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="start-using-sdk.html">Start Using the SDK</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="sample-application.html">Sample Application</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="webui-cli-access.html">Browser and CLI Access</a>
    </span>
  </li>
</ul>
  </li>
  <li class="nav-item is-current-path is-active" data-depth="0">
    <span class="nav-line">
    <button class="nav-toggle"></button>
    <span class="nav-text">Working with Data</span>
    </span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="core-operations.html">Core Operations</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="document-operations.html">Document Operations</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="subdocument-operations.html">Sub-Document Operations</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="n1ql-query.html">Querying with N1QL</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="n1ql-queries-with-sdk.html">N1QL from the SDK</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="full-text-search-overview.html">Full Text Search</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="full-text-searching-with-sdk.html">Searching from the SDK</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="view-queries-with-sdk.html">MapReduce Views</a>
    </span>
  </li>
  <li class="nav-item is-current-page is-active" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="async-programming.html">Asynchronous Programming</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="batching-operations.html">Batching Operations</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="durability.html">Durability</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="concurrent-mutations-cluster.html">Concurrent Document Mutations</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="nonjson.html">Non-JSON Documents</a>
    </span>
  </li>
</ul>
  </li>
  <li class="nav-item is-active" data-depth="0">
    <span class="nav-line">
    <button class="nav-toggle"></button>
    <span class="nav-text">Deployment Environments</span>
    </span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="managing-connections.html">Managing Connections</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="managing-clusters.html">Managing Clusters</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="compatibility-versions-features.html">Compatibility</a>
    </span>
  </li>
</ul>
  </li>
  <li class="nav-item is-active" data-depth="0">
    <span class="nav-line">
    <button class="nav-toggle"></button>
    <span class="nav-text">Settings, Error Handling &amp; Diagnostics</span>
    </span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="client-settings.html">Client Settings</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="handling-error-conditions.html">Handling Errors</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="failure-considerations.html">Failure Considerations</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="collecting-information-and-logging.html">Collecting Information</a>
    </span>
  </li>
</ul>
  </li>
  <li class="nav-item is-active" data-depth="0">
    <span class="nav-line">
    <button class="nav-toggle"></button>
    <span class="nav-text">Project Docs</span>
    </span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="relnotes-java-sdk.html#version-2-3-7-19-january-2017">Release Notes</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="compatibility-versions-features.html">Compatibility</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="sdk-licenses.html">Licenses</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <button class="nav-toggle"></button>
    <a class="nav-link" href="get-involved.html">Get involved</a>
    </span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <span class="nav-line">
    <a class="nav-link" href="https://docs.couchbase.com/home/contribute/index.html">Improve the Docs</a>
    </span>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
</div>
</nav>
<aside class="toc sidebar">
  <div class="toc-menu"></div>
</aside>
<main class="article" data-ceiling="topbar">
  <div class="article-banner">
    <p>A newer version of this documentation is available.</p>
    <a class="btn" href="../2.7/async-programming.html">View Latest</a>
  </div>
  <div class="article-header">
<button class="nav-control"></button>
<nav class="crumbs" aria-label="breadcrumbs">
  <ul>
    <li class="crumb"><a href="start-using-sdk.html">Java SDK</a></li>
    <li class="crumb">Working with Data</li>
    <li class="crumb"><a href="async-programming.html">Asynchronous Programming</a></li>
  </ul>
</nav>
<div class="tools" role="navigation">
  <ul>
    <li class="tool edit"><a href="https://github.com/couchbase/docs-sdk-java/edit/release/2.3/modules/ROOT/pages/async-programming.adoc" title="Edit Page" target="_blank" rel="noopener">Edit</a></li>
  </ul>
</div>
  </div>
<article class="doc">
<h1 class="page">Asynchronous Progamming Using the Java SDK with Couchbase Server</h1>
<div id="preamble">
<div class="sectionbody">
<div class="quoteblock abstract">
<blockquote>
The Couchbase Java SDK has a complete asynchronous API based in part on RxJava.
This section provides information on how the asynchronous API can be used, how it works with Java platform and RxJava features and the kinds of error handling you will need to consider in application development.
</blockquote>
</div>
</div>
</div>
<div class="sect1">
<h2 id="java-8-lambdas-and-anonymous-classes"><a class="anchor" href="#java-8-lambdas-and-anonymous-classes"></a>Java 8, Lambdas and Anonymous Classes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before jumping into the details, one thing warrants clarification: RxJava and, therefore, the Java SDK, fully support Java 8.
This support brings some great improvements, most prominently support for <em class="term">lambdas</em> and <em class="term">method references</em>.</p>
</div>
<div class="paragraph">
<p>Because the Java SDK has support for Java 6 and 7, most of the examples shown in the documentation use anonymous classes instead of lambdas.
You are free and even encouraged to use them if you can, but Java 8 may not be an option for some.</p>
</div>
<div class="paragraph">
<p>To whet your appetite for why you may want to strongly consider these features, compare the same Java 6 code to Java 8:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Loads 3 documents in parallel
Observable
    .just("doc1", "doc2", "doc3")
    .flatMap(new Func1&lt;String, Observable&lt;JsonDocument&gt;&gt;() {
        @Override
        public Observable&lt;JsonDocument&gt; call(String id) {
            return bucket.get(id);
        }
    }).forEach(new Action1&lt;JsonDocument&gt;() {
        @Override
        public void call(JsonDocument document) {
            System.out.println("Got: " + document);
        }
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>Versus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Loads 3 documents in parallel
Observable
    .just("doc1", "doc2", "doc3")
    .flatMap(bucket::get)
    .forEach(document -&gt; System.out.println("Got: " + document));</code></pre>
</div>
</div>
<div class="paragraph">
<p>RxJava has additional support for other languages such as Scala, Groovy, Kotlin or Clojure through language adapters.
If you are using one of those, refer to the RxJava documentation on how to use the adapters.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="understanding-observables"><a class="anchor" href="#understanding-observables"></a>Understanding Observables</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can think of an <em class="term">Observable</em> as the push-based, asynchronous cousin ("dual") of the pull-based, synchronous <em class="term">Iterable</em>.
The contract of an <code>Observable</code> is that zero to N data events can happen, followed by a complete event.
An error event can also happen at any time and complete the <code>Observable</code>.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. The duality of Iterable and Observable</caption>
<colgroup>
<col style="width: 33.5118%;">
<col style="width: 32.8232%;">
<col style="width: 33.665%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Event</th>
<th class="tableblock halign-left valign-top">Iterable (Pull)</th>
<th class="tableblock halign-left valign-top">Observable (Push)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">retrieve data</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T next()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>onNext(T)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">discover error</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>throws Exception</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>onError(Exception)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">complete</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>returns</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>onCompleted()</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>You can convert an <code>Observable</code> into a <code>BlockingObservable</code>, which then behaves very much like the <code>Iterable</code>.</p>
</div>
<div class="paragraph">
<p>The key element to take away is that an <code>Observable&lt;T&gt;</code> can emit 0 to N events, which is very different than a <code>Future&lt;T&gt;</code> that only contains one value.
After you start to work on streams instead of single values, you will very much appreciate this fact.</p>
</div>
<div class="paragraph">
<p>By definition, an <code>Observable</code> does not imply that the underlying code is executed asynchronously.
As a consumer of an <code>Observable</code>, you leave the actual implementation to the supplier, who can change it later on without you having to adapt your code.
Imagine, you are consuming this API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface FooService {
    Observable&lt;String&gt; load();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It could be that when <code>load()</code> is called, the <code>String</code> value is fetched right out of a <code>Map</code> in memory (or even a hard-coded value).
In this case, there is no need to move the execution away from the caller thread, because the value will be returned instantaneously.
If later the implementation needs to be changed so that the <code>String</code> is loaded through a web service (introducing latency and other semantics), the API doesn&#8217;t need to be changed because the underlying implementation is free to move it to a <code>Scheduler</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="consuming-observables"><a class="anchor" href="#consuming-observables"></a>Consuming Observables</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The first thing you want to do when working with <code>Observables</code> is to consume them.
Consuming an <code>Observable</code> means subscribing to it.
Here is an example that subscribes and prints out all the items emitted:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable
    .just(1, 2, 3)
    .subscribe(new Subscriber&lt;Integer&gt;() {
        @Override
        public void onCompleted() {
            System.out.println("Completed Observable.");
        }

        @Override
        public void onError(Throwable throwable) {
            System.err.println("Whoops: " + throwable.getMessage());
        }

        @Override
        public void onNext(Integer integer) {
            System.out.println("Got: " + integer);
        }
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example prints the following lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Got: 1
Got: 2
Got: 3
Completed Observable.</pre>
</div>
</div>
<div class="paragraph">
<p>You can see that our <code>Subscriber</code> gets notified of every event and also receives the completed event.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A well-formed <code>Observable</code> invokes its subscriberâ€™s <code>onNext</code> method zero or more times and then invokes either the <code>onCompleted</code> or <code>onError</code> method exactly once.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also test the error case by throwing an artificial exception when the value 2 is emitted:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable
    .just(1, 2, 3)
    .doOnNext(new Action1&lt;Integer&gt;() {
        @Override
        public void call(Integer integer) {
            if (integer.equals(2)) {
                throw new RuntimeException("I don't like 2");
            }
        }
    })
    .subscribe(new Subscriber&lt;Integer&gt;() {
        @Override
        public void onCompleted() {
            System.out.println("Completed Observable.");
        }

        @Override
        public void onError(Throwable throwable) {
            System.err.println("Whoops: " + throwable.getMessage());
        }

        @Override
        public void onNext(Integer integer) {
            System.out.println("Got: " + integer);
        }
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example prints:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Got: 1
Whoops: I don't like 2</pre>
</div>
</div>
<div class="paragraph">
<p>The first value gets through without problems, the second value throws an exception and, therefore, terminates the <code>Observable</code>.
No subsequent values are allowed to be emitted after an error event.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>subscribe</code> method also returns a <code>Subscription</code> that you can use to <code>unsubscribe</code> and not receive further events.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Even if you don&#8217;t unsubscribe explicitly, operations like <code>take</code> do that for you implicitly.
The following code only takes the first five values and then unsubscribes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable
    .just("The", "Dave", "Brubeck", "Quartet", "Time", "Out")
    .take(5)
    .subscribe(new Subscriber&lt;String&gt;() {
        @Override
        public void onCompleted() {
            System.out.println("Completed Observable.");
        }

        @Override
        public void onError(Throwable throwable) {
            System.err.println("Whoops: " + throwable.getMessage());
        }

        @Override
        public void onNext(String name) {
            System.out.println("Got: " + name);
        }
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>This prints:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Got: The
Got: Dave
Got: Brubeck
Got: Quartet
Got: Time
Completed Observable.</pre>
</div>
</div>
<div class="paragraph">
<p>You do not need to implement the full subscriber every time.
If you are only interested in the data events, you can subscribe like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable
    .just(1, 2, 3)
    .subscribe(new Action1&lt;Integer&gt;() {
        @Override
        public void call(Integer integer) {
            System.out.println("Got: " + integer);
        }
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>Be aware though that if an error happens, the following exception will be propagated:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Exception in thread "main" rx.exceptions.OnErrorNotImplementedException
	at rx.Observable$36.onError(Observable.java:8412)
	at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:128)
	at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:97)
	at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:67)
	at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:78)
	at rx.internal.operators.OnSubscribeFromIterable$IterableProducer
          .request(OnSubscribeFromIterable.java:76)
	...</pre>
</div>
</div>
<div class="paragraph">
<p>It is recommended always to implement an error handler right from the beginning since things can and will go wrong at some point.
It can come in handy though if you just want to try things out quickly or for illustrative purposes.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="from-asynchronous-to-synchronous"><a class="anchor" href="#from-asynchronous-to-synchronous"></a>From Asynchronous to Synchronous</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As long as your <code>Observable</code> works on the same thread all the time, there is no need for communication between threads since only one is executing.
When your <code>Observable</code> flow gets executed on a different thread, you need to take some extra care to make sure you are not missing values.
This is not specific to <code>Observables</code>: every time you need to deal with parallel threads you need to think about synchronization and communication.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Most of the snippets in this documentation only call <code>subscribe</code>.
You should ensure that your program doesn&#8217;t terminate before <code>onCompleted()</code> is called (e.g., via <code>toBlocking()</code> or a <code class="api">CountDownLatch</code>) and be aware of that when trying to replicate a snippet in its Main class.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You should never perform long-running blocking operations inside of an asynchronous stream (e.g.
inside of <code>map</code>s or <code>flatMap</code>s).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following code emits an increasing value every second, which is done on a different thread:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static void main(String... args) {
    Observable
        .interval(1, TimeUnit.SECONDS)
        .subscribe(new Action1&lt;Long&gt;() {
            @Override
            public void call(Long counter) {
                System.out.println("Got: " + counter);
            }
        });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It works perfectly fine; the only problem is though chances are you won&#8217;t see anything printed out.
Your main thread exits before the background thread had a chance to run and emit values.</p>
</div>
<div class="paragraph">
<p>A common way to deal with such a situation is to add a <code>CountDownLatch</code>, which allows you to synchronize between different threads.
One thread counts down the latch; the other one waits until it is counted down:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">final CountDownLatch latch = new CountDownLatch(5);
Observable
    .interval(1, TimeUnit.SECONDS)
    .subscribe(new Action1&lt;Long&gt;() {
        @Override
        public void call(Long counter) {
            latch.countDown();
            System.out.println("Got: " + counter);
        }
    });

latch.await();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example prints the following lines and then exits:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Got: 0
Got: 1
Got: 2
Got: 3
Got: 4</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>One common mistake is to use <code>Thread.sleep()</code> instead of a latch to synchronize the execution between threads.
This is a bad idea because it synchronizes nothing and just keeps one thread alive for a specific amount of time.
If the actual calls take less time you are wasting time, and if it takes longer you won&#8217;t get the desired effect.
If you do this in unit tests, be prepared for a good amount of non-determinism and randomly failing tests.</p>
</div>
<div class="paragraph">
<p><strong>Always use a CountDownLatch!</strong></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A technique unique to <code>Observables</code> is to convert it into a <code>BlockingObservable</code> to achieve the same effect.
In simple terms, it converts an <code>Observable</code> into an <code>iterable</code> and makes it execute on the caller thread, blocking it until one or more values arrive.
This technique is used extensively in the documentation to show concepts, while not having to deal with count-down latches all the time.
It can also be used if you for some reason are not able to use asynchronous computations.</p>
</div>
<div class="paragraph">
<p>The conversion itself doesn&#8217;t do any blocking in the first place, only subsequent calls will:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// This does not block.
BlockingObservable&lt;Long&gt; observable = Observable
    .interval(1, TimeUnit.SECONDS)
    .toBlocking();

// This blocks and is called for every emitted item.
observable.forEach(new Action1&lt;Long&gt;() {
    @Override
    public void call(Long counter) {
        System.out.println("Got: " + counter);
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because this will run forever, you are free to chain any asynchronous computations before.
Thus, you can build an asynchronous workflow and then block at the very end.
This resembles the same code as with the <code>CountDownLatch</code> before:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable
    .interval(1, TimeUnit.SECONDS)
    .take(5)
    .toBlocking()
    .forEach(new Action1&lt;Long&gt;() {
        @Override
        public void call(Long counter) {
            System.out.println("Got: " + counter);
        }
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you know that only a single value is ever returned, you can use the <code class="api">single()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">int value = Observable
    .just(1)
    .toBlocking()
    .single();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Be aware though that if more items get emitted, you get an exception:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Exception in thread "main" java.lang.IllegalArgumentException: Sequence contains too many elements
	at rx.internal.operators.OperatorSingle$1.onNext(OperatorSingle.java:58)
	at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:76)
	at rx.Subscriber.setProducer(Subscriber.java:148)
	at rx.Subscriber.setProducer(Subscriber.java:144)
	....</pre>
</div>
</div>
<div class="paragraph">
<p>The same thing happens if no value gets emitted:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Exception in thread "main" java.util.NoSuchElementException: Sequence contains no elements
	at rx.internal.operators.OperatorSingle$1.onCompleted(OperatorSingle.java:82)
	at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:79)
	at rx.Subscriber.setProducer(Subscriber.java:148)
	at rx.Subscriber.setProducer(Subscriber.java:144)
	at rx.Subscriber.setProducer(Subscriber.java:144)
	at rx.Subscriber.setProducer(Subscriber.java:144)
	....</pre>
</div>
</div>
<div class="paragraph">
<p>As an alternative, you can use <code>singleOrDefault()</code> so that a fallback value gets returned.</p>
</div>
<div class="paragraph">
<p>You can use this technique with the Java SDK if you are loading a document and it does not exist:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">JsonDocument doc = bucket.get("id").toBlocking().singleOrDefault(null);
if (doc == null) {
    System.err.println("Document not found!");
} else {
    System.out.println(doc);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you check out the API documentation of the <code class="api">BlockingObservable</code>, you will discover many more possibilities, including iterators or grabbing the first and last values.</p>
</div>
<div class="paragraph">
<p>One last thing that comes in handy with blocking calls: sometimes you want to collect all emitted values into a list.
You can combine the blocking calls with the toList() operator to achieve something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">List&lt;Integer&gt; list = Observable
    .just(1, 2, 3)
    .toList()
    .toBlocking()
    .single();

// Prints: [1, 2, 3]
System.out.println(list);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-observables"><a class="anchor" href="#creating-observables"></a>Creating Observables</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are many ways to create <code>Observables</code>, and you&#8217;ve already seen <code class="api">just()</code> and <code class="api">interval()</code>.
There are much more such  convenience methods available on the <code>Observable</code> class, but they all boil down to the <code class="api">create()</code> method.
You can simulate the example from before with this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() {
    @Override
    public void call(Subscriber&lt;? super Integer&gt; subscriber) {
        try {
            if (!subscriber.isUnsubscribed()) {
                for (int i = 0; i &lt; 5; i++) {
                    subscriber.onNext(i);
                }
                subscriber.onCompleted();
            }
        } catch (Exception ex) {
            subscriber.onError(ex);
        }
    }
}).subscribe(new Action1&lt;Integer&gt;() {
    @Override
    public void call(Integer integer) {
        System.out.println("Got: " + integer);
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Every time a Subscriber subscribes, the <code class="api">call()</code> method is executed.
You can then call <code>onNext</code>, <code>onComplete</code> and <code>onError</code> as you wish, but keep in mind that both <code>onComplete</code> and <code>onError</code> should only be called once, and afterward no subsequent <code class="api">onNext</code> is allowed to follow so that the contract is met.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This example shows why it is crucial to call <code class="api">subscribe()</code> on the <code>Observable</code>, because only such a call triggers the actual execution of the pipeline.
This is a little different with subjects, which are covered later in this guide.
Nevertheless, always call <code class="api">subscribe()</code> on your observables.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="transforming-observables"><a class="anchor" href="#transforming-observables"></a>Transforming Observables</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Observables can transform their values in various ways.
One of the most basic ones is <code class="api">map()</code>, which converts the incoming value into a different one.
You surely like division, so here is the FizzBuzz game:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable
    .interval(10, TimeUnit.MILLISECONDS)
    .take(20)
    .map(new Func1&lt;Long, String&gt;() {
        @Override
        public String call(Long input) {
            if (input % 3 == 0) {
                return "Fizz";
            } else if (input % 5 == 0) {
                return "Buzz";
            }
            return Long.toString(input);
        }
    })
    .toBlocking()
    .forEach(new Action1&lt;String&gt;() {
        @Override
        public void call(String s) {
            System.out.println(s);
        }
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>The map function is used to convert the input number into a string and do some checks to satisfy the FizzBuzz game.
As a more practical example, consider loading a document from the Java SDK and only extracting the first name of a user before passing it on:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">bucket
    .get("id")
    .map(new Func1&lt;JsonDocument, String&gt;() {
        @Override
        public String call(JsonDocument document) {
            return document.content().getString("firstname");
        }
    }).subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p>A variation of <code class="api">map()</code> is called <code class="api">flatMap()</code>, which allows you to do those transformations with asynchronous calls.
Taking the example from above, we want to map from String (the document ID) to a <code>JsonDocument</code> (the loaded document).
With a normal <code class="api">map()</code>, call you would either need to block on the <code>Observable</code> or at some point deal with an <code>Observable&lt;Observable&lt;JsonDocument&gt;&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Thankfully, <code class="api">flatMap()</code> flattens the resulting values for us and return them into the original flow:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Loads 3 documents in parallel
Observable
    .just("doc1", "doc2", "doc3")
    .flatMap(new Func1&lt;String, Observable&lt;JsonDocument&gt;&gt;() {
        @Override
        public Observable&lt;JsonDocument&gt; call(String id) {
            return bucket.get(id);
        }
    }).subscribe(new Action1&lt;JsonDocument&gt;() {
        @Override
        public void call(JsonDocument document) {
            System.out.println("Got: " + document);
        }
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see that <code class="api">flatMap()</code> returns an Observable&lt;T&gt; whereas the normal map just returns &lt;T&gt;.
You will use <code class="api">flatMap()</code> a lot when dealing with flows like this, so keep it in mind.</p>
</div>
<div class="paragraph">
<p>Another helpful transformation is <code class="api">scan()</code>.
It applies a function to each value emitted by an <code>Observable</code>, sequentially, and emits each successive value.
We can use it to aggregate values like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable
    .just(1, 2, 3, 4, 5)
    .scan(new Func2&lt;Integer, Integer, Integer&gt;() {
        @Override
        public Integer call(Integer sum, Integer value) {
            return sum + value;
        }
    }).subscribe(new Action1&lt;Integer&gt;() {
        @Override
        public void call(Integer integer) {
            System.out.println("Sum: " + integer);
        }
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>This prints:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Sum: 1
Sum: 3
Sum: 6
Sum: 10
Sum: 15</pre>
</div>
</div>
<div class="paragraph">
<p>Finally, <code class="api">groupBy()</code> comes in handy, which emits one <code>Observable</code> by each group, defined by a function.
The following example emits two <code>Observables</code>, one for even and one for odd values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable
    .just(1, 2, 3, 4, 5)
    .groupBy(new Func1&lt;Integer, Boolean&gt;() {
        @Override
        public Boolean call(Integer integer) {
            return integer % 2 == 0;
        }
    }).subscribe(new Action1&lt;GroupedObservable&lt;Boolean, Integer&gt;&gt;() {
        @Override
        public void call(GroupedObservable&lt;Boolean, Integer&gt; grouped) {
            grouped.toList().subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {
                @Override
                public void call(List&lt;Integer&gt; integers) {
                    System.out.println(integers + " (Even: " + grouped.getKey() + ")");
                }
            });
        }
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example prints:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[1, 3, 5] (Even: false)
[2, 4] (Even: true)</pre>
</div>
</div>
<div class="paragraph">
<p>Combined with the Java SDK, this technique can be used to separate returned Documents based on their content.
The following example uses a view to load all documents from the <code>beer-sample</code> bucket, groups them by type and counts the number of occurrences:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">bucket
    .query(ViewQuery.from("my_design_doc", "my_view"))
    .flatMap(ViewResult::rows)
    .flatMap(ViewRow::document)
    .groupBy(document -&gt; document.content().getString("type"))
    .subscribe(observable -&gt;
        observable.count().subscribe(integer -&gt;
            System.out.println(observable.getKey() + ": " + integer)
        )
    );</code></pre>
</div>
</div>
<div class="paragraph">
<p>This code queries the view, extracts all rows, loads the full document for each row, groups it by the <code>type</code> property in the JSON document and then uses the <code class="api">count()</code> operator to count the number of rows emitted by each <code>Observable</code>.
This prints something like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>brewery: 1412
beer: 5891</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="filtering-observables"><a class="anchor" href="#filtering-observables"></a>Filtering Observables</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In addition to transforming observables, you can also filter them.
Filtering doesn&#8217;t change the emitted values itself, but rather how much and at which point (and if at all) they are emitted.</p>
</div>
<div class="paragraph">
<p>For example, you can filter based on some criteria:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// This will only let 3 and 4 pass.
Observable
    .just(1, 2, 3, 4)
    .filter(new Func1&lt;Integer, Boolean&gt;() {
        @Override
        public Boolean call(Integer integer) {
            return integer &gt; 2;
        }
    }).subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or take only the first N values emitted and then unsubscribe:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Only 1 and 2 will pass.
Observable
    .just(1, 2, 3, 4)
    .take(2)
    .subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or use only the first or last value emitted:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Only 1 will pass
Observable
    .just(1, 2, 3, 4)
    .first()
    .subscribe();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Only 4 will pass
Observable
    .just(1, 2, 3, 4)
    .last()
    .subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, you can use distinct() to suppress duplicate values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// 1, 2, 3, 4 will be emitted
Observable
    .just(1, 2, 1, 3, 4, 2)
    .distinct()
    .subscribe();</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code class="api">distinct()</code> also allows you to pass in a function that returns the key to select by.
You can use this, for example, to separate out duplicate <code>JsonDocument</code> objects.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="combining-observables"><a class="anchor" href="#combining-observables"></a>Combining Observables</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Multiple <code>Observables</code> can also be merged to form a combined one.
Depending on how you want those to be merged, there are different operators available.
Two of the most used ones are <code class="api">merge()</code> and <code class="api">zip()</code> which are covered here.</p>
</div>
<div class="paragraph">
<p><code class="api">Merge</code> only merges all emitted values by the source <code>Observables</code> in the order they arrive:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable
    .merge(evens, odds)
    .subscribe(new Action1&lt;Integer&gt;() {
        @Override
        public void call(Integer integer) {
            System.out.println(integer);
        }
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example prints something similar to the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>2
4
6
8
10
1
3
5
7
9</pre>
</div>
</div>
<div class="paragraph">
<p>With the zip operator, you can combine two streams in the strictly same order, defined by a function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable&lt;Integer&gt; evens = Observable.just(2, 4, 6, 8, 10);
Observable&lt;Integer&gt; odds = Observable.just(1, 3, 5, 7, 9);

Observable
    .zip(evens, odds, (v1, v2) -&gt; v1 + " + " + v2 + " is: " + (v1 + v2))
    .subscribe(System.out::println);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This zips the pairs together in order and prints:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>2 + 1 is: 3
4 + 3 is: 7
6 + 5 is: 11
8 + 7 is: 15
10 + 9 is: 19</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="error-handling"><a class="anchor" href="#error-handling"></a>Error Handling</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Error handling is a vital component of every real world application and needs to be considered from the start.
RxJava provides sophisticated mechanisms to deal with errors that happen inevitably in your <code>Observable</code> flows.</p>
</div>
<div class="paragraph">
<p>In general, you want to react in the following ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Return a default value instead.</p>
</li>
<li>
<p>Flip over to a backup <code>Observable</code>.</p>
</li>
<li>
<p>Retry the <code>Observable</code> (immediately or with backoff).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Returning a default value is a good idea if you cannot afford to retry or you just don&#8217;t care (maybe because the flow is not crucial to your data flow).
The following code throws an exception at the first emitted item, but falls back to a default value:</p>
</div>
<div class="paragraph">
<p>Note that you can pass in a function that also takes the exception, so you can return different values for different exception types or use it for logging purposes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Prints:
// Default
// Oops: I don't like: Apples
Observable
    .just("Apples", "Bananas")
    .doOnNext(s -&gt; {
        throw new RuntimeException("I don't like: " + s);
    })
    .onErrorReturn(throwable -&gt; {
        System.err.println("Oops: " + throwable.getMessage());
        return "Default";
    }).subscribe(System.out::println);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also flip to a backup <code>Observable</code> that will be called if the first one fails.
The Java SDK has a <code class="api">getFromReplica()</code> command that  allows you to read stale data from its replicas and treat availability for consistency on reads.
You can use this approach to fall back:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">bucket
    .async()
    .get("id")
    .onErrorResumeNext(bucket.getFromReplica("id", ReplicaMode.ALL))
    .subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Normally you want to have more control on which <code>Observable</code> should be run next depending on the type of error.
The following example will only go to the replica if a <code>TimeoutException</code> happened (if not the error is passed down):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">bucket
    .async()
    .get("id")
    .timeout(500, TimeUnit.MILLISECONDS)
    .onErrorResumeNext(new Func1&lt;Throwable, Observable&lt;? extends JsonDocument&gt;&gt;() {
        @Override
        public Observable&lt;? extends JsonDocument&gt; call(Throwable throwable) {
            if (throwable instanceof TimeoutException) {
                return bucket.getFromReplica("id", ReplicaMode.ALL);
            }
            return Observable.error(throwable);
        }
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, it is possible to retry the <code>Observable</code> by resubscribing.
This can be done as quickly as possible, or with a backoff interval, which is preferred when external resources are involved.</p>
</div>
<div class="paragraph">
<p>The following program desperately tries to read the numbers from 1 to 10, but a (not so hidden) flaw makes it randomly throw an exception.
If that happens, the code retries.
Since lots of values might be already emitted, we can use <code class="api">distinct()</code> to filter those out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable
    .just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    .doOnNext(integer -&gt; {
        if (new Random().nextInt(10) + 1 == 5) {
            throw new RuntimeException("Boo!");
        }
    })
    .retry()
    .distinct()
    .subscribe(System.out::println);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you only want to retry for a max amount, replace the <code class="api">retry()</code> with a <code class="api">retry(count)</code> call.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you want to retry with backoff, you can use a technique like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable
    .range(1, 10)
    .doOnNext(integer -&gt; {
        if (new Random().nextInt(10) + 1 == 5) {
            throw new RuntimeException("Boo!");
        }
    })
    .retryWhen(attempts -&gt;
        attempts.zipWith(Observable.range(1, 3), (n, i) -&gt; i)
        .flatMap(i -&gt; {
            System.out.println("delay retry by " + i + " second(s)");
            return Observable.timer(i, TimeUnit.SECONDS);
        }))
    .distinct()
    .subscribe(System.out::println);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The attempts get passed into the <code class="api">retryWhen()</code> method and zipped with the number of seconds to wait.
The timer method is used to complete once its timer is done.
If you run this code a few times to generate an exception (or more), you will see something similar to this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1
2
3
4
delay retry by 1 second(s)
delay retry by 2 second(s)
5
6
7
8
9
10</pre>
</div>
</div>
<div class="paragraph">
<p>With the Java SDK the advanced <code>retryWhen</code> is easier to write using the <code>RetryBuilder</code> helper class.
These can be used to specify a filter on which kind of <code>Exception</code> to retry, for how many attempts, with any <code>Delay</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable
    .range(1, 10)
    .doOnNext(integer -&gt; {
         if (new Random().nextInt(10) + 1 == 5) {
             throw new RuntimeException("Boo!");
         }
    })
    .retryWhen(
         RetryBuilder
             .anyOf(RuntimeException.class)
             .delay(Delay.exponential(TimeUnit.MILLISECONDS, 100))
             .max(5)
             .build())
    .distinct()
    .subscribe(System.out::println);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="schedulers-and-threads"><a class="anchor" href="#schedulers-and-threads"></a>Schedulers and Threads</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Schedulers in RxJava are used to manage and control concurrency.
Some operators implicitly use one or allow you to pass in a custom one.</p>
</div>
<div class="paragraph">
<p>RxJava ships with a bunch of pre-configured Schedulers by default, which are all accessible through the Schedulers class:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code class="api">Schedulers.computation()</code>: Event-loop style scheduler for purely computational work.</p>
</li>
<li>
<p><code class="api">Schedulers.immediate()</code>: Executes the work immediately on the current thread.</p>
</li>
<li>
<p><code class="api">Schedulers.io()</code>: Executes work on an Executor-backed pool that grows as needed.</p>
</li>
<li>
<p><code class="api">Schedulers.newThread()</code>: Creates a new thread for each unit of work.</p>
</li>
<li>
<p><code class="api">Schedulers.trampoline()</code>: Queues the work on the current thread and gets executed after the current work completes.</p>
</li>
<li>
<p><code class="api">Schedulers.test()</code>: Test the <code>scheduler</code> used for testing and debugging, which allows manual advancing of the clock.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As a rule of thumb, the computation <code>scheduler</code> should always be used for in-memory processing, while the I/O scheduler should only be used for blocking-style I/O operations (so do not use it together with the Java SDK because it is asynchronous anyway).</p>
</div>
<div class="paragraph">
<p>You can instruct an <code>observable</code> to be executed on such a <code>scheduler</code> in the following ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Implicitly by using an operator that makes use of one</p>
</li>
<li>
<p>Explicitly by passing the Scheduler to such an operator</p>
</li>
<li>
<p>By using <code class="api">subscribeOn(Scheduler)</code></p>
</li>
<li>
<p>By using <code class="api">observeOn(Scheduler)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Operators like <code>buffer</code>, <code>replay</code>, <code>skip</code>, <code>delay</code>, <code>parallel</code> and so on use a <code>scheduler</code> by default if not instructed otherwise.
A list of default <code>schedulers</code> can be found <a href="https://github.com/ReactiveX/RxJava/wiki/Scheduler#default-schedulers-for-rxjava-observable-operators" target="_blank" rel="noopener">here</a>.</p>
</div>
<div class="paragraph">
<p>As a rule of thumb, all of those operators allow you to pass in a custom <code>scheduler</code> if needed, but most of the time sticking with the defaults is a good idea.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The Java SDK uses an <em class="term">internal scheduler</em> similar to the <em class="term">computation scheduler</em> to proper isolate the inner mechanisms from user-land.
It is possible to change that <code>scheduler</code> through the environment, but it is not recommended.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you want the whole subscribe chain to be executed on a specific <code>scheduler</code>, you use the <code class="api">subscribeOn()</code> operator.
Without a scheduler set, the following code executes on the main thread:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable
    .range(1, 5)
    .map(integer -&gt; {
        System.out.println("Map: (" + Thread.currentThread().getName() + ")");
        return integer + 2;
    })
    .subscribe(integer -&gt;
        System.out.println("Got: " + integer + " (" + Thread.currentThread().getName() + ")")
    );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example prints:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Map: (main)
Got: 3 (main)
Map: (main)
Got: 4 (main)
Map: (main)
Got: 5 (main)
Map: (main)
Got: 6 (main)
Map: (main)
Got: 7 (main)</pre>
</div>
</div>
<div class="paragraph">
<p>This example shows the <code class="api">subscribeOn()</code> method added to the flow (it doesn&#8217;t matter where you add it):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable
    .range(1, 5)
    .map(integer -&gt; {
        System.out.println("Map: (" + Thread.currentThread().getName() + ")");
        return integer + 2;
    })
    .subscribeOn(Schedulers.computation())
    .subscribe(integer -&gt;
            System.out.println("Got: " + integer + " (" + Thread.currentThread().getName() + ")")
    );</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the output of the example that uses <code class="api">subscribeOn()</code>, you can see it is executed on the same thread, but on the computation thread pool:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Map: (RxComputationThreadPool-6)
Got: 3 (RxComputationThreadPool-6)
Map: (RxComputationThreadPool-6)
Got: 4 (RxComputationThreadPool-6)
Map: (RxComputationThreadPool-6)
Got: 5 (RxComputationThreadPool-6)
Map: (RxComputationThreadPool-6)
Got: 6 (RxComputationThreadPool-6)
Map: (RxComputationThreadPool-6)
Got: 7 (RxComputationThreadPool-6)</pre>
</div>
</div>
<div class="paragraph">
<p>If you need tighter control regarding which parts are executed on what pool, use <code class="api">observeOn()</code>.
Here, the order matters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable
    .range(1, 5)
    .map(integer -&gt; {
        System.out.println("Map: (" + Thread.currentThread().getName() + ")");
        return integer + 2;
    })
    .observeOn(Schedulers.computation())
    .subscribe(integer -&gt;
            System.out.println("Got: " + integer + " (" + Thread.currentThread().getName() + ")")
    );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Everything before the <code class="api">observeOn()</code> call is executed in <code>main</code>, everything below in the scheduler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Map: (main)
Map: (main)
Map: (main)
Got: 3 (RxComputationThreadPool-6)
Got: 4 (RxComputationThreadPool-6)
Got: 5 (RxComputationThreadPool-6)
Map: (main)
Map: (main)
Got: 6 (RxComputationThreadPool-6)
Got: 7 (RxComputationThreadPool-6)</pre>
</div>
</div>
<div class="paragraph">
<p>There is also a way to use <code>schedulers</code> directly to schedule operations.
For more information about <code>schedulers</code>, refer to the RxJava documentation about <a href="https://github.com/ReactiveX/RxJava/wiki/Scheduler#default-schedulers-for-rxjava-observable-operators" target="_blank" rel="noopener">schedulers</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="topic_drb_nrp_f5"><a class="anchor" href="#topic_drb_nrp_f5"></a>Writing Resilient Reactive Applications</h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Many concepts can be applied for both synchronous and asynchronous access.
When necessary, both patterns are discussed separately.
The focus is on database interaction, but if you are using RxJava as part of your stack, you can and should apply most of the principles there as well.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="error-recovery"><a class="anchor" href="#error-recovery"></a>Error Recovery</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section discusses different strategies to mitigate errors that might come up during operations.
Some of them are shown to make a point, but the techniques apply to all different types of errors and can be applied as you see fit.</p>
</div>
<div class="paragraph">
<p><strong>Defaults</strong></p>
</div>
<div class="paragraph">
<p>Another possibility that requires intervention on the application side are <code>Observables</code> that do not emit a single value.
This can happen because operators filtered the <code>Observable</code> so that nothing is left, or they did not produce any values in the first place.
One common case in the Java SDK is <code class="api">get()</code>.
If the Document is not found, the <code>Observable</code> will complete without emitting anything.</p>
</div>
<div class="paragraph">
<p>RxJava provides helper operators that all end with <code class="api">*OrDefault()</code> and allow you to return default values if no item is emitted when the <code>Observable</code> completes.</p>
</div>
<div class="paragraph">
<p>In most cases, you want to use <code class="api">singleOrDefault()</code> and return a default value when not a single item is emitted by the source <code>Observable</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable
    .&lt;String&gt;empty()
    .singleOrDefault("Default")
    .subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are dealing with potentially more than one item emitted in your <code>Observable</code> and you only want to emit either the first or the last value, there are also operators that allow you to emit a default if it&#8217;s unexpectedly empty.
See <code class="api">firstOrDefault()</code> as well as <code class="api">lastOrDefault()</code> for more details.</p>
</div>
<div class="paragraph">
<p>Lastly, RxJava offers the method <code class="api">defaultIfEmtpy</code>, which allows you to return a value if the source doesn&#8217;t emit anything.
In recent versions, the method <code class="api">switchIfEmpty</code> allows you to switch to a different <code>Observable</code> in that same case.</p>
</div>
<div class="paragraph">
<p><strong>Error Handling in Bulk Scenarios</strong></p>
</div>
<div class="paragraph">
<p>Bulk operations are used to handle more data in one batch and, therefore, benefit from better resource utilization.
However,  error handling becomes more complicated.
There are three high-level cases to consider:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Best Effort</strong>: Keep going and just use the results that succeeded when errors happen.</p>
</li>
<li>
<p><strong>Full Retry</strong>: Retry the complete Observable when errors happen.</p>
</li>
<li>
<p><strong>Incremental Retry</strong>: Only retry specific events of the Observable.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Before we "dig" into the specific approaches, let&#8217;s revisit the contract of Observables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">onNext* (onError | onComplete)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Zero or more events are followed by either an error event or a complete event.
This provides an important clue right away: once our <code>Observable</code> fails, no more events can be passed through.
Therefore, you need to make sure that errors are handled at the smallest scope possible, only letting it proceed if you cannot handle it right away.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Best Effort Bulk Handling</dt>
<dd>
<p>Sometimes it is more important to get data in a timeframe, or maybe with a short timeout, then getting all data.
In general, you want to keep a timeout that lets you fetch all the data, but depending on the use case you are fine with only getting a subset of the data returned.</p>
<div class="paragraph">
<p>To ignore errors and turn them into "noops", you can utilize <code class="api">onErrorResumeNext()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable
      .create(new Observable.OnSubscribe&lt;String&gt;() {
           @Override
           public void call(Subscriber&lt;? super String&gt; subscriber) {
               subscriber.onNext("A");
               subscriber.onNext("B");
               subscriber.onError(new IllegalStateException("Woops"));
               subscriber.onNext("C");
            }
        })
    .onErrorResumeNext(Observable.&lt;String&gt;empty())
    .toBlocking()
    .forEach(new Action1&lt;String&gt;() {
        @Override
        public void call(String s) {
            System.out.println("Got: " + s);
        }
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will not raise any exception to your calling thread, but it will never process "C" because, based on the <code>Observable</code> contract, once <code class="api">onError</code> is called no more events are allowed to be generated.</p>
</div>
<div class="paragraph">
<p>To keep going in case an event fails, you need to turn each event into a single <code>Observable</code> and then merge it back together to either defer the error handling (through <code class="api">Observable#mergeDelayError</code>) or use <code class="api">flatMap</code> and make sure to contain the errors before flattening.</p>
</div>
<div class="paragraph">
<p>This code provides some fake data with which you can work.
It will emit four <code>Observables</code> where one of them will fail:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable&lt;Observable&lt;String&gt;&gt; dataObservables = Observable
    .just("a", "b", "c", "d")
    .map(new Func1&lt;String, Observable&lt;String&gt;&gt;() {
        @Override
        public Observable&lt;String&gt; call(String s) {
            if (s.equals("b")) {
                return Observable.error(new IllegalStateException("I dont like b"));
            }
            return Observable.just(s);
        }
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then use <code class="api">mergeDelayError</code> to defer error handling until the end.
If you un-comment the <code class="api">onErrorResumeNext</code>, it will silently discard any errors as well leaving you with an <code>Observable</code> that provides best-effort processing of the source <code>Observables</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable.mergeDelayError(dataObservables)
    //.onErrorResumeNext(Observable.&lt;String&gt;empty())
    .toBlocking()
    .forEach(new Action1&lt;String&gt;() {
        @Override
        public void call(String s) {
            System.out.println(s);
        }
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can use <code class="api">flatMap</code> and make sure the errors are contained for each emitted <code>Observable</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable
    .just("a", "b", "c", "d")
    .flatMap(new Func1&lt;String, Observable&lt;String&gt;&gt;() {
        @Override
        public Observable&lt;String&gt; call(String s) {
            // Simulate some observable that sometimes fails
            Observable&lt;String&gt; obs;
            if (s.equals("b")) {
                obs = Observable.error(new IllegalStateException("I dont like b"));
            } else {
                obs = Observable.just(s);
            }

            // Here comes the actual handling part before we flatten it back
            return obs.onErrorResumeNext(Observable.&lt;String&gt;empty());
        }
    })
    .toBlocking()
    .forEach(new Action1&lt;String&gt;() {
        @Override
        public void call(String s) {
            System.out.println(s);
        }
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>As a more practical example here is a best effort bulk loading of documents from Couchbase Server that just discards operations that fail:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"> private static Observable&lt;JsonDocument&gt; loadDocsBestEffort(Bucket bucket, List&lt;String&gt; ids) {
    return Observable
        .from(ids)
        .flatMap(new Func1&lt;String, Observable&lt;JsonDocument&gt;&gt;() {
            @Override
            public Observable&lt;JsonDocument&gt; call(String id) {
                return bucket
                .async()
                .get(id)
                .onErrorResumeNext(Observable.&lt;JsonDocument&gt;empty());
            }
        });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, you can add more logic onto each emitted <code>Observable</code> and also proper logging so that you at least know which errors occurred.</p>
</div>
</dd>
<dt class="hdlist1">Full Retry Bulk Handling</dt>
<dd>
<p>Full retry bulk handling can be done by just chaining one of the retry operators right at the end of the <code>Observable</code> chain.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This example uses Java 8 Lambda syntax for conciseness.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"> private static Observable&lt;JsonDocument&gt; loadDocsFullRetry(Bucket bucket, List&lt;String&gt; ids) {
    return Observable
        .from(ids)
        .flatMap(id -&gt; return bucket.async().get(id))
        .retry(4);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is, however, a bit crude because the whole list of IDs will be retried if there is an error.
This is the case even if the error happens late in the stream and some items have already been emitted.
Imagine that you retrieve items <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and that an error occurs just the first time the SDK retrieves C.
What you will see is <code>A</code>, <code>B</code>, <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>.</p>
</div>
<div class="paragraph">
<p>This can be mitigated by using the <code class="api">distinct()</code> operator, but keep in mind the memory tradeoff (distinct will maintain a set of values it saw in the background, which can be problematic for infinite or very large streams).</p>
</div>
</dd>
<dt class="hdlist1">Incremental Retry Bulk Handling</dt>
<dd>
<p>Incremental retry improves on full retry by only actually retrying elements that couldn&#8217;t be loaded.
It is easily done by chaining the retry operators inside the <code class="api">flatMap</code> instead of outside of it.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"> private static Observable&lt;JsonDocument&gt; loadDocsIncrementalRetry(Bucket bucket, List&lt;String&gt; ids) {
    return Observable
        .from(ids)
        .flatMap(id -&gt; return bucket.async().get(id)
            .retry(4)
        );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>One thing to keep in mind with <code class="api">flatMap</code> is that the order of emissions isn&#8217;t guaranteed to be the same as the source emissions.
This can be especially visible in this case since individual streams are retried on their own: retried keys could come back with a value much later than other keys, more often changing the order in which they appear.</p>
</div>
</dd>
<dt class="hdlist1">Bulk Pattern, <code class="api">BackpressureException</code> and Reactive Pull Backpressure</dt>
<dd>
<p>The bulk pattern is powerful, but if you try it with a very large collection, it is especially susceptible to a <code class="api">BackpressureException</code>.
This exception is a way for the SDK to tell you that you&#8217;re asking for too much in a short amount of time, and requests have piled up too much while waiting for a server response to free up a spot.</p>
<div class="paragraph">
<p>By default, the internal structure that holds pending requests is sized to a little over 16 000 slots.
Since <code class="api">from</code> iterates over a collection in memory, which is <em>very</em> fast, it can easily flood the SDK if the size of it is over or close to 16K.</p>
</div>
<div class="paragraph">
<p>You could try to react to that by implementing a retry strategy, but it is hard to get it right.
Fortunately, RxJava comes with an even better solution, a form of flow-control called <em class="term">reactive pull backpressure</em> that you can leverage to avoid getting a <code class="api">BackpressureException</code>.</p>
</div>
<div class="paragraph">
<p>This is done through the Subscriber, its <code class="api">onStart()</code> method and the <code class="api">request(n)</code> method.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You have to use the Subscriber to <code class="api">subscribe()</code> instead of the convenience methods that just take <code class="api">Action</code> individually for <code class="api">next</code>, <code class="api">error</code> and <code class="api">completed</code> handlers.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Observable&lt;JsonDocument&gt; largeBulk = Observable
    .from(oneMillionIds)
    .flatMap(id -&gt; return bucket.async().get(id));

//the subscription is where reactive pull backpressure happens
largeBulk.subscribe(new Subscriber&lt;JsonDocument&gt;() {

    //onStart initiates the backpressure
    @Override
    public void onStart() {
        request(100);
    }

    @Override
    public void onNext(JsonDocument jsonDocument) {
        System.out.println(jsonDocument.content());
        request(100); //request more items
    }

    //onCompleted and onError are less relevant.
    //Note that if you want to block you'd need a CountDownLatch in this case

    @Override public void onCompleted() { System.out.println("Done"); }

    @Override public void onError(Throwable e) { e.printStackTrace(); }

});</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code class="api">request(n)</code> method allows to notify the upstream source that the consumer is ready for more, and is prepared to consume <code>n</code> items.
For example, this avoids instant iteration of the collection in the case of <code class="api">from</code>.
And as long as responses come in from Couchbase Server, we continue asking for more.</p>
</div>
<div class="paragraph">
<p>This is a form of <em class="term">error mitigation</em>, and we&#8217;ll see a few others in the next section.</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="error-mitigation"><a class="anchor" href="#error-mitigation"></a>Error Mitigation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The idea behind <em class="term">error mitigation</em> is to limit the impact a failing piece had on the rest of the system.
When an error occurs, you don&#8217;t want it to cause failures downstream.
You also want to prevent as much of the error conditions to happen as possible.</p>
</div>
<div class="paragraph">
<p>The <code class="api">BackpressureException</code> and RxJava&#8217;s <em class="term">reactive pull backpressure</em> are forms of error mitigation we already saw since they both allow a form of flow control that avoids overloading the system.</p>
</div>
<div class="paragraph">
<p><strong>Slowing Down</strong></p>
</div>
<div class="paragraph">
<p>Rate limiting of the requests can be a way to keep the system within parameters that are known to be stable, thus mitigating overloading errors.
This can happen in the client-to-server direction, which avoids making more requests than can be processed later.
It can also happen in the server-to-client direction, when the client can&#8217;t keep up with the bandwidth at which data is sent from the server because, for instance, it has to process it through long-running tasks.
Rather than choking on that data when backpressure mechanisms are not available, the client can decide to discard some of the data.
This is referred to as <em class="term">Load Shedding</em>.</p>
</div>
<div class="paragraph">
<p>For example, consider a system where multiple sensors write data into Couchbase, and the client application reads that data and displays it in a UI.
The graphs in the UI can be built on a <code>sample</code> of the data, and that&#8217;s the key point.
The processing rate of the data is lower than its producing rate, but at the same time the resolution is also lower.
That means we can simply ignore some of the data and only consume what&#8217;s needed, such as take the data point at every second to trigger a refresh of the graph in the UI.</p>
</div>
<div class="paragraph">
<p>RxJava allows you to do that through several operators:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code class="api">sample</code> (alternatively <code class="api">throttleLast</code>) periodically looks at an Observable and emits the item last seen during this period.</p>
</li>
<li>
<p><code class="api">throttleFirst</code> does the same except it emits the <code>first</code> item seen during the period.</p>
</li>
<li>
<p><code class="api">debounce</code> only emits an item if a given timespan has passed since the last emission, eliminating items that are rapidly following another item.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The operator <code class="api">sample</code> is useful for sources that are "too chatty" even at a regular rate.
The operator <code class="api">debounce</code>, on the other hand, is really shining with sources that have a variable rate of emission.
The sources only trigger a web search for auto-complete suggestions from an input form once the user has stopped typing for 500ms.</p>
</div>
<div class="paragraph">
<p><strong>Semaphore</strong></p>
</div>
<div class="paragraph">
<p>To limit the strain put on dependencies of your application, one possibility is to put hard limits on how many concurrent threads can access a resource.
This is done with the classic concurrency programming pattern of the <code class="api">Semaphore</code>, which is implemented in <code class="api">java.util.concurrent</code> since Java 7.</p>
</div>
<div class="paragraph">
<p>Note that Semaphores are a bit different from locks since they don&#8217;t have a notion of ownership.
For example, two different threads can respectively <code class="api">acquire()</code> and <code class="api">release()</code> a <code class="api">Semaphore</code> permit), which can avoid things like deadlocks.</p>
</div>
<div class="paragraph">
<p>The same concept could also be implemented using a fixed-size thread pool.
Such thread pool adds overhead but allows upstream code to just "walk away" from the call if it takes too long for a slot to become available, providing an even better isolation.</p>
</div>
<div class="paragraph">
<p><strong>Collapsing Requests</strong></p>
</div>
<div class="paragraph">
<p>Another way of mitigating errors is to batch similar requests together and "collapse" them into one request to the subsystem.
If you have multiple threads that potentially ask for the same data, the benefit can be immediate by just putting a facade on your calls that will de-duplicate parallel requests.</p>
</div>
<div class="paragraph">
<p>You can go beyond and trade a little bit of latency to allow for more potential de-duplication.
Wait a little longer to see if any duplicate request comes in before firing the actual de-duplicated request.</p>
</div>
<div class="paragraph">
<p><strong>Implementation</strong></p>
</div>
<div class="paragraph">
<p>All the mentioned techniques can be easily implemented in an application in a RxJava-compatible way by using another library from Netflix, <a href="https://github.com/Netflix/Hystrix/wiki" target="_blank" rel="noopener">Hystrix</a>.
It is a very comprehensive library for building resilient applications, including techniques for error mitigation but also failing fast.
Here, the circuit-breaker pattern short-circuits calls to a service that is known to be down until we detect it is back up, which stops cascading failures, provides fallbacks and gathers metrics.</p>
</div>
</div>
</div>
</article>
</main>
</div>
<footer class="footer">
  <div class="container">
    <div class="footer-links">
      <div class="col">
        <div class="footer-logo">
          <a href="https://www.couchbase.com" class="icon">
            <img src="../../_/img/logo.svg" alt="Couchbase">
          </a>
        </div>
        <div class="contact">
          <p class="address">3250 Olcott Street
Santa Clara, CA 95054
United States</p>
          <a href="https://www.couchbase.com/contact" class="btn white-btn">Contact Us</a>
          <a class="tel" href="tel:1-650-417-7500">1-650-417-7500</a>
        </div>
      </div>
      <div class="col">
        <ul>
          <li><span class="heading">Company</span></li>
          <li><a href="https://www.couchbase.com/about">About</a></li>
          <li><a href="https://www.couchbase.com/leadership">Leadership</a></li>
          <li><a href="https://www.couchbase.com/news-and-press-releases">News &amp; Press</a></li>
          <li><a href="https://www.couchbase.com/careers">Careers</a></li>
          <li><a href="https://www.couchbase.com/resources/events">Events</a></li>
          <li><a href="https://www.couchbase.com/contact">Contact Us</a></li>
          <li><a href="https://www.couchbase.com/request-pricing">Pricing</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><span class="heading">Support</span></li>
          <li><a href="https://developer.couchbase.com" target="_blank" rel="noopener">Developer Portal</a></li>
          <li><a href="https://docs.couchbase.com" target="_blank" rel="noopener">Documentation</a></li>
          <li><a href="https://forums.couchbase.com" target="_blank" rel="noopener">Forums</a></li>
          <li><a href="https://www.couchbase.com/services">Professional Services</a></li>
          <li><a href="https://support.couchbase.com" target="_blank" rel="noopener">Support Login</a></li>
          <li><a href="https://learn.couchbase.com/store" target="_blank" rel="noopener">Training</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><span class="heading">Quicklinks</span></li>
          <li><a href="https://blog.couchbase.com" target="_blank" rel="noopener">Blog</a></li>
          <li><a href="https://www.couchbase.com/downloads">Downloads</a></li>
          <li><a href="https://www.couchbase.com/get-started-developing-nosql">Get Started</a></li>
          <li><a href="https://learn.couchbase.com/store?utf8=%E2%9C%93&ss=1&ct=78327&commit=Filter" target="_blank" rel="noopener">Online Training</a></li>
          <li><a href="https://www.couchbase.com/resources">Resources</a></li>
          <li><a href="https://www.couchbase.com/nosql-resources/why-nosql">Why NoSQL</a></li>
          <li><a href="https://www.couchbase.com/resources/security">Security</a></li>
          <li><a href="https://www.couchbase.com/resources/gdpr">GDPR</a></li>
        </ul>
      </div>
      <div class="col">
        <ul class="social-icons">
          <li>
            <a href="https://www.facebook.com/Couchbase" class="icon">
              <svg width="50px" height="50px" viewBox="26.363 116.363 560.215 560.215"><path d="m586.58 209.58c0-48.96-44.252-93.212-93.212-93.212h-373.79c-48.96 0-93.212 44.252-93.212 93.212v373.79c0 48.96 44.252 93.212 93.212 93.212h186.42v-211.85h-68.732v-93.212h68.732v-36.72c0-63.083 47.077-119.58 105.45-119.58h75.323v93.212h-75.323c-8.474 0-17.889 10.357-17.889 25.422v37.662h93.212v93.212h-93.212v211.85h99.803c48.96 0 93.212-44.252 93.212-93.212v-373.79z"/></svg>
            </a>
          </li>
          <li>
            <a href="https://twitter.com/couchbase" class="icon">
              <svg width="50px" height="50px" viewBox="32.012 176.622 542.326 437.815"><path d="m574.34 227.46c-19.772 8.474-41.428 15.065-64.025 17.889 22.597-14.123 40.486-35.778 48.96-61.2-21.655 13.182-45.194 21.655-70.615 27.305-20.714-21.655-48.96-34.837-80.972-34.837-61.2 0-111.1 49.902-111.1 111.1 0 8.474 0.942 16.948 2.825 25.422-92.271-5.649-174.18-49.902-229.74-117.69-9.415 16.006-15.065 35.778-15.065 55.551 0 38.603 19.772 72.498 49.902 92.271-17.889-0.942-35.778-5.649-50.843-14.123v0.942c0 53.668 38.603 98.862 89.446 109.22-9.415 2.825-18.831 3.766-29.188 3.766-7.532 0-14.123-0.942-20.714-1.883 14.123 44.252 55.551 76.265 103.57 77.206-37.662 30.129-85.68 48.018-138.41 48.018-9.415 0-17.889-0.941-26.363-1.883 48.96 32.012 107.34 49.902 170.42 49.902 204.31 0 316.36-169.48 316.36-316.36v-14.123c21.656-14.125 40.487-33.897 55.551-56.494z"/></svg>
            </a>
          </li>
          <li>
            <a href="https://www.linkedin.com/company/couchbase" class="icon">
              <svg width="50px" height="50px" viewBox="31.071 119.188 539.537 540.443"><path d="m531.97 119.19h-461.35c-21.655 0-39.545 16.948-39.545 38.603v463.24c0 21.655 17.889 38.603 39.545 38.603h460.41c21.655 0 39.545-16.948 39.545-38.603v-463.24c0.942-21.656-16.947-38.603-38.603-38.603zm-337.07 451.94h-81.914v-243.86h81.914v243.86zm-40.486-276.81c-28.246 0-46.135-18.831-46.135-42.369s17.889-42.369 46.135-42.369 45.194 17.889 45.194 42.369c0.942 23.538-16.948 42.369-45.194 42.369zm335.19 276.81h-81.914v-129.93c0-32.954-12.24-55.551-41.428-55.551-22.597 0-35.778 15.065-41.428 30.129-1.883 5.649-2.825 12.24-2.825 19.772v136.52h-81.914s0.942-221.26 0-243.86h81.914v34.837c11.298-16.948 30.129-40.486 73.44-40.486 53.668 0 94.154 34.837 94.154 110.16l1e-3 138.41zm-168.54-208.08s0.941-0.941 0 0z"/></svg>
            </a>
          </li>
          <li>
            <a href="https://plus.google.com/+CouchbaseServer" class="icon">
              <svg width="50px" height="50px" viewBox="36.72 225.573 542.326 343.67"><path d="m209.02 363.05v68.732h93.212c-15.065 44.252-37.662 68.732-93.212 68.732-56.492 0-100.74-46.135-100.74-102.63s44.252-102.63 100.74-102.63c30.129 0 48.96 10.357 66.849 25.422 14.123-14.123 13.182-16.006 48.96-49.902-31.071-28.246-71.557-45.194-115.81-45.194-95.096-0.94-172.3 76.266-172.3 171.36s77.206 172.3 172.3 172.3c142.17 0 177.01-124.28 165.71-206.2-33.896-1e-3 -165.71-1e-3 -165.71-1e-3zm310.71 3.766v-59.317h-42.369v59.317h-61.2v42.369h61.2v61.2h42.369v-61.2h59.317v-42.369h-59.317z"/></svg>
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="footer-terms">
      <span>2018 COUCHBASE All rights reserved.</span>
      <a href="https://www.couchbase.com/privacy-policy">Privacy Policy</a>
      <a href="https://www.couchbase.com/terms-of-use">Terms of Use</a>
      <a href="https://www.couchbase.com/cookie-policy">Cookie Policy</a>
      <a href="https://info.couchbase.com/unsubscribe-or-manage-preferences.html" target="_blank" rel="noopener">Marketing Preference Center</a>
    </div>
  </div>
</footer>
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
