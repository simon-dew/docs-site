<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>Swift | Couchbase Docs (Staging)</title>
    <link rel="canonical" href="https://simon-dew.github.io/docs-site/DOC-4504/couchbase-lite/2.5/swift.html">
    <link rel="stylesheet" href="../../_/css/site.css">
    <link rel="schema.dcterms" href="https://purl.org/dc/terms/">
    <meta name="dcterms.subject" content="couchbase-lite">
    <meta name="dcterms.identifier" content="1.3">
    <meta name="generator" content="Antora 1.1.1">
    <link rel="icon" href="../../_/img/favicon.ico" type="image/x-icon">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar" id="topbar">
    <div class="container">
      <div class="navbar-brand">
        <a class="navbar-item" href="https://www.couchbase.com"><img src="../../_/img/logo.svg" alt="Couchbase"></a>
        <button class="navbar-burger" data-target="topbar-menu">
          <span></span>
          <span></span>
          <span></span>
        </button>
      </div>
      <div id="topbar-menu" class="navbar-menu">
        <div class="navbar-start">
          <div class="navbar-item has-dropdown">
            <a class="navbar-link" href="https://simon-dew.github.io/docs-site/DOC-4504">Docs</a>
            <div class="navbar-dropdown explore">
              <div class="title">Couchbase Documentation Overview</div>
              <div class="cols">
                <ul>
                  <li class="heading"><a href="../../server/6.0/introduction/intro.html">Server</a></li>
                  <li><a href="../../server/6.0/n1ql/n1ql-language-reference/index.html">N1QL</a></li>
                  <li><a href="../../server/6.0/fts/full-text-intro.html">Full Text Search</a></li>
                  <li><a href="../../server/6.0/analytics/introduction.html">Analytics</a></li>
                  <li><a href="../../server/6.0/eventing/eventing-overview.html">Eventing</a></li>
                  <li><a href="../../operator/1.2/overview.html">Autonomous Operator</a></li>
                </ul>
                <ul>
                  <li class="heading">Mobile</li>
                  <li><a href="../2.5/index.html">Lite</a></li>
                  <li><a href="../../sync-gateway/2.5/index.html">Sync Gateway</a></li>
                </ul>
                <ul class="two-cols">
                  <li class="heading"><a href="../../server/6.0/sdk/overview.html">SDKs</a></li>
                  <li><a href="../../c-sdk/2.10/start-using-sdk.html">C</a></li>
                  <li><a href="../../dotnet-sdk/2.7/start-using-sdk.html">.NET</a></li>
                  <li><a href="../../go-sdk/1.5/start-using-sdk.html">Go</a></li>
                  <li><a href="../../java-sdk/2.7/start-using-sdk.html">Java</a></li>
                  <li><a href="../../nodejs-sdk/2.6/start-using-sdk.html">Node.js</a></li>
                  <li><a href="../../php-sdk/2.6/start-using-sdk.html">PHP</a></li>
                  <li><a href="../../python-sdk/2.5/start-using-sdk.html">Python</a></li>
                </ul>
                <ul>
                  <li class="heading"><a href="../../server/6.0/connectors/intro.html">Connectors</a></li>
                  <li><a href="../../elasticsearch-connector/4.0/index.html">Elasticsearch</a></li>
                  <li><a href="../../server/6.0/connectors/hadoop-1.2/hadoop.html">Hadoop</a></li>
                  <li><a href="../../kafka-connector/3.4/index.html">Kafka</a></li>
                  <li><a href="../../spark-connector/2.2/index.html">Spark</a></li>
                  <li><a href="../../talend-connector/index.html">Talend</a></li>
                  <li><a href="../../server/6.0/connectors/odbc-jdbc-drivers.html">ODBC/JDBC</a></li>
                </ul>
              </div>
            </div>
          </div>
          <div class="navbar-item has-dropdown">
            <a class="navbar-link component" href="index.html"><span class="title">Couchbase Lite</span> <span class="version">1.3</span></a>
            <div class="navbar-dropdown versions">
              <div class="cols">
                <ul>
                  <li><a class="navbar-item" href="../2.5/swift.html">Couchbase Lite 2.5</a></li>
                  <li><a class="navbar-item" href="../2.1/swift.html">Couchbase Lite 2.1</a></li>
                  <li><a class="navbar-item" href="../2.0/swift.html">Couchbase Lite 2.0</a></li>
                  <li><a class="navbar-item" href="../1.4/swift.html">Couchbase Lite 1.4</a></li>
                </ul>
              </div>
            </div>
          </div>
        </div>
        <div class="navbar-end">
          <div class="navbar-item">
            <a class="btn red-btn" href="https://www.couchbase.com/downloads">Downloads</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body container">
<nav class="nav">
<div class="nav-menu">
<ul class="nav-list">
  <li class="nav-item is-current-path is-active" data-depth="0">
    <span class="nav-line">
    <button class="nav-toggle"></button>
    <span class="nav-text">Couchbase Lite</span>
    </span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="index.html">What&#8217;s New</a>
    </span>
  </li>
  <li class="nav-item is-current-page is-active" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="swift.html">Swift</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="java.html">Java</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="csharp.html">C#</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="objc.html">Objective-C</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="rest-api.html">REST API</a>
    </span>
  </li>
</ul>
  </li>
</ul>
</div>
</nav>
<aside class="toc sidebar">
  <div class="toc-menu"></div>
</aside>
<main class="article" data-ceiling="topbar">
  <div class="article-banner">
    <p>A newer version of this documentation is available.</p>
    <a class="btn" href="../2.5/swift.html">View Latest</a>
  </div>
  <div class="article-header">
<button class="nav-control"></button>
<nav class="crumbs" aria-label="breadcrumbs">
  <ul>
    <li class="crumb">Couchbase Lite</li>
    <li class="crumb"><a href="swift.html">Swift</a></li>
  </ul>
</nav>
<div class="tools" role="navigation">
  <ul>
    <li class="tool edit"><a href="https://github.com/couchbaselabs/docs-couchbase-lite/edit/release/1.3/modules/ROOT/pages/swift.adoc" title="Edit Page" target="_blank" rel="noopener">Edit</a></li>
  </ul>
</div>
  </div>
<article class="doc">
<h1 class="page">Swift</h1>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a>Getting Started</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="installation"><a class="anchor" href="#installation"></a>Installation</h3>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset1_frameworks"></a>Frameworks</p>
</li>
<li>
<p><a id="tabset1_cocoapods"></a>Cocoapods</p>
</li>
<li>
<p><a id="tabset1_carthage"></a>Carthage</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset1_frameworks">
<div class="paragraph">
<p><strong>iOS &amp; tvOS</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="http://www.couchbase.com/nosql-databases/downloads#couchbase-mobile">Download Couchbase Lite</a> for the platform your app is targeting.</p>
</li>
<li>
<p>Unzip the file.</p>
</li>
<li>
<p>Open the Couchbase Lite folder and drag <strong>CouchbaseLite.framework</strong> to the project navigator in Xcode.</p>
</li>
<li>
<p>In the <strong>Choose options for adding these files</strong> sheet, make sure that your app target is selected.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Couchbase Lite requires additional frameworks and libraries for building an app.
These additional dependencies are added via Xcode build settings.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>In the Xcode navigator, click on the project open the <strong>Build Settings</strong> tab.</p>
</li>
<li>
<p>Scroll to the <strong>Linking</strong> section, find the <strong>Other Linker Flags</strong> row and then add the flag <strong>-ObjC</strong> (be sure to use the capitalization shown).</p>
</li>
<li>
<p>Click the <strong>Build Phases</strong> tab.</p>
</li>
<li>
<p>Expand the <strong>Link Binary With Libraries</strong> section and add the following items.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">CFNetwork.framework
Security.framework
SystemConfiguration.framework
libsqlite3.dylib
libz.dylib
libc++.dylib</code></pre>
</div>
</div>
<div class="paragraph">
<p>To use the SDK in Swift files, you must also import the framework in a bridging header (<code>#import &lt;CouchbaseLite/CouchbaseLite.h&gt;</code>).</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>macOS</strong></p>
</div>
<div class="paragraph">
<p>For a macOS target, you&#8217;ll need to make sure the framework is copied to your app&#8217;s bundle.
Follow the steps below.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="http://www.couchbase.com/nosql-databases/downloads#couchbase-mobile">Download Couchbase Lite</a> for the platform your app is targeting.</p>
</li>
<li>
<p>Open the <strong>Build Settings</strong> tab of your app target&#8217;s settings.</p>
</li>
<li>
<p>In the <strong>Linking</strong> section, edit <strong>Runpath Search Paths</strong> and add <code>@loader_path/../Frameworks/</code>.</p>
</li>
<li>
<p>Now switch to the <strong>Build Phases</strong>.</p>
</li>
<li>
<p>Press the <strong>Add Build Phase</strong> button at the top of the window and create a new <strong>Copy Files</strong> phase.</p>
<div class="imageblock">
<div class="content">
<img src="_images/ios-copy-files-phase.png" alt="ios copy files phase">
</div>
</div>
</li>
<li>
<p>Set the phase&#8217;s destination to <strong>Frameworks</strong>.</p>
</li>
<li>
<p>Press the <strong>+</strong> button below the phases' file list and select <strong>CouchbaseLite.framework</strong> to add it.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Available frameworks</strong></p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Framework</th>
<th class="tableblock halign-left valign-top">Service</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CouchbaseLiteListener.framework</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">To access the database through HTTP (often used for hybrid development and peer-to-peer sync).
This component has a dependency on <code>JavaScriptCore.framework</code>, make sure to add this framework as well if you&#8217;re planning on using it.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CBLJSONValidator</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Validates JSON objects against JSON-Schema specs.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CBLRegisterJSViewCompiler</code>, <code>libCBLJSViewCompiler.a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">To register Views and Filters through the Listener.
When doing so, the logic is written in JavaScript and stored in the database.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>libCBLForestDBStorage.a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">To use ForestDB as the storage type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>libsqlcipher.a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">To enable encryption on SQLite databases.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Extras/CBLEncryptionController</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Utility class to handle password entry.
Prompts the user to make up a key, asks for the key when re-opening the database, and asks again if the key was incorrect
It even takes advantage of Touch ID fingerprint authentication on recent iOS devices to avoid making the user deal with a password at all.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Extras/CBLIncrementalStore</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A subclass of the NSIncrementalStore to allow Core Data to use a Couchbase Lite database as its persistent storage instead of the default SQLite database.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Extras/CBLUICollectionSource</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A UICollectionView data source driven by a CBLLiveQuery.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tab-pane" aria-labelledby="tabset1_cocoapods">
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://guides.cocoapods.org/using/getting-started.html">Install Cocoapods</a></p>
</li>
<li>
<p>In your <code>Podfile</code>, add the following.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ruby hljs" data-lang="ruby">pod 'couchbase-lite-ios', '~&gt; 1.3.1'</code></pre>
</div>
</div>
</li>
<li>
<p>Install the pods and open the .xcworkspace file generated by Cocoapods.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ruby hljs" data-lang="ruby">pod install</code></pre>
</div>
</div>
<div class="paragraph">
<p>To use the SDK in Swift files, you must also import the framework in a bridging header (<code>#import &lt;CouchbaseLite/CouchbaseLite.h&gt;</code>).</p>
</div>
<div class="paragraph">
<p>The following subspecs are available to import different Couchbase Lite components.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Pod</th>
<th class="tableblock halign-left valign-top">Service</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>couchbase-lite-ios/SQLite</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">To use SQLite as the storage type.
This is the default.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>couchbase-lite-ios/SQLCipher</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">To use SQLCipher as the storage type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>couchbase-lite-ios/ForestDB</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">To use ForestDB as the storage type.</p></td>
</tr>
</tbody>
</table>
</li>
</ol>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset1_carthage">
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://github.com/Carthage/Carthage#installing-carthage">Install Carthage</a></p>
</li>
<li>
<p>Add <code>github "couchbase/couchbase-lite-ios" "release/1.3.1"</code> to your <strong>Cartfile</strong>.</p>
</li>
<li>
<p>Run <code>carthage update --platform ios</code>.</p>
</li>
<li>
<p>Drag <strong>CouchbaseLite.framework</strong> from the appropriate platform directory in <strong>Carthage/Build/</strong> to the <strong>Embedded Binaries</strong> section of your Xcode project&#8217;s <strong>General</strong> settings.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="starter-code"><a class="anchor" href="#starter-code"></a>Starter Code</h3>
<div class="paragraph">
<p>Create a new Xcode project and install Couchbase Lite by following one of the methods above.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/xcode-installation.png" alt="xcode installation">
</div>
</div>
<div class="paragraph">
<p>Open <strong>ViewController.swift</strong> in Xcode.</p>
</div>
<div class="paragraph">
<p>If you installed Couchbase Lite with Carthage, append the following in your import section.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">import CouchbaseLite</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, add the following in the <code>viewDidLoad</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// Create a manager
let manager = CBLManager.sharedInstance()

let database: CBLDatabase
do {
 // Create or open the database named app
 database = try manager.databaseNamed(app)
} catch {
 print(Database creation or opening failed)
 return
}

// The properties that will be saved on the document
let properties = [title: Couchbase Mobile, sdk: iOS]
// Create a new document
let document: CBLDocument = database.createDocument()

do {
 // Save the document to the database
 try document.putProperties(properties)
} catch {
 print(Can't save document in database)
 return
}

// Log the document ID (generated by the database)
// and properties
print(Document ID :: \(document.documentID))
print(Learning \(document.property(forKey: sdk)!))

// Create replicators to push  pull changes to  from Sync Gateway
let url = URL(string: http://localhost:4984/hello)!
let push = database.createPushReplication(url)
let pull = database.createPullReplication(url)
push.continuous = true
pull.continuous = true

// Start replicators
push.start()
pull.start()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Build and run.
You should see the document ID and property printed to the console.
The document was successfully persisted to the database.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/xcode-running.png" alt="xcode running">
</div>
</div>
<div class="paragraph">
<p>Before synchronizing documents to Sync Gateway you will need to disable App Transport Security.
In the Xcode navigator, right-click on <strong>Info.plist</strong> and open it as a source file.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/info-plist.png" alt="info plist">
</div>
</div>
<div class="paragraph">
<p>Append the following inside of the <code>dict</code> XML tags to disable ATS.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">keyNSAppTransportSecurity/key
dict
keyNSAllowsArbitraryLoads/keytrue/
/dict</code></pre>
</div>
</div>
<div class="paragraph">
<p>The application is now correctly configured to start synchronizing documents with Sync Gateway.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="manager"><a class="anchor" href="#manager"></a>Manager</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A <code>Manager</code> is the top-level object that manages a collection of Couchbase Lite <code>Database</code> instances.
You need to create a <code>Manager</code> instance before you can work with Couchbase Lite objects in your Application.</p>
</div>
<div class="sect2">
<h3 id="creating-a-manager"><a class="anchor" href="#creating-a-manager"></a>Creating a manager</h3>
<div class="paragraph">
<p>You create a Manager object by calling a constructor or initializer on the Manager class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let manager = CBLManager.sharedInstance()
if manager == nil {
    NSLog("Cannot create Manager Instance")
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dude-where-s-my-database-file"><a class="anchor" href="#dude-where-s-my-database-file"></a>Dude, where&#8217;s my database file?</h3>
<div class="paragraph">
<p>The Manager creates a directory in the filesystem and stores databases inside it.
Normally, you don&#8217;t need to care where that is&#8201;&#8212;&#8201;your application shouldn&#8217;t be directly accessing those files.
But sometimes it does matter.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Android: The directory is the location returned by the Android Context object&#8217;s <code>getFilesDir()</code>.</p>
</li>
<li>
<p>iOS: <code>Application Support/CouchbaseLite/</code></p>
</li>
<li>
<p>macOS: <code>~/Library/Application Support/com.example.YourAppBundleID/CouchbaseLite/</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
One notable case where the location can be important is on iOS: Apple&#8217;s app review process tries to make sure that the only application data that will be backed up to iCloud is data created by the user.
So it&#8217;s a red flag when, on first launch, an app creates data in backed-up locations (including the Documents and Application Support directories) without user action.
Unfortunately, that will happen if your app starts a pull replication on launch, or installs a pre-populated database.
Some apps using Couchbase Lite have had their App Store approval held up for this reason!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>On iOS or Mac OS you can change the location of the databases by instantiating the Manager via a constructor/initializer that takes a path as a parameter.
This directory will be created if it doesn&#8217;t already exist.
(Of course you should be consistent about what path to use, since if you change the path the application won&#8217;t be able to find any already-existing databases.)</p>
</div>
<div class="paragraph">
<p>On Android, you can subclass <code>com.couchbase.lite.android.AndroidContext</code> and override its <code>getFilesDir</code> method to return the desired directory.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let dir = WhereIWantCBLStuffToGo()
var error: NSError?
self.manager = CBLManager(directory: dir, options: nil, error: &amp;error)
if manager == nil {
    NSLog("Cannot create Manager instance: %@", (error ?? ""))
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="global-logging-settings"><a class="anchor" href="#global-logging-settings"></a>Global logging settings</h3>
<div class="paragraph">
<p>You can customize the global logging settings for Couchbase Lite via the <code>Manager</code> class.
Log messages are tagged, allowing them to be logically grouped by activity.
You can control whether individual tag groups are logged.</p>
</div>
<div class="paragraph">
<p>The available tags are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">In Swift tag groups is disabled by default.

BLIP
BLIPVerbose
CBLDatabase
CBLJSONMatcher
CBLListener
CBLListenerVerbose
CBLModel
CBL_Router
CBL_Server
CBL_URLProtocol
CBLValidation
CBLRemoteRequest
CBLMultiStreamWriter
ChangeTracker
ChangeTrackerVerbose
JSONSchema
MYDynamicObject
Query
RemoteRequest
Sync
SyncVerbose
View
ViewVerbose
WS</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following code snippet enables logging for the <strong>Sync</strong> tag.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">CBLManager.enableLogging("Sync")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="concurrency-support"><a class="anchor" href="#concurrency-support"></a>Concurrency Support</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In Java all Couchbase Lite objects may be shared freely between threads.
The rest of this section is irrelevant for Java programs, and applies only to Objective-C.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In Objective-C, a <code>Manager</code> instance and the object graph associated with it may only be accessed from the thread or dispatch queue that created the <code>Manager</code> instance.
Concurrency is supported through explicit method calls.</p>
</div>
<div class="sect3">
<h4 id="running-individual-blocks-in-the-background"><a class="anchor" href="#running-individual-blocks-in-the-background"></a>Running individual blocks in the background</h4>
<div class="paragraph">
<p>You can use the <code>CBLManager</code> method <code>backgroundTellDatabaseNamed:to:</code> to perform any operation in the background.
Be careful with this, though! Couchbase Lite objects are per-thread, and your block runs on a background thread, so:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You can&#8217;t use any of the Couchbase Lite objects (databases, documents, models&#8230;&#8203;) you were using on the main thread.
Instead, you have to use the CBLDatabase object passed to the block, and the other objects reachable from it.</p>
</li>
<li>
<p>You can&#8217;t save any of the Couchbase Lite objects in the block and then call them on the main thread.
(For example, if in the block you allocated some CBLModels and assigned them to properties of application objects, bad stuff would happen if they got called later on by application code.)</p>
</li>
<li>
<p>And of course, since the block is called on a background thread, any application or system APIs you call from it need to be thread-safe.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In general, it&#8217;s best to do only very limited things using this API, otherwise it becomes too easy to accidentally use main-thread Couchbase Lite objects in the block, or store background-thread Couchbase Lite objects in places where they&#8217;ll be called on the main thread.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example that deletes a number of documents given an array of IDs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// "myDB" is the CBLDatabase object in use on the main thread.
let mgr = myDB.manager
let name = myDB.name
mgr.backgroundTellDatabaseNamed(name, to: { (bgdb: CBLDatabase!) -&gt; Void in
  // Inside this block we can't use myDB; instead use the instance given (bgdb)
  for docID in docIDs {
    bgdb.documentWithID(docID).deleteDocument(nil)
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="running-couchbase-lite-on-a-background-thread"><a class="anchor" href="#running-couchbase-lite-on-a-background-thread"></a>Running Couchbase Lite on a background thread</h4>
<div class="paragraph">
<p>If you want to do lots of Couchbase Lite processing in the background in Objective-C, the best way to do it is to start your own background thread and use a new <code>Manager</code> instance on it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: NSDictionary?) -&gt; Bool {
  let manager = CBLManager.sharedInstance()
  var error: NSError?
  let database = manager.databaseNamed("db", error: &amp;error)
  let bgMgr = manager.copy()
  NSThread.detachNewThreadSelector("runBackground:", toTarget: self, withObject: bgMgr)
  return true
}
func runBackground(bgMgr: CBLManager) {
  var error: NSError?
  let bgDB = [bgMgr.databaseNamed("db", error: &amp;error)]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you don&#8217;t plan to use Couchbase Lite on the main thread at all, the setup is even easier.
Just have the background thread create a new instance of CBLManager from scratch and use that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: NSDictionary?) -&gt; Bool {
  // We're not going to use Couchbase Lite at all on the main thread;
  // instead we start a background thread to run it on:
  NSThread.detachNewThreadSelector("runBackground", toTarget: self, withObject: nil)
  return true
}
func runBackground {
  let manager = CBLManager.sharedInstance()
  var error: NSError?
  let db = [manager.databaseNamed("db", error: &amp;error)]
  // ... now use the database
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="database"><a class="anchor" href="#database"></a>Database</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A Database is a container and a namespace for documents, a scope for queries, and the source and target of replication.
Databases are represented by the <code>Database</code> class.</p>
</div>
<div class="paragraph">
<p>Most applications only need one database, but you can use the Manager to create as many as you need.
Multiple databases are independent of each other.
If your application supports switching between multiple users, each with their own separate content and settings, you should consider using a database for each user.
Otherwise, it&#8217;s usually best to stick with one database.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A database is not a table.
Couchbase Lite doesn&#8217;t have any equivalent of relational database tables: different types of documents all coexist in the same database.
Usually you use a "type" property to distinguish them.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A database has the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Its <strong>name</strong>.
The name must consist only of <em>lowercase</em> ASCII letters, digits, and the special characters <code>_$()+-/</code>.
It must also be less than 240 bytes and start with a lower case letter.</p>
</li>
<li>
<p>Documents.
Each document is identified uniquely by its ID.</p>
</li>
<li>
<p>Views.
Each view has a unique name, and a persistent index as well as map and reduce functions.</p>
</li>
<li>
<p>Filter functions.
These are used to replicate subsets of documents.</p>
</li>
<li>
<p>Replications.
Each replication specifies a remote database to sync documents to or from, and other parameters.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="creating-a-database"><a class="anchor" href="#creating-a-database"></a>Creating a database</h3>
<div class="sect3">
<h4 id="creating-an-empty-database"><a class="anchor" href="#creating-an-empty-database"></a>Creating an empty database</h4>
<div class="paragraph">
<p>You create a new empty database by simply accessing it, using the <code>databaseNamed</code> method&#8201;&#8212;&#8201;this method opens the database if it isn&#8217;t yet open, and creates it if it doesn&#8217;t yet exist.
See the next section, Opening a database, for details.
This way you don&#8217;t have to write any special code for the first launch of the app.</p>
</div>
</div>
<div class="sect3">
<h4 id="pulling-down-a-remote-database"><a class="anchor" href="#pulling-down-a-remote-database"></a>Pulling down a remote database</h4>
<div class="paragraph">
<p>Often you&#8217;ll want to create a local clone (or subset) of a database on a server.
To do this you simply create an empty database as above, then start a pull replication that will download the remote database into it.
The replication is asynchronous, but you can monitor its progress to find out when it&#8217;s done.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If possible, avoid blocking until the replication completes.
The user&#8217;s first-launch experience will be much more pleasant if s/he can begin using your app immediately instead of staring at a modal progress screen waiting for downloads to complete.
If you&#8217;ve implemented a data-driven UI, the content will appear incrementally as it downloads.
For example, the ToDoLite app initially displays no content, but the to-do lists and their items quickly appear as the replication progresses.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="installing-a-pre-built-database"><a class="anchor" href="#installing-a-pre-built-database"></a>Installing a pre-built database</h4>
<div class="paragraph">
<p>If your app needs to sync a lot of data initially, but that data is fairly static and won&#8217;t change much, it can be a lot more efficient to bundle a database in your application and install it on the first launch.
Even if some of the content changes on the server after you create the app, the app&#8217;s first pull replication will bring the database up to date.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is essentially trading setup time for app installation time.
If you install a 100MB database in your app, that of course adds to the time it takes to download and install the app.
But it can still be faster than replication since the 100MB database will simply be downloaded in bulk as part of the app archive, instead of going through the interactive sync protocol.
Also, the download happens when the user expects it to (while installing the app) rather than when s/he&#8217;s not (on first launch).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To use a prebuilt database, you need to set up the database, build the database into your app bundle as a resource, and install the database during the initial launch.</p>
</div>
<div class="paragraph">
<p><strong>Setting Up the Database:</strong> You need to make the database as small as possible.
Couchbase Lite keeps a revision history of every document and that takes up space.
When creating the database locally, you can make it smaller by storing each document (via a PUT request) only once, rather than updating it multiple times.
(You can double-check this by verifying that each document revision ID starts with <code>1-</code>.)</p>
</div>
<div class="paragraph">
<p>If you start with a snapshot of a live database from a server, then create a new, empty local database and replicate the source database into it.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
On iOS / Mac OS, the Couchbase Lite Xcode project has a target called LiteServ that builds a small Mac app that does nothing but run the REST API.
LiteServ is a useful tool for creating databases and running replications locally on your development machine.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Extracting and Building the Database:</strong> Next you need to find the database&#8217;s files.
The location of these is determined by the Manager instance;
it&#8217;s in a directory called <code>CouchbaseLite</code> whose default location is platform-specific.
(On iOS and Mac OS, it&#8217;s in the <code>Application Support</code> directory.)
The main database file has a .cblite extension.
If your database has attachments, you also need the "databasename attachments" directory that&#8217;s adjacent to it.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
iOS/Mac specific instructions: Add the database file and the corresponding attachments directory to your Xcode project.
If you add the attachments folder, make sure that in the Add Files sheet you select the Create folder references for any added folders radio button, so that the folder structure is preserved;
otherwise, the individual attachment files are all added as top-level bundle resources.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Installing the Database:</strong> After your app launches and creates a Database instance for its database, it needs to check whether the database exists.
If the database does not exist, the app should copy it from the app bundle.
The code looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let dbManager = CBLManager.sharedInstance()
var error :NSError?
var database = dbManager.existingDatabaseNamed("catalog", error: &amp;error)
if database == nil {
    let cannedDbPath = NSBundle.mainBundle().pathForResource("catalog", ofType: "cblite")
    let cannedAttPath = NSBundle.mainBundle().pathForResource("catalog attachments", ofType: "")
    dbManager.replaceDatabaseNamed("catalog", withDatabaseFile: cannedDbPath, withAttachments: cannedAttPath, error: &amp;error)
    if error != nil {
        self.handleError(error)
    }
    database = dbManager.existingDatabaseNamed("catalog", error: &amp;error)
    if error != nil {
        self.handleError(error)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="opening-a-database"><a class="anchor" href="#opening-a-database"></a>Opening a database</h3>
<div class="paragraph">
<p>You&#8217;ll typically open a database while initializing your app, right after instantiating the Manager object, and store a reference to the Database object as either a global variable or a property of your top-level application object (the app delegate on iOS or Mac OS).
Opening a database is as simple as calling the Manager&#8217;s <code>databaseNamed</code> method&#8201;&#8212;&#8201;this will first create a new empty database if one doesn&#8217;t already exist with that name.
It&#8217;s fine to call this method more than once: it will return the same Database instance every time.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
For compatibility reasons, <strong>database names cannot contain uppercase letters!</strong>
The only legal characters are lowercase ASCII letters, digits, and the special characters <code>_$()+-/</code>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let manager = CBLManager.sharedInstance()
var error: NSError?
self.database = manager.databaseNamed("my-database", error: &amp;error)
if self.database == nil {
    self.handleError(error)
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you want to open only an existing database, without the possibility of creating a new one, call the related Manager method <code>existingDatabaseNamed</code> instead.
It returns null/nil (without an error or exception) if no database with that name exists.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="database-encryption"><a class="anchor" href="#database-encryption"></a>Database encryption</h3>
<div class="paragraph">
<p>Since Couchbase Lite 1.2, databases can be encrypted using SQLCipher;
an open source extension to SQLite that provides transparent encryption of database files.
The encryption specification is 256-bit AES.
The steps below outline how to enable it.</p>
</div>
<div class="sect3">
<h4 id="step-1-installing-sqlcipher"><a class="anchor" href="#step-1-installing-sqlcipher"></a>Step 1: Installing SQLCipher</h4>
<div class="paragraph">
<p>SQLCipher is an optional dependency.
The section below describes how to add it on each platform.</p>
</div>
<div class="sect4">
<h5 id="ios"><a class="anchor" href="#ios"></a>iOS</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Download the iOS SDK from <a href="http://www.couchbase.com/nosql-databases/downloads#couchbase-mobile">here</a>.</p>
</li>
<li>
<p>Add the <code>libsqlcipher.a</code> library to your XCode project.</p>
</li>
<li>
<p>Go to the Link Binary With Libraries build phase of your app target.</p>
</li>
<li>
<p>Remove <code>libsqlite.dylib</code></p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="step-2-enabling-encryption"><a class="anchor" href="#step-2-enabling-encryption"></a>Step 2: Enabling encryption</h4>
<div class="paragraph">
<p>At this point, Couchbase Lite won&#8217;t work any differently.
Databases are still unencrypted by default.
To enable encryption, you must register an encryption key when opening the database with the openDatabase method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">var options: CBLDatabaseOptions = CBLDatabaseOptions()
options.storageType = "SQLite"
options.encryptionKey = "password123456"
options.create = true
var database: CBLDatabase = manager.openDatabaseNamed("db", withOptions: options, error: nil)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the database does not exist (and <code>options.create</code> is true) it will be created encrypted with the given key.</p>
</div>
<div class="paragraph">
<p>If the database already exists, the key will be used to decrypt it (and to encrypt future changes).
If the key does not match the one previously used, opening the database will fail;
the error/exception will have status code 401.</p>
</div>
<div class="paragraph">
<p>To change the encryption key, you must first open the database using the <code>openDatabase</code> method with the existing key and if the operation is successful, use the <code>changeEncryptionKey</code> method providing the new key.
Passing <code>nil</code> as the value will disable encryption.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="storage-engines"><a class="anchor" href="#storage-engines"></a>Storage engines</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The following section describes how to set up ForestDB, which will be deprecated in the next major release of Couchbase Mobile.
For present and future development, we recommend to use the default storage type, SQLite.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are two storage engines available with Couchbase Lite: SQLite and ForestDB.
In the case of SQLite, it will use the system dependency already available on most platforms (iOS, Android, Windows&#8230;&#8203;).
To use ForestDB, the project must include the ForestDB storage dependency (see instructions below).</p>
</div>
<div class="sect3">
<h4 id="what-is-forestdb"><a class="anchor" href="#what-is-forestdb"></a>What is ForestDB?</h4>
<div class="paragraph">
<p>ForestDB is a persistent key-value storage library, it&#8217;s a key-value map where the keys and values are binary blobs.</p>
</div>
<div class="sect4">
<h5 id="benefits-of-using-forestdb"><a class="anchor" href="#benefits-of-using-forestdb"></a>Benefits of using ForestDB</h5>
<div class="ulist">
<ul>
<li>
<p>Faster (2x to 5x as fast, depending on the operation and data set)</p>
</li>
<li>
<p>Better concurrency (writers never block readers)</p>
</li>
<li>
<p>Lower RAM footprint (data caches are shared between threads)</p>
</li>
<li>
<p>Database compaction is automatic and runs periodically in the background</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="ios-2"><a class="anchor" href="#ios-2"></a>iOS</h5>
<div class="paragraph">
<p>The ForestDB engine isn&#8217;t built into the iOS and tvOS platforms, to save space.
To use ForestDB on those platforms you&#8217;ll need to link it into your app as an extra static library.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add the library <code>libCBLForestDBStorage.a</code> to your project and add it to your iOS app target&#8217;s "Link Binary With Libraries" build phase.</p>
</li>
<li>
<p>Link the system library <code>libc&#43;&#43;.dylib</code>.
To do that, in the target&#8217;s Build Phases editor, press the "+" button below the "Link Binary With Libraries" and add <code>libc&#43;&#43;.dylib</code></p>
</li>
<li>
<p>Make sure <code>-ObjC</code> is set in <code>Other Linker Flags</code> in <code>Build Settings</code></p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
These steps aren&#8217;t necessary for Mac OS because that version of the Couchbase Lite framework already has ForestDB built into it.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="choosing-a-storage-engine"><a class="anchor" href="#choosing-a-storage-engine"></a>Choosing a storage engine</h4>
<div class="sect4">
<h5 id="for-new-databases"><a class="anchor" href="#for-new-databases"></a>For new databases</h5>
<div class="paragraph">
<p>At runtime, you need to tell the <code>Manager</code> you want to use ForestDB, by setting its <code>storageType</code> to ForestDB.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">manager.storageType = kCBLForestDBStorage</code></pre>
</div>
</div>
<div class="paragraph">
<p>This only applies to new databases.
Existing local database files will always open with the same storage engine that created them.</p>
</div>
</div>
<div class="sect4">
<h5 id="upgrading-databases-to-forestdb"><a class="anchor" href="#upgrading-databases-to-forestdb"></a>Upgrading databases to ForestDB</h5>
<div class="paragraph">
<p>It&#8217;s possible to upgrade an existing local database file from SQLite to ForestDB.
You can use this option if you have an already-shipping app and want your existing installs to use ForestDB as well as new installs.
To do this, you use an alternate method to open your database, one that allows you to specify a set of options.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">var options: CBLDatabaseOptions = CBLDatabaseOptions()
options.create = true
options.storageType = kCBLForestDBStorage  // Forces upgrade to ForestDB
var db: CBLDatabase = manager.openDatabaseNamed("my-database", withOptions: options, error: error!)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Setting the options' <code>storageType</code> property forces the database to use the ForestDB format.
If it&#8217;s currently in SQLite format, it will be converted in place before being opened.
(The next time, it will just open normally, since it&#8217;s already ForestDB.)</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="concurrency-support-2"><a class="anchor" href="#concurrency-support-2"></a>Concurrency support</h3>
<div class="paragraph">
<p>Concurrency support varies by platform.</p>
</div>
<div class="sect3">
<h4 id="ios-mac-os-objective-c"><a class="anchor" href="#ios-mac-os-objective-c"></a>iOS, Mac OS (Objective-C)</h4>
<div class="paragraph">
<p>The Objective-C implementation follows the typical behavior of Cocoa classes: the classes are not themselves thread-safe, so the app is responsible for calling them safely.
In addition, some of the classes post <code>NSNotifications</code> and need to know what runloop or dispatch queue to deliver the notifications on.
Therefore, each thread or dispatch queue that you use Couchbase Lite on should have <em>its own set of Couchbase Lite objects</em>.</p>
</div>
<div class="paragraph">
<p>If your app uses Couchbase Lite on multiple threads, then on each thread (or dispatch queue) it must:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create a new CBLManager instance.
If you use multiple threads, do not use the <code>sharedInstance</code>.</p>
</li>
<li>
<p>Use only objects (Databases, Documents, &#8230;&#8203;) acquired from its Manager.</p>
</li>
<li>
<p>Not pass any Couchbase Lite objects to code running on any other thread/queue.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If different threads/queues need to communicate to each other about documents, they can use the document ID (and database name, if you use multiple databases).</p>
</div>
<div class="paragraph">
<p>By default, Couchbase Lite is thread-based;
if you are instead creating a CBLManager for use on a dispatch queue (which might run on different threads during its lifetime), you must set the Manager&#8217;s <code>dispatchQueue</code> property, so that it can properly schedule future calls.</p>
</div>
<div class="paragraph">
<p>As a convenience, CBLManager&#8217;s <code>backgroundTellDatabaseNamed:to:</code> method will run a block on an existing background thread (the same one the replicator runs on).
You must be careful to avoid using any of the calling thread&#8217;s objects in the block, since the block runs on a different thread.
Instead, you should use the CBLDatabase object passed to the block and derive other objects like documents from it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// Example to read a document asynchronously on a background thread.
// (This isn't very realistic since reading one document is fast enough to
// do on the main thread.)
let docID = myDocument.documentID
myDB.manager.backgroundTellDatabaseNamed(myDB.name, to: { (bgdb: CBLDatabase!) -&gt; Void in
    if let bgDoc = bgdb[docID] {
        var properties = bgDoc.properties;
        dispatch_async(nil, { () -&gt; Void in
            self.handleDoc(properties)
        })
    }
})</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="android-java"><a class="anchor" href="#android-java"></a>Android, Java</h5>
<div class="paragraph">
<p>It is safe to call Couchbase Lite from multiple threads on the Android / Java platform.
If you find any thread safety related issues, please report a bug.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="database-notifications"><a class="anchor" href="#database-notifications"></a>Database notifications</h3>
<div class="paragraph">
<p>You can register for notifications when documents are added/updated/deleted from a database.
In practice, applications don&#8217;t use these as much as live queries and document change notifications;
still this facility can be useful if you want a lightweight way to tell whenever anything&#8217;s changed in a database.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">NSNotificationCenter.defaultCenter().addObserverForName(kCBLDatabaseChangeNotification, object: myDatabase, queue: nil) {
  (notification) -&gt; Void in
    if let changes = notification.userInfo!["changes"] as? [CBLDatabaseChange] {
        for change in changes {
            NSLog("Document changed, revision ID '%@'", change.revisionID)
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above shows how to access the revision linked to the document change that is being processed.
The notifications may not be delivered immediately after the document changes.
Notifications aren&#8217;t delivered during a transaction;
they&#8217;re buffered up for delivery after the transaction completes.</p>
</div>
</div>
<div class="sect2">
<h3 id="database-housekeeping"><a class="anchor" href="#database-housekeeping"></a>Database housekeeping</h3>
<div class="paragraph">
<p>Refer to the <a href="#revision">Revision</a> guide to learn about compaction and pruning to manage the database size.</p>
</div>
</div>
<div class="sect2">
<h3 id="deleting-a-database"><a class="anchor" href="#deleting-a-database"></a>Deleting a database</h3>
<div class="paragraph">
<p>The <code>delete</code> method (<code>deleteDatabase</code> in Objective-C) permanently deletes a database&#8217;s file and all its attachments.
After this, you should immediately set your Database reference to nil/null and not call it again.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">var error: NSError?
if !self.database.deleteDatabase(&amp;error) {
    self.handleError(error)
}
self.database = nil</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="document"><a class="anchor" href="#document"></a>Document</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In a <em>document database</em> such as Couchbase Lite, the primary entity stored in a database is called a <strong>document</strong> instead of a "row" or "record".
This reflects the fact that a document can store more data, with more structure, than its equivalent in other databases.</p>
</div>
<div class="paragraph">
<p>In Couchbase Lite, a document&#8217;s <strong>body</strong> takes the form of a JSON object&#8201;&#8212;&#8201;a collection of key/value pairs where the values can be different types of data such as numbers, strings, arrays or even nested objects.
Every document is identified by a <strong>document ID</strong>, which can be automatically generated (as a UUID) or determined by the application;
the only constraints are that it must be unique within the database, and it can&#8217;t be changed.</p>
</div>
<div class="paragraph">
<p>In addition, a document can contain attachments, named binary blobs that are useful for storing large media files or other non-textual data.
Couchbase Lite supports attachments of unlimited size, although the Sync Gateway currently imposes a 20MB limit for attachments synced to it.</p>
</div>
<div class="paragraph">
<p>Couchbase Lite keeps track of the change history of every document, as a series of revisions.
This is somewhat like a version control system such as Git or Subversion, although its main purpose is not to be able to access old data, but rather to assist the replicator in deciding what data to sync and what documents have conflicts.
Every time a document is created or updated, it is assigned a new unique <strong>revision ID</strong>.
The IDs of past revisions are available, and the contents of past revisions may be available, but only if the revision was created locally and the database has not yet been compacted.</p>
</div>
<div class="paragraph">
<p>To summarize, a document has the following attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A document ID</p>
</li>
<li>
<p>A current revision ID (which changes every time the document is updated)</p>
</li>
<li>
<p>A history of past revision IDs (usually linear, but will form a branching tree if the document has or has had conflicts)</p>
</li>
<li>
<p>A body in the form of a JSON object, i.e., a set of key/value pairs</p>
</li>
<li>
<p>Zero or more named binary attachments</p>
</li>
<li>
<p>Creating, Reading, Updating and Deleting documents (CRUD)</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="creating-reading-updating-and-deleting-documents-crud"><a class="anchor" href="#creating-reading-updating-and-deleting-documents-crud"></a>Creating, Reading, Updating and Deleting documents (CRUD)</h3>
<div class="paragraph">
<p>Couchbase Lite of course supports the typical database "CRUD" operations on documents: Create, Read, Update, Delete.</p>
</div>
<div class="sect3">
<h4 id="creating-documents"><a class="anchor" href="#creating-documents"></a>Creating documents</h4>
<div class="paragraph">
<p>You can create a document with or without giving it an ID.
If you don&#8217;t need or want to define your own ID, call the Database method <code>createDocument</code>, and the ID will be generated randomly in the form of a Universally Unique ID (UUID), which looks like a string of hex digits.
The uniqueness ensures that there is no chance of an accidental collision by two client apps independently creating different documents with the same ID, then replicating to the same server.</p>
</div>
<div class="paragraph">
<p>The following example shows how to create a document with an automatically-assigned UUID:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let owner = "profile".stringByAppendingString(userId)
let properties = [
    "type": "list",
    "title": title,
    "owner": owner,
    "members": []
]
let document = database.createDocument()
var error: NSError?
if document.putProperties(properties, error: &amp;error) == nil {
    self.handleError(error)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you do want to choose the document&#8217;s ID, just call the Database method <code>getDocument</code>, just as you would to retrieve an existing document.
If the document doesn&#8217;t exist yet, you still get a valid Document object, it just doesn&#8217;t have any revisions or contents yet.
The first time you save the document, it will be added persistently to the database.
If a document does already exist with the same ID, saving the document will produce a conflict error.</p>
</div>
<div class="paragraph">
<p>The following example shows how to create a document with an custom ID:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let properties =
[
    "title": "Little, Big",
    "author": "John Crowley",
    "published":  1982
]
let document = database.documentWithID("978-0061120053")
var error: NSError?
if document.putProperties(properties, error: &amp;error) == nil {
    self.handleError(error)
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
It&#8217;s up to you whether to assign your own IDs or use random UUIDs.
If the documents are representing entities that already have unique IDs&#8201;&#8212;&#8201;like email addresses or employee numbers&#8201;&#8212;&#8201;then it makes sense to use those, especially if you need to ensure that there can&#8217;t be two documents representing the same entity.
For example, in a library cataloging app, you wouldn&#8217;t want two librarians to independently create duplicate records for the same book, so you might use the book&#8217;s ISBN as the document ID to enforce uniqueness.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="reading-documents"><a class="anchor" href="#reading-documents"></a>Reading documents</h4>
<div class="paragraph">
<p>To retrieve a Document object given its ID, call the Database method <code>getDocument</code>.
As described in the previous section, if there is no document with this ID, this method will return a valid but empty Document object.
(If you would rather get a null/nil result for a nonexistent document, call <code>existingDocumentWithID</code> instead.)</p>
</div>
<div class="paragraph">
<p>Document objects, like document IDs, are unique.
That means that there is never more than one Document object in memory that represents the same document.
If you call <code>getDocument</code> multiple times with the same ID, you get the same Document object every time.
This helps conserve memory, and it also makes it easy to compare Document object references (pointers)&#8201;&#8212;&#8201;you can just use <code>==</code> to check whether two references refer to the same document.</p>
</div>
<div class="paragraph">
<p>Loading a Document object doesn&#8217;t immediately read its properties from the database.
Those are loaded on demand, when you call an accessor method like <code>getProperties</code> (or access the Objective-C property <code>properties</code>).
The properties are represented using whatever platform type is appropriate for a JSON object.
In Objective-C they&#8217;re an <code>NSDictionary</code>, in Java a <code>Map&lt;String,Object&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a simple example of getting a document&#8217;s properties:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let doc = database.documentWithID(myDocID)
// We can directly access properties from the document object:
let title = doc["title"] as? String
// Or go through its properties dictionary:
let properties = doc.properties;
let owner = properties["owner"] as? String;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>getProperties</code> method is actually just a convenient shortcut for getting the Document&#8217;s <code>currentRevision</code> and then getting its <code>properties</code>&#8201;&#8212;&#8201;since a document usually has multiple revisions, the properties really belong to a revision.
Every existing document has a current revision (in fact that&#8217;s how you can tell whether a document exists or not).
Almost all the time you&#8217;ll be accessing a document&#8217;s current revision, which is why the convenient direct properties accessor exists.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="updating-documents"><a class="anchor" href="#updating-documents"></a>Updating documents</h4>
<div class="paragraph">
<p>There are two methods that update a document: <code>putProperties</code> and <code>update</code>.
We&#8217;ll cover them both, then explain why they&#8217;re different.</p>
</div>
<div class="paragraph">
<p><code>putProperties</code> is simpler: given a new JSON object, it replaces the document&#8217;s body with that object.
Actually what it does is creates a new revision with those properties and makes it the document&#8217;s current revision.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let doc = database.documentWithID(myDocID)
var properties = doc.properties
properties["title"] = title
properties["notes"] = notes
var error: NSError?
if doc.putProperties(properties, error: &amp;error) == nil {
    self.handleError(error)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>update</code> instead takes a callback function or block (the details vary by language).
It loads the current revision&#8217;s properties, then calls this function, passing it an <code>UnsavedRevision</code> object, whose properties are a mutable copy of the current ones.
Your callback code can modify this object&#8217;s properties as it sees fit;
after it returns, the modified revision is saved and becomes the current one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let doc = database.documentWithID(myDocID)
var error: NSError?
doc.update({ (newRev) -&gt; Bool in
    newRev["title"] = title
    newRev["notes"] = notes
    return true
}, error: &amp;error)
if error != nil {
    self.handleError(error)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Whichever way you save changes, you need to consider the possibility of <strong>update conflicts</strong>.
Couchbase Lite uses Multiversion Concurrency Control (MVCC) to guard against simultaneous changes to a document.
(Even if your app code is single-threaded, the replicator runs on a background thread and can be pulling revisions into the database at the same time you&#8217;re making changes.)</p>
</div>
<div class="paragraph">
<p>Here&#8217;s the typical sequence of events that creates an update conflict:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Your code reads the document&#8217;s current properties, and constructs a modified copy to save</p>
</li>
<li>
<p>Another thread (perhaps the replicator) updates the document, creating a new revision with different properties</p>
</li>
<li>
<p>Your code updates the document with its modified properties</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Clearly, if your update were allowed to proceed, the change from step 2 would be overwritten and lost.
Instead, the update will fail with a conflict error.
Here&#8217;s where the two API calls differ:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>putProperties simply returns the error to you to handle.
You&#8217;ll need to detect this type of error, and probably handle it by re-reading the new properties and making the change to those, then trying again.</p>
</li>
<li>
<p>update is smarter: it handles the conflict error itself by re-reading the document, then calling your block again with the updated properties, and retrying the save.
It will keep retrying until there is no conflict.</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Of the two techniques, calling update may be a bit harder to understand initially, but it actually makes your code simpler and more reliable.
We recommend it.
(Just be aware that your callback block can be called multiple times.)
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="deleting-documents"><a class="anchor" href="#deleting-documents"></a>Deleting documents</h4>
<div class="paragraph">
<p>The <code>delete</code> method (<code>deleteDocument:</code> in Objective-C) deletes a document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let doc = database.documentWithID(myDocID)
var error: NSError?
if !doc.deleteDocument(&amp;error) {
    self.handleError(error)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Deleting a document actually just creates a new revision (informally called a "tombstone") that has the special <code>_deleted</code> property set to <code>true</code>.
This ensures that the deletion will replicate to the server, and then to other endpoints that pull from that database, just like any other document revision.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It&#8217;s possible for the delete call to fail with a conflict error, since it&#8217;s really just a special type of putProperties.
In other words, something else may have updated the document at the same time you were trying to delete it.
It&#8217;s up to your app whether it&#8217;s appropriate to retry the delete operation.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you need to preserve one or more fields in a document that you want to <code>delete</code> (like a record of who deleted it or when it was deleted) you can avoid the delete method;
just update the document and set the <code>UnsavedRevision</code><code>'s `deletion</code> property to <code>true</code>, or set JSON properties that include a <code>"_deleted"</code> property with a value of <code>true</code>.
You can retain all of the fields, as shown in the following example, or you can remove specified fields so that the tombstone revision contains only the fields that you need.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">doc.update({ (newRev) -&gt; Bool in
    newRev.isDeletion = true
    newRev["deleted_at"] = currentTimeString
    return true
}, error: &amp;error)
if error != nil {
    self.handleError(error)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="document-expiration-ttl"><a class="anchor" href="#document-expiration-ttl"></a>Document expiration (TTL)</h3>
<div class="paragraph">
<p>Documents in a local database can have an expiration time.
After that time, they are automatically purged from the database - this completely removes them, freeing the space they occupied.
This feature was introduced in Couchbase Lite 1.3.</p>
</div>
<div class="paragraph">
<p>The following example sets the TTL for a document to 5 seconds from the current time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">var ttl = NSDate(timeIntervalSinceNow: 5)
var properties = ["foo": "bar"]
var doc = db.createDocument()
doc.putProperties(properties, error: nil)
doc.expirationDate = ttl</code></pre>
</div>
</div>
<div class="paragraph">
<p>Expiration timing is not highly precise.
The times are stored with one-second granularity, and the timer that triggers expiration may be delayed slightly by the operating system or by other activity on the database thread.
Expiration won&#8217;t happen while the app is not running;
this means it may be triggered soon after the app is activated or launched, to catch up with expiration times that have already passed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As with the existing explicit <strong>purge</strong> mechanism, this applies only to the local database;
it has nothing to do with replication.
This expiration time is not propagated when the document is replicated.
The purge of the document does not cause it to be deleted on any other database.
If the document is later updated on a remote database that the local database pulls from, the new revision will be pulled and the document will reappear.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="document-change-notifications"><a class="anchor" href="#document-change-notifications"></a>Document change notifications</h3>
<div class="paragraph">
<p>You can register for notifications when a particular document is updated or deleted.
This is very useful if you&#8217;re display a user interface element whose content is based on the document: use the notification to trigger a redisplay of the view.</p>
</div>
<div class="paragraph">
<p>You can use change events for the following purposes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>To be notified when new revisions are added to a document</p>
</li>
<li>
<p>To be notified when a document is deleted</p>
</li>
<li>
<p>To be notified when a document enters into a conflicted state</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">NSNotificationCenter.defaultCenter().addObserverForName(kCBLDocumentChangeNotification, object: myDocument, queue: nil) {
    (notification) -&gt; Void in
        if let change = notification.userInfo!["change"] as? CBLDatabaseChange {
            NSLog("This is a new revision, %@", change.revisionID);
            set.setNeedsDisplay(true)
        }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="conflicts"><a class="anchor" href="#conflicts"></a>Conflicts</h3>
<div class="paragraph">
<p>So far we&#8217;ve been talking about a conflict as an error that occurs when you try to update a document that&#8217;s been updated since you read it.
In this scenario, Couchbase Lite is able to stop the conflict before it happens, giving your code a chance to re-read the document and incorporate the other changes.</p>
</div>
<div class="paragraph">
<p>However, there&#8217;s no practical way to prevent a conflict when the two updates are made on different instances of the database.
Neither app even knows that the other one has changed the document, until later on when replication propagates their incompatible changes to each other.
A typical scenario is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Molly creates DocumentA; the revision is 1-5ac</p>
</li>
<li>
<p>DocumentA is synced to Naomi&#8217;s device; the latest revision is still 1-5ac</p>
</li>
<li>
<p>Molly updates DocumentA, creating revision 2-54a</p>
</li>
<li>
<p>Naomi makes a different change to DocumentA, creating revision 2-877</p>
</li>
<li>
<p>Revision 2-877 is synced to Molly&#8217;s device, which already has 2-54a, putting the document in conflict</p>
</li>
<li>
<p>Revision 2-54a is synced to Naomi&#8217;s device, which already has 2-877, similarly putting the local document in conflict</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>At this point, even though DocumentA is in a conflicted state, it needs to have a current revision.
That is, when your app calls <code>getProperties</code>, Couchbase Lite has to return something.
It chooses one of the two conflicting revisions (2-877 and 2-54a) as the "winner".
The choice is deterministic, which means that every device that is faced with the same conflict will pick the same winner, without having to communicate.
In this case it just compares the revision IDs "2-54a" and "2-877" and picks the higher one, "2-877".</p>
</div>
<div class="paragraph">
<p>To be precise, Couchbase Lite uses the following rules to handle conflicts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The winner is the undeleted leaf revision on the longest revision branch (i.e., with the largest prefix number in its revision ID.)</p>
</li>
<li>
<p>If there are no undeleted leaf revisions, the deletion (tombstone) on the longest branch wins.</p>
</li>
<li>
<p>If there&#8217;s a tie, the winner is the one whose revision ID sorts higher in a simple ASCII comparison.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Couchbase Lite does not automatically merge the contents of conflicts.
Automated merging would run the risk of giving wrong or undesired results in many cases;
only you know your document schemas well enough to decide how conflicts should be merged.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In some cases this simple "one revision wins" rule is good enough.
For example, in a grocery list if two people rename the same item, one of them will just see that their change got overwritten, and may do it over again.
But usually the details of the document content are more important, so the application will want to detect and resolve conflicts.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Resolving conflicts can also save the space in the database.
Conflicting revisions stay in the database indefinitely until resolved, even surviving compactions.
Therefore, it makes sense to deal with the conflict by at least deleting the non-winning revision.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Another reason to resolve conflicts is to implement business rules.
For example, if two sales associates update the same customer record and it ends up in conflict, you might want the sales manager to resolve the conflict and "hand merge" the two conflicting records so that no information is lost.</p>
</div>
<div class="paragraph">
<p>There are two alternative ways to resolve a conflict:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Pick a winner.</strong> Just decide which of the two changes should win, and delete the other one.
The deleted revision will no longer be eligible as a conflict winner, so there won&#8217;t be any more conflict.</p>
</li>
<li>
<p><strong>Merge.</strong> Consider the contents of both conflicting revisions and construct a new revision that incorporates both.
The details are, of course, application-dependent, and might even require user interaction.
Then resolve the conflict by saving the merged revision, then deleting the old losing conflict revision.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows how to resolve a conflict:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let doc = database.documentWithID(myDocID)
var error: NSError?
if let conflicts = doc.getConflictingRevisions(&amp;error) as? [CBLSavedRevision]{
    if conflicts.count &gt; 1 {
        // There is more than one leaf revision, thus a conflict!
        database.inTransaction({ () -&gt; Bool in
            // Come up with a merged/resolved document in some way that's
            // appropriate for the app. You could even just pick the body of
            // one of the revisions.
            var mergedProps = self.mergeRevisions(conflicts)
            // Delete the conflicting revisions to get rid of the conflict:
            var current = doc.currentRevision
            for rev in conflicts {
                var newRev = rev.createRevision()
                if rev == current {
                    // add the merged revision
                    newRev.properties = NSMutableDictionary(dictionary: mergedProps)
                } else {
                    // mark other conflicts as deleted
                    newRev.isDeletion = true
                }
                // saveAllowingConflict allows 'rev' to be updated even if it
                // is not the document's current revision.
                var error: NSError?
                if newRev.saveAllowingConflict(&amp;error) == nil {
                    return false
                }
            }
            return true
        })
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="document-conflict-faq"><a class="anchor" href="#document-conflict-faq"></a>Document Conflict FAQ</h3>
<div class="sect3">
<h4 id="what-if-both-devices-make-the-same-change-to-the-document-is-that-a-conflict"><a class="anchor" href="#what-if-both-devices-make-the-same-change-to-the-document-is-that-a-conflict"></a>What if both devices make the same change to the document? Is that a conflict?</h4>
<div class="paragraph">
<p>No.
The revision ID is derived from a digest of the document body.
So if two databases save identical changes, they end up with identical revision IDs, and Couchbase Lite (and the Sync Gateway) treat these as the same revision.</p>
</div>
</div>
<div class="sect3">
<h4 id="i-deleted-a-document-but-the-it-s-still-in-the-database-only-now-its-properties-are-different-what-happened"><a class="anchor" href="#i-deleted-a-document-but-the-it-s-still-in-the-database-only-now-its-properties-are-different-what-happened"></a>I deleted a document, but the it&#8217;s still in the database, only now its properties are different. What happened?</h4>
<div class="paragraph">
<p>Sounds like the document was in conflict and you didn&#8217;t realize it.
You deleted the winning revision, but that made the other (losing) revision become the current one.
If you delete the document again, it&#8217;ll actually go away.</p>
</div>
</div>
<div class="sect3">
<h4 id="how-can-i-get-the-properties-of-the-common-ancestor-revision-to-do-a-three-way-merge"><a class="anchor" href="#how-can-i-get-the-properties-of-the-common-ancestor-revision-to-do-a-three-way-merge"></a>How can I get the properties of the common ancestor revision, to do a three-way merge?</h4>
<div class="paragraph">
<p>You can&#8217;t always.
Couchbase Lite isn&#8217;t a version-control system and doesn&#8217;t preserve old revision bodies indefinitely.
But if the ancestor revision used to exist in your local database, and you haven&#8217;t yet compacted the database, you can still get its properties.
Get the <code>parentRevision</code> property of the current revision to get the ancestor, then see if its <code>properties</code> are still non-null.</p>
</div>
</div>
<div class="sect3">
<h4 id="how-can-i-tell-if-a-document-has-a-conflict"><a class="anchor" href="#how-can-i-tell-if-a-document-has-a-conflict"></a>How can I tell if a document has a conflict?</h4>
<div class="paragraph">
<p>Call its <code>getConflictingRevisions</code> method and see if more than one revision is returned.</p>
</div>
</div>
<div class="sect3">
<h4 id="how-can-i-tell-if-there-are-any-conflicts-in-the-database"><a class="anchor" href="#how-can-i-tell-if-there-are-any-conflicts-in-the-database"></a>How can I tell if there are any conflicts in the database?</h4>
<div class="paragraph">
<p>Use an all-documents query with the <code>onlyConflicts</code> mode.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="purging-documents"><a class="anchor" href="#purging-documents"></a>Purging documents</h3>
<div class="paragraph">
<p>Purging a document is different from deleting it;
it&#8217;s more like forgetting it.
The <code>purge</code> method removes all trace of a document (and all its revisions and their attachments) from the local database.
It has no effect on replication or on remote databases, though.</p>
</div>
<div class="paragraph">
<p>Purging is mostly a way to save disk space by forgetting about replicated documents that you don&#8217;t need anymore.
It has some slightly weird interactions with replication, though.
For example, if you purge a document, and then later the document is updated on the remote server, the next replication will pull the document into your database again.</p>
</div>
</div>
<div class="sect2">
<h3 id="special-properties"><a class="anchor" href="#special-properties"></a>Special Properties</h3>
<div class="paragraph">
<p>The body of a document contains a few special properties that store metadata about the document.
For the most part you can ignore these since the API provides accessor methods for the same information, but it can still be helpful to know what they are if you encounter them.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>_id</code>: The document ID.</p>
</li>
<li>
<p><code>_rev</code>: The revision ID.</p>
</li>
<li>
<p><code>_attachments</code>: Metadata about the document&#8217;s attachments.</p>
</li>
<li>
<p><code>_deleted</code>: Only appears in a deletion (tombstone) revision, where it has the value <code>true</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A leading underscore always denotes a reserved property&#8212;&#8203;don&#8217;t use an underscore prefix for any of your own properties, and don&#8217;t change the value of any reserved property.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="revision"><a class="anchor" href="#revision"></a>Revision</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Couchbase Lite uses revisions to resolve conflicts detected during replication.
One significant difference from other databases is document versioning.
Couchbase Lite uses a technique called Multiversion Concurrency Control (MVCC) to manage conflicts between multiple writers.
This is the same technique used by version-control systems like Git or Subversion, and by WebDAV.
Document versioning is similar to the check-and-set mechanism (CAS) of Couchbase Server, except that in Couchbase Lite versioning is required rather than optional and the token is a UUID rather than an integer.</p>
</div>
<div class="paragraph">
<p>Every document has a special field called <code>_rev</code> that contains the revision ID.
The revision ID is assigned automatically each time the document is saved.
Every time a document is updated, it gets a different and unique revision ID.</p>
</div>
<div class="paragraph">
<p>When you save an update to an existing document, you must include its current revision ID.
If the revision ID you provide isn&#8217;t the current one, the update is rejected.
When this happens, it means some other endpoint snuck in and updated the document before you.
You need to fetch the new version, reconcile any changes, incorporate the newer revision ID, and try again.</p>
</div>
<div class="paragraph">
<p>Keep in mind that Couchbase Lite is not a version control system and you must not use the versioning feature in your application.
They&#8217;re there only to help with concurrency and resolving conflicts during replication.</p>
</div>
<div class="sect2">
<h3 id="resolving-conflicts"><a class="anchor" href="#resolving-conflicts"></a>Resolving Conflicts</h3>
<div class="paragraph">
<p>Revisions form a tree data structure since they can have multiple branches.
In the case where there are multiple branches, one or more conflicts exist and should be resolved per the application requirements.
Refer to the <a href="https://docs.couchbase.com/tutorials/todo-app/develop/swift/adding-synchronization.html#resolve-conflicts">Resolve Conflicts</a> section of the <code>TodoApp</code> tutorial to learn how to resolve conflicts in your application.</p>
</div>
</div>
<div class="sect2">
<h3 id="tombstones"><a class="anchor" href="#tombstones"></a>Tombstones</h3>
<div class="paragraph">
<p>The reason that tombstone revisions exist is so that deletes can be sync&#8217;d to other databases.
If revisions were simply deleted with a naive approach, then there would be no easy way to sync up with other databases that contained the revision.</p>
</div>
<div class="paragraph">
<p>There is a special field in a revision&#8217;s JSON called <code>_deleted</code> which determines whether the revision is a tombstone revision or not.
A consequence of this fact is that tombstone revisions can hold arbitrary amounts of metadata, which can be useful for an application.
If the full metadata of the document is preserved in the tombstone revision, then a document could easily be restored to it&#8217;s last known good state after it&#8217;s been deleted at some point.</p>
</div>
<div class="paragraph">
<p>For examples of deleting revisions via adding a tombstone revision, refer to the guide on Documents.</p>
</div>
</div>
<div class="sect2">
<h3 id="saved-vs-unsaved-revision"><a class="anchor" href="#saved-vs-unsaved-revision"></a>Saved vs Unsaved Revision</h3>
<div class="paragraph">
<p>Here are the main differences between Saved and Unsaved Revision objects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Unsaved revisions have not yet been persisted to the database.</p>
</li>
<li>
<p>Saved revisions have already been persisted to the database.</p>
</li>
<li>
<p>Unsaved revisions are useful for adding attachments.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Unsaved Revisions are mainly useful for manipulating attachments, since they provide the only means to do so via the API.
See Attachments for examples of adding/removing attachments.</p>
</div>
</div>
<div class="sect2">
<h3 id="pruning"><a class="anchor" href="#pruning"></a>Pruning</h3>
<div class="paragraph">
<p>Pruning is the process that deletes the metadata and/or JSON bodies associated with old non-leaf revisions.
Leaf revisions are not impacted.
The process runs automatically every time a revision is added.
The <strong>maxRevTreeDepth</strong> value defaults to 20, which means that the metadata and JSON bodies of the last 20 revisions are retained in Couchbase Lite as shown on the animation below.</p>
</div>
<div class="paragraph">
<p>If there are conflicting revisions, the document may end up with <strong>disconnected branches</strong> after the pruning process.
In the animation below, the document has a conflicting branch (revisions 3 - 7).
When the current revision (or longest branch) reaches the 23rd update, the conflicting branch is cut off.
The revision tree is not in a corrupted state and the logic that chooses the winning revision still applies.
But it may make it impossible to do certain merges to resolve conflicts and occupy disk space that could have been free-ed if the conflict was resolved early on.</p>
</div>
</div>
<div class="sect2">
<h3 id="compaction"><a class="anchor" href="#compaction"></a>Compaction</h3>
<div class="paragraph">
<p>Compaction is defined as the process of purging the JSON bodies of non-leaf revisions.
As shown on the diagram below, only properties with a leading underscore (<code>_</code> is the character to denote properties reserved for Couchbase) are kept to construct the revision tree.</p>
</div>
<div class="paragraph">
<p>Compaction can only be invoked manually via the <code>Database.compact()</code> method.
The compaction process does not remove JSON bodies of leaf nodes.
Hence, it is important to resolve conflicts in your application in order to re-claim disk space when the compaction process is executed.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="attachment"><a class="anchor" href="#attachment"></a>Attachment</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Attachments store data associated with a document, but are not part of the document&#8217;s JSON object.
Their primary purpose is to make it efficient to store large binary data in a document.
Binary data stored in JSON has to be base64-encoded into a string, which inflates its size by 33%.
Also, binary data blobs are often large (think of camera images or audio files), and big JSON documents are slow to parse.</p>
</div>
<div class="paragraph">
<p>Attachments are uninterpreted data (blobs) stored separately from the JSON body.
A document can have any number of attachments, each with a different name.
Each attachment is also tagged with a MIME type, which isn&#8217;t used by Couchbase Lite but can help your application interpret its contents.
On Couchbase Lite, attachments can be arbitrarily large, and are only read on demand, not when you load a <code>Document</code> object.
On Sync Gateway, the maximum content size is 20 MB per attachment.
If a document&#8217;s attachment is over 20 MB, the document will be replicated but not the attachment.</p>
</div>
<div class="paragraph">
<p>Attachments also make replication more efficient.
When a document that contains pre-existing attachments is synced, only attachments that have changed since the last sync are transferred over the network.
In particular, changes to document JSON values will <strong>not</strong> cause Couchbase Lite to re-send attachment data when the attachment has not changed.</p>
</div>
<div class="paragraph">
<p>In the native API, attachments are represented by the <code>Attachment</code> class.
Attachments are available from a <code>Revision</code> object.
From a <code>Document</code>, you get to the attachments via its <code>currentRevision</code>.</p>
</div>
<div class="sect2">
<h3 id="reading-attachments"><a class="anchor" href="#reading-attachments"></a>Reading attachments</h3>
<div class="paragraph">
<p>The <code>Revision</code> class has a number of methods for accessing attachments:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>attachmentNames</code> returns the names of all the attachments.</p>
</li>
<li>
<p><code>attachmentNamed</code> returns an <code>Attachment</code> object given its name.</p>
</li>
<li>
<p><code>attachments</code> returns all the attachments as <code>Attachment</code> objects.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Once you have an <code>Attachment</code> object, you can access its name, MIME type and content length.
The accessors for the content vary by platform: on iOS it&#8217;s available as an <code>NSData</code> object or as an <code>NSURL</code> pointing to a read-only file;
in Java you read the data from an <code>InputStream</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// Load an JPEG attachment from a document into a UIImage:
let doc = db.documentWithID("Robin")
let rev = doc.currentRevision
let att = rev.attachmentNamed("photo.jpg")
var photo: UIImage?
if att != nil {
    photo = UIImage(att.content)
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="writing-and-deleting-attachments"><a class="anchor" href="#writing-and-deleting-attachments"></a>Writing (and deleting) attachments</h3>
<div class="paragraph">
<p>To create an attachment, first create a mutable <code>UnsavedRevision</code> object by calling <code>createRevision</code> on the document&#8217;s <code>currentRevision</code>.
Then call <code>setAttachment</code> on the new revision to add an attachment.
(You can of course also change the JSON by modifying the revision&#8217;s properties.)
Finally you call <code>save</code> to save the new revision.</p>
</div>
<div class="paragraph">
<p>Updating an attachment&#8217;s content (or type) works exactly the same way: the <code>setAttachment</code> method will replace any existing attachment with the same name.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// Add or update an image to a document as a JPEG attachment:
let doc = db.documentWithID("Robin")
let newRev = doc.currentRevision.createRevision()
let imageData = UIImageJPEGRepresentation(photo, 0.75)
newRev.setAttachmentNamed("photo.jpg", withContentType: "image/jpeg", content: imageData)
var error: NSError?
assert(newRev.save(&amp;error) != nil)</code></pre>
</div>
</div>
<div class="paragraph">
<p>To delete an attachment, just call <code>removeAttachment</code> instead of <code>setAttachment</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// Remove an attachment from a document:
let doc = db.documentWithID("Robin")
let newRev = doc.currentRevision.createRevision()
newRev.removeAttachmentNamed("phto.jpg")
var error: NSError?
assert(newRev.save(&amp;error) != nil)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="attachment-storage"><a class="anchor" href="#attachment-storage"></a>Attachment storage</h3>
<div class="paragraph">
<p>In general, you don&#8217;t need to think about where and how Couchbase Lite is storing data.
But since attachments can occupy a lot of space, it can be helpful to know where that space is and how it&#8217;s managed.</p>
</div>
<div class="paragraph">
<p>Attachments aren&#8217;t stored in the database file itself.
Instead they are individual files, contained in a directory right next to the database file.
Each attachment file has a cryptic name that is actually a SHA-1 digest of its contents.</p>
</div>
<div class="paragraph">
<p>As a consequence of the naming scheme, attachments are de-duplicated: if multiple attachments in the same database have exactly the same contents, the data is only stored once in the filesystem.</p>
</div>
<div class="paragraph">
<p>Updating a document&#8217;s attachment does <strong>not</strong> immediately remove the old version of the attachment.
And deleting a document does not immediately delete its attachments.
An attachment file has to remain on disk as long as there are any document revisions that reference it, And a revision persists until the next database compaction after it&#8217;s been replaced or deleted.
(Orphaned attachment files are deleted from disk as part of the compaction process.)
So if you&#8217;re concerned about the space taken up by attachments, you should compact the database frequently, or at least after making changes to large attachments.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="view"><a class="anchor" href="#view"></a>View</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A View is a persistent index of documents in a database, which you then query to find data.
Couchbase Lite doesn&#8217;t have a query language like SQL;
instead, it uses a technique called map/reduce to generate indexes (views) according to arbitrary app-defined criteria.
Queries can then look up a range of rows from a view, and either use the rows' keys and values directly or get the documents they came from.</p>
</div>
<div class="paragraph">
<p>The main component of a view (other than its name) is its <strong>map function</strong>.
This function is written in the same language as your app&#8212;&#8203;most likely Objective-C or Java&#8212;&#8203;so it&#8217;s very flexible.
It takes a document&#8217;s JSON as input, and <strong>emits</strong> (outputs) any number of key/value pairs to be indexed.
The view generates a complete index by calling the map function on every document in the database, and adding each emitted key/value pair to the index, sorted by key.
For example, a map function might grind through an address-book database and produce a set of mappings from names to phone numbers.
The resulting index is persistent, and updated incrementally as documents change.
(It&#8217;s very much like the type of index a SQL database creates internally to optimize queries.)</p>
</div>
<div class="paragraph">
<p>A view may also have a <strong>reduce function</strong>.
If present, it can be used during queries to combine multiple rows into one.
It can be used to compute aggregate values like totals or averages, or to group rows by common criteria (like collecting all the artists in a record collection.)
We&#8217;ll explain reduce functions later on.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<strong>A view is not a query, it&#8217;s an index.</strong>
Views are persistent, and need to be updated (incrementally) whenever documents change, so having large numbers of them can be expensive.
Instead, it&#8217;s better to have a smaller number of views that can be queried in interesting ways.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="creating-and-initializing-views"><a class="anchor" href="#creating-and-initializing-views"></a>Creating and initializing views</h3>
<div class="paragraph">
<p><code>View</code> objects belong to a <code>Database</code>.
You create or find a view by calling the database&#8217;s <code>viewNamed</code> method, which will create and return a new <code>View</code> if none exists by that name.</p>
</div>
<div class="paragraph">
<p>Even though a view is persistent, its map and reduce functions aren&#8217;t: they&#8217;re just function pointers (or blocks, or inner classes) and have to be registered at runtime, before the view is queried.
It&#8217;s good practice to set up views when your app starts up, right after opening the database:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// Create a view and register its map function:
let phoneView = db.viewNamed("phones")
phoneView.setMapBlock({ (doc, emit) in
    if let phones = doc["phones"] as? [String] {
        for phone in phones {
            emit(phone, doc["name"])
        }
    }
}, version: "2")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>version</code> parameter to <code>setMapBlock</code> takes a bit of explanation.
During development, and as you update the app, you may change the behavior of a map function.
This invalidates any existing index generated by that function, so the next time the app runs, the view should rebuild the index from scratch using the new function.
Unfortunately the view indexer can&#8217;t tell that the map function has changed because it can&#8217;t see its source code! Instead, you have to provide a version string that the indexer can compare, and you must change that string whenever you change the function.
The easiest thing to remember is just to set the version to "1" initially, and then increment it every time you edit any source code in the map function (or any function of yours that it calls).</p>
</div>
</div>
<div class="sect2">
<h3 id="querying-views"><a class="anchor" href="#querying-views"></a>Querying views</h3>
<div class="paragraph">
<p>You query a view by using a <code>Query</code> object that you create from a <code>View</code> by calling <code>createQuery</code>.
This is a big topic, and is covered in a separate article on the <code>Query</code> class.</p>
</div>
</div>
<div class="sect2">
<h3 id="map-functions"><a class="anchor" href="#map-functions"></a>Map functions</h3>
<div class="sect3">
<h4 id="understanding-map-functions"><a class="anchor" href="#understanding-map-functions"></a>Understanding map functions</h4>
<div class="paragraph">
<p>As discussed in the introduction, a map function&#8217;s job is to look at a document&#8217;s JSON contents and from them produce (emit) zero or more key/value pairs to be indexed.
If you know SQL, you can think of it as corresponding to the expressions that immediately follow the <code>SELECT</code> and <code>WHERE</code> keywords, only more powerful because you have the full power of a programming language available.</p>
</div>
<div class="paragraph">
<p>For discussion purposes, here&#8217;s a simple map function in JavaScript:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">function(doc) {
    if (doc["type"] == "person")
        emit(doc["name"], doc["phone"]);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function works with a database that contains, among other things, documents representing people, which are tagged with a <code>type</code> property whose value is &#8220;person&#8221;.
(This use of a <code>type</code> property is a common idiom.)
Every person document contains <code>name</code> and <code>phone</code> properties.
The map function simply checks whether the document represents a person, and if it does, it calls <code>emit</code> to add the name and phone number to the index.</p>
</div>
<div class="paragraph">
<p>The resulting index maps names to phone numbers.
You can query it to look up someone by name and find their phone number.
You can also query it to get ranges of names, in alphabetical order, which is very useful for driving GUI list views.</p>
</div>
</div>
<div class="sect3">
<h4 id="rules-for-the-map-function"><a class="anchor" href="#rules-for-the-map-function"></a>Rules for the map function</h4>
<div class="paragraph">
<p>The map function is called by the indexer to help generate an index, and it has to meet certain requirements, otherwise the index won&#8217;t be consistent.
It&#8217;s important to understand some rules so you can create a proper map function, otherwise your queries can misbehave in strange ways.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>It must be a "https://en.wikipedia.org/wiki/Pure_function[pure]" function:</strong> That means any time it&#8217;s called with the same input, it must produce exactly the same output.
In other words, it can&#8217;t use any external state, just its input JSON.</p>
</li>
<li>
<p><strong>It can&#8217;t have side effects:</strong> It shouldn&#8217;t change any external state, because it&#8217;s unpredictable when it&#8217;s called or how often it&#8217;s called or in what order documents are passed to it.</p>
</li>
<li>
<p><strong>It must be thread-safe:</strong> It may be called on a background thread belonging to the indexer, or even in parallel on several threads at once.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In particular, avoid these common mistakes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Don&#8217;t do anything that depends on the current date and time&#8201;&#8212;&#8201;that breaks the first rule, since your function&#8217;s output can change depending on the date/time it&#8217;s called.
Common mistakes include emitting the current time as a timestamp, emitting a person&#8217;s age, or emitting only documents that have been modified in the past week.</p>
</li>
<li>
<p>Don&#8217;t try to "parameterize" the map function by referring to an external variable whose value you change when querying.
It won&#8217;t work.
People sometimes try this because they want to find various subsets of the data, like all the items of a particular color.
Instead, emit all the values of that property, and use a key range in the query to pick out the rows with the specific value you want.</p>
</li>
<li>
<p>Don&#8217;t make any assumptions about when the map function is called.
That&#8217;s an implementation detail of the indexer.
(For example, it&#8217;s not called every time a document changes.)</p>
</li>
<li>
<p>Avoid having the map function call out into complex external code.
That code might change later on to be stateful or have side effects, breaking your map function.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="keys-and-values"><a class="anchor" href="#keys-and-values"></a>Keys and values</h4>
<div class="paragraph">
<p>Both the key and value passed to <code>emit</code> can be any JSON-compatible objects: not just strings, but also numbers, booleans, arrays, dictionaries/maps, and the special JSON <code>null</code> object (which is distinct from a null/nil pointer).
In addition, the value emitted, but <em>not</em> the key, can be a null/nil pointer.
(It&#8217;s pretty common to not need a value in a view, in which case it&#8217;s more efficient to not emit one.)</p>
</div>
<div class="paragraph">
<p>Keys are commonly strings, but it turns out that arrays are a very useful type of key as well.
This is because of the way arrays are sorted: given two array keys, the first items are compared first, then if those match the second items are compared, and so on.
That means that you can use array keys to establish multiple levels of sorting.
If the map function emits keys of the form <em>[lastname, firstname]</em>, then the index will be sorted by last name, and entries with the same last name will be sorted by first name, just as if you&#8217;d used <em>ORDER BY lastname, firstname</em> in SQL.</p>
</div>
<div class="paragraph">
<p>Here are the exact rules for sorting (collation) of keys.
The most significant factor is the key&#8217;s object type;
keys of one type always sort before or after keys of a different type.
This list gives the types in order, and states how objects of that type are compared:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>null</p>
</li>
<li>
<p>false, true (in that order)</p>
</li>
<li>
<p>Numbers, in numeric order of course</p>
</li>
<li>
<p>Strings, case-insensitive.
The exact ordering is specified by the <a href="http://www.unicode.org/unicode/reports/tr10/">Unicode Collation Algorithm</a>.
This is <strong>not</strong> the same as ASCII ordering, so the results might surprise you&#8201;&#8212;&#8201;for example, all symbols, including "~", sort before alphanumeric characters.</p>
</li>
<li>
<p>Arrays, compared item-by-item as described above.</p>
</li>
<li>
<p>Maps/dictionaries, also compared item-by-item.
Unfortunately the order of items is ambiguous (since JSON doesn&#8217;t specify any ordering of keys, and most implementations use hash tables which randomize the order) so using these as keys isn&#8217;t recommended.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="the-source-document-and-redirection"><a class="anchor" href="#the-source-document-and-redirection"></a>The source document, and redirection</h4>
<div class="paragraph">
<p>In addition to its key and value, every index row also remembers the ID of the document that emitted it.
This can be accessed at query time via the <code>QueryRow.documentID</code> property, or more commonly via the shortcut <code>QueryRow.document</code> which uses the ID to load the Document object.</p>
</div>
<div class="paragraph">
<p>It can sometimes be useful to redirect this reference, i.e., to make the index row point to a different document instead.
You do this by emitting a value that&#8217;s a dictionary with a key <code>_id</code> whose value is the document ID you want the row to reference.
The <code>QueryRow.documentID</code> and accessors will then use this document ID instead.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// This example indexes documents that record Facebook-style "likes".
// When querying, the document we really want to look at is the post being
// liked, so we redirect the emitted row at that document.
view.setMapBlock({ (doc, emit) -&gt; Void in
    if doc["type"] as? String == "like" {
        let associatedID = doc["likePostID"] as String
        let key = [doc["creator"]!, doc["date"]!]
        let value = ["_id": associatedID]
        emit(key, value)
    }
}, version: "1")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even if you&#8217;ve used the redirect technique, at query time you can still recover the ID of the actual document that emitted the row, by using the <code>QueryRow.sourceDocumentID</code> property.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reduce-functions"><a class="anchor" href="#reduce-functions"></a>Reduce functions</h3>
<div class="sect3">
<h4 id="understanding-reduce-functions"><a class="anchor" href="#understanding-reduce-functions"></a>Understanding reduce functions</h4>
<div class="paragraph">
<p>Reduce functions are the other half of the map/reduce technique.
They&#8217;re optional, and less commonly used.
A reduce function post-processes the indexed key/value pairs generated by the map function, by aggregating the values together.
Very commonly it counts them, or (if the values are numeric) totals or averages them.
The reduce function boils down data the way a chef reduces a sauce.
Or if you&#8217;re a SQL user, reduce functions are like SQL aggregation operators like <code>COUNT</code> or <code>AVERAGE</code> (only you get to define your own).</p>
</div>
<div class="paragraph">
<p>In general, most views don&#8217;t need reduce functions, so don&#8217;t feel like you&#8217;re missing something if you haven&#8217;t written one.
But if you find yourself writing a query and counting the returned rows or adding up their values, you could do that more efficiently with a reduce function.</p>
</div>
<div class="paragraph">
<p><strong>A reduce function takes an ordered list of key/value pairs, aggregates them together into a single object, and returns that object.</strong>
Here&#8217;s an example, building on the phone-numbers example up above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let phoneView = db.viewNamed("phones")
phoneView.setMapBlock({ (doc, emit) -&gt; Void in
    if let phones = doc["phones"] as? [String] {
        for phone in phones {
            emit(phone, doc["name"])
        }
    }
}, reduceBlock: { (keys, values, rereduce) -&gt; AnyObject! in
    return values.count
}, version: "2")</code></pre>
</div>
</div>
<div class="paragraph">
<p>For efficiency, the key/value pairs are passed in as two parallel arrays.
This reduce block just counts the number of values and returns that number as an object.
We could query this view, with reduce enabled, and get the total number of phone numbers in the database.
Or by specifying a key range we could find the number of phone numbers in that range, for example the number in a single area code.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s just the body of a reduce function that totals up numbers.
(This function would belong in a different view, whose map function emitted numeric values.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">var total: Double = 0.0
let numberValues = values as [Double];
for value in numberValues {
    total += value
}
return total</code></pre>
</div>
</div>
<div class="paragraph">
<p>This totaling is common enough that <code>CBLView</code> provide a utility to do it for you, the <code>totalValues</code> method.</p>
</div>
</div>
<div class="sect3">
<h4 id="rereducing"><a class="anchor" href="#rereducing"></a>Rereducing</h4>
<div class="paragraph">
<p>The previous section ignored the boolean <code>rereduce</code> parameter that&#8217;s passed to the reduce function.
What&#8217;s it for?
Unfortunately, from your perspective as a reduce-function-writer it&#8217;s just there to make your job a bit harder.
The reason it exists is because it&#8217;s part of a major optimization that makes reducing more efficient for the query engine.</p>
</div>
<div class="paragraph">
<p>Think of a view with a hundred million rows in its index.
To run a reduced query against the whole index (with no startKey or endKey) the database will have to read all hundred million keys and values into memory at once, so it can pass them all to your reduce function.
That&#8217;s a lot of overhead, and on a mobile device it&#8217;s likely to crash your app.</p>
</div>
<div class="paragraph">
<p>Instead, the database will read the rows in chunks.
It&#8217;ll read some number of rows into memory, send them to your reduce function, release them from memory, then go on to the next rows.
This scales very well, but now there&#8217;s the problem of what to do with the multiple reduced values returned by your function.
Reducing is supposed to produce one end result, not several! The answer is to reduce the list of reduced values&#8201;&#8212;&#8201;to <code>re-reduce</code>.</p>
</div>
<div class="paragraph">
<p>The rereduce parameter is there to tell your reduce function that it&#8217;s being called in this special <code>re-reduce mode</code>.
<strong>When re-reducing there are no keys, and the values are the ones already returned by previous runs of the same reduce function.</strong>
The function&#8217;s job is, once again, to combine the values into a single value and return it.</p>
</div>
<div class="paragraph">
<p>Sometimes you can handle re-reduce mode exactly like reduce mode.
The second reduce block shown above (the one that totals up the values) can do this.
Since its input values are numbers, and its output is a number, the re-reduce is done the same way as the reduce, and it can just ignore the <code>rereduce</code> flag.</p>
</div>
<div class="paragraph">
<p>But sometimes re-reduce has to work differently, because the output of the reduce stage doesn&#8217;t look like the indexed values.
The first reduce example&#8201;&#8212;&#8201;the one that just counts the rows&#8201;&#8212;&#8201;is an example.
To re-reduce a list of row counts, you can&#8217;t just count them, you have to add them.
Let&#8217;s revisit that example and add proper support for re-reducing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// Create a view and register its map and reduce functions:
let phoneView = db.viewNamed("phones")
phoneView.setMapBlock({ (doc, emit) in
    if let phones = doc["phones"] as? [String] {
        for phone in phones {
            emit(phone, doc["name"])
        }
    }
}, reduceBlock: { (keys, values, rereduce) in
    if rereduce {
        return CBLView.totalValues(values) // re-reduce mode adds up counts
    } else {
        return values.count
    }
}, version: "2")</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the <code>rereduce</code> flag is off, this just counts the raw values as before.
But when the flag is on, it knows it&#8217;s been given an array of row counts, so it invokes the <code>totalValues</code> method to add them up.</p>
</div>
<div class="paragraph">
<p>Now that you know how re-reduce works, we should let you know <strong>that Couchbase Lite 1.0 doesn&#8217;t actually use re-reduce</strong>&#8201;&#8212;&#8201;your reduce function will always be given index rows, never already-reduced values.
The <code>rereduce</code> parameter is in the API for future expansion, because in the future Couchbase Lite will use it.
For now, it&#8217;s up to you whether you want to ignore re-reduce (and maybe find that your reduce function breaks in the future) or code defensively and implement it now even though it isn&#8217;t used yet.</p>
</div>
</div>
<div class="sect3">
<h4 id="rules-for-the-reduce-function"><a class="anchor" href="#rules-for-the-reduce-function"></a>Rules for the reduce function</h4>
<div class="paragraph">
<p>The reduce function has the same restrictions as the map function (see above): It must be a "pure" function that always produce the same output given the same input.
It must not have side effects.
And it must be thread-safe.
In addition:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Its output should be no larger than its input.</strong>
Usually this comes naturally.
But it is legal to return an array or dictionary, and sometimes people have tried to make reduce functions that transform the input values without actually making them any smaller.
The problem with this is that it scales badly, and as the size of the index grows, the indexer will eventually run out of memory and fail.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="development-considerations"><a class="anchor" href="#development-considerations"></a>Development considerations</h3>
<div class="sect3">
<h4 id="map-function-design"><a class="anchor" href="#map-function-design"></a>Map function design</h4>
<div class="paragraph">
<p><strong>When to emit a whole document as the value?</strong>
In some places you&#8217;ll see code that does something like <code>emit(key, doc)</code>, i.e., emitting the document&#8217;s entire body as the value.
(Some people seem to do this by reflex whenever they don&#8217;t have a specific value in mind.)
It&#8217;s not necessarily bad, but most of the time you shouldn&#8217;t do it.
The benefit is that, by having the document&#8217;s properties right at hand when you process a query row, it can make querying a little bit faster (saving a trip to the database to load the document).
But the downside is that it makes the view index a lot larger, which can make querying slower.
So whether it&#8217;s a net gain or loss depends on the specific use case.
We recommend that you just set the value to <code>null</code> if you don&#8217;t need to emit any specific value.</p>
</div>
<div class="paragraph">
<p><strong>Is it OK is the same key is emitted more than once?</strong>
The index allows duplicate keys, whether emitted by the same document or different documents.
A query will return all of those key/value pairs if they match.
They&#8217;ll be sorted by the ID of the document that was responsible for emitting them;
if a doc emits the same key multiple times, the order is undefined.</p>
</div>
<div class="paragraph">
<p><strong>When is the map function called?</strong>
View indexes are updated on demand when queried.
So after a document changes, the next query made to a view will cause that view&#8217;s map function to be called on the doc&#8217;s new contents, updating the view index.
(But remember that you shouldn&#8217;t write any code that makes assumptions about when map functions are called.)</p>
</div>
<div class="paragraph">
<p><strong>If a document has conflicts, which conflicting revision gets indexed?</strong>
The document&#8217;s <code>currentRevision</code>, sometimes called the "winning" revision, is the one that you see in the API if you don&#8217;t request a revision by ID.</p>
</div>
</div>
<div class="sect3">
<h4 id="performance"><a class="anchor" href="#performance"></a>Performance</h4>
<div class="paragraph">
<p><strong>How to improve your view indexing:</strong>
The main thing you have control over is the performance of your map function, both how long it takes to run and how many objects it allocates.
Try profiling your app while the view is indexing and see if a lot of time is spent in the map function;
if so, optimize it.
See if you can short-circuit the map function and give up early if the document isn&#8217;t a type that will produce any rows.
Also see if you could emit less data.
(If you&#8217;re emitting the entire document as a value, don&#8217;t.)</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="query"><a class="anchor" href="#query"></a>Query</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A <strong>query</strong> is the action of looking up results from a view&#8217;s index.
In Couchbase Lite, queries are objects of the <code>Query</code> class.
To perform a query you create one of these, customize its properties (such as the key range or the maximum number of rows) and then run it.
The result is a <code>QueryEnumerator</code>, which provides a list of <code>QueryRow</code> objects, each one describing one row from the view&#8217;s index.</p>
</div>
<div class="paragraph">
<p>There&#8217;s also a special type of query called an <strong>all-docs query</strong>.
This type of query isn&#8217;t associated with any view;
or rather, you can think of it as querying an imaginary view that contains one row for every document in the database.
You use an all-docs query to find all the documents in the database, or the documents with keys in a specific range, or even the documents with a specific set of keys.
It can also be used to find documents with conflicts.</p>
</div>
<div class="paragraph">
<p>Couchbase Lite also provides <strong>live queries</strong>.
Once created, a live query remains active and monitors changes to the view&#8217;s index, notifying observers whenever the query results change.
Live queries are very useful for driving UI components like table views.</p>
</div>
<div class="sect2">
<h3 id="creating-and-configuring-queries"><a class="anchor" href="#creating-and-configuring-queries"></a>Creating and configuring queries</h3>
<div class="paragraph">
<p><code>Query</code> objects are created by a <code>View</code><code>'s `createQuery</code> method, and by a <code>Database</code><code>'s `createAllDocumentsQuery</code> method.
In its default state a <code>Query</code> object will return every row of the index, in increasing order by key.
But there are several properties you can configure to change this, before you run the query.
Here are the most basic and common ones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>startKey</code>: the key to start at.
The default value, <code>null</code>, means to start from the beginning.</p>
</li>
<li>
<p><code>endKey</code>: the last key to return.
The default value, <code>null</code>, means to continue to the end.</p>
</li>
<li>
<p><code>descending</code>: If set to <code>true</code>, the keys will be returned in reverse order.
(This also reverses the meanings of the <code>startKey</code> and <code>endKey</code> properties, since the query will now start at the highest keys and end at lower ones!)</p>
</li>
<li>
<p><code>limit</code>: If nonzero, this is the maximum number of rows that will be returned.</p>
</li>
<li>
<p><code>skip</code>: If nonzero, this many rows will be skipped (starting from the <code>startKey</code> if any).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Some more advanced properties that aren&#8217;t used as often:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>keys</code>: If provided, the query will fetch only the rows with the given keys (and <code>startKey</code> and <code>endKey</code> will be ignored).</p>
</li>
<li>
<p><code>startKeyDocID</code>: If multiple index rows match the startKey, this property specifies that the result should start from the one(s) emitted by the document with this ID, if any.
(Useful if the view contains multiple identical keys, making .startKey ambiguous.)</p>
</li>
<li>
<p><code>endKeyDocID</code>: If multiple index rows match the endKey, this property specifies that the result should end with from the one(s) emitted by the document with this ID, if any.
(Useful if the view contains multiple identical keys, making .startKey ambiguous.)</p>
</li>
<li>
<p><code>indexUpdateMode</code>: Changes the behavior of index updating.
By default the index will be updated if necessary before the query runs.
You can choose to skip this (and get possibly-stale results), with the option of also starting an asynchronous background update of the index.</p>
</li>
<li>
<p><code>prefixMatchLevel</code>: If nonzero, enables prefix matching of string or array keys.</p>
<div class="ulist">
<ul>
<li>
<p>A value of 1 treats the endKey itself as a prefix: if it&#8217;s a string, keys in the index that come after the endKey, but begin with the same prefix, will be matched.
(For example, if the endKey is <code>"foo"</code> then the key <code>"foolish"</code> in the index will be matched, but not <code>"fong"</code>.)
Or if the endKey is an array, any array beginning with those elements will be matched.
(For example, if the endKey is <code>[1]</code>, then <code>[1, "x"]</code> will match, but not <code>[2]</code>.)
If the key is any other type, there is no effect.</p>
</li>
<li>
<p>A value of 2 assumes the endKey is an array and treats its final item as a prefix, using the rules above.
(For example, an endKey of <code>[1, "x"]</code> will match <code>[1, "xtc"]</code> but not <code>[1, "y"]</code>.)</p>
</li>
<li>
<p>A value of 3 assumes the key is an array of arrays, etc.</p>
<div class="paragraph">
<p>Note that if the <code>.descending</code> property is also set, the search order is reversed and the above discussion applies to the <code>startKey`</code> <strong>not</strong> the <code>endKey</code>.</p>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are other advanced properties that only apply to reducing and grouping:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>mapOnly</code>: If set to true, prevents the reduce function from being run, so you get all of the index rows instead of an aggregate.
Has no effect if the view has no reduce function.</p>
</li>
<li>
<p><code>groupLevel</code>: If greater than zero, enables grouping of rows.
The value specifies the number of items in the value array that will be grouped.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// Set up a query for a view that indexes blog posts, to get the latest:
let query = db.viewNamed("postsByDate").createQuery()
query.descending = true
query.limit = 20</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="all-documents-queries"><a class="anchor" href="#all-documents-queries"></a>All-documents queries</h3>
<div class="paragraph">
<p>An all-docs query isn&#8217;t associated with a view;
or rather, you can think of it as querying an imaginary view that contains one row for every document in the database, whose key is the document ID.
It supports all the standard view options, so you can query ranges of document IDs, reverse the order, and even query a specific set of documents using the <code>keys</code> property.</p>
</div>
<div class="paragraph">
<p>All-docs queries also have a special property called <code>allDocsMode</code> that can customize their behavior.
Its values are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>allDocs</code>: The default mode.
Returns all non-deleted documents.</p>
</li>
<li>
<p><code>includeDeleted</code>: In this mode, deleted documents are included as well.</p>
</li>
<li>
<p><code>showConflicts</code>: In this mode, each <code>QueryRow</code><code>'s `conflictingRevisions</code> property can be used to find whether it&#8217;s in conflict and what the IDs of the conflicting revisions are.</p>
</li>
<li>
<p><code>onlyConflicts</code>: Like <code>showConflicts</code>, but <em>only</em> conflicted documents are returned.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>(<em>These are not flags.</em>
You can only choose one.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// Let's find the documents that have conflicts so we can resolve them:
let query = db.createAllDocumentsQuery()
query.allDocsMode = CBLAllDocsMode.OnlyConflicts
var error: NSError?
let result = query.run(&amp;error)
while let row = result?.nextRow() {
    NSLog("!!! Conflict in document %@", row.documentID);
    self.beginConflictResolution(row.document)
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="running-queries"><a class="anchor" href="#running-queries"></a>Running queries</h3>
<div class="paragraph">
<p>After a <code>Query</code> object is set up just right, you call its <code>run</code> method to get the results.
These are returned as a <code>QueryEnumerator</code> object, which mainly serves as an enumerable collection of <code>QueryRow</code> objects.</p>
</div>
<div class="paragraph">
<p>Each <code>QueryRow</code> has two main properties, its <code>key</code> and its <code>value</code>.
These are what were emitted to the index.
(Or in the case of an all-docs query, the key is the same as the document ID.)
It also has a <code>documentID</code> property that identifies the document that the key and value were emitted from, although usually you&#8217;d access the <code>document</code> property instead, which gives you the <code>Document</code> object directly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// Let's query a view that maps product names to prices,
// starting with the "M"s and showing 100 widgets:
let query = db.viewNamed("widgetsByName").createQuery()
query.startKey = "m"
query.limit = 100
var error: NSError?
let result = query.run(&amp;error)
while let row = result?.nextRow() {
    NSLog("Widget named %@ costs $%.2f", row.key as String, row.value as Double);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="re-running-queries-and-livequery"><a class="anchor" href="#re-running-queries-and-livequery"></a>Re-running queries, and LiveQuery</h3>
<div class="paragraph">
<p>It&#8217;s OK to run the same Query again.
You can even change its settings before the next run.
But if you find yourself wanting to re-run a query over and over to check for updates, there are some optimizations to consider.</p>
</div>
<div class="paragraph">
<p>First, there&#8217;s a quick check to see whether the previous query results are still up to date.
If you keep the QueryEnumerator object and check its <code>stale</code> property, a <code>false</code> value means that the view index hasn&#8217;t changed and re-running the query won&#8217;t give you a different result set.</p>
</div>
<div class="paragraph">
<p>Second, even if the enumerator says it&#8217;s stale and you re-run the query, the new results might not be any different.
The <code>stale</code> method is conservative and might report false positives, and even if the index did change, your query might not include any of the changed rows.
You can quickly check if the new QueryEnumerator you got is equivalent to the old one by comparing the objects for equality (e.g., using <code>equals</code> in Java, or <code>-isEqual:</code> in Objective-C).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// Check whether the query result set has changed:
if (queryResult == nil || queryResult.stale) {
    let newResult = query.run(&amp;error)
    if (queryResult != newResult) {
        queryResult = newResult
        self.updateMyUserInterface()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s a class that actually does this work for you, called <code>LiveQuery</code>.
A live query stays active and monitors the database and view index for changes.
When there&#8217;s a change it re-runs itself automatically, and if the query results changed it notifies any observers.
LiveQuery is a great way to build reactive user interfaces, especially table/list views, that keep themselves up to date.
For example, as the replicator runs and pulls new data from the server, a LiveQuery-driven UI will automatically update to show the data without the user having to manually refresh.
This helps your app feel quick and responsive.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">func initializeQuery() {
    let query = db.viewNamed("widgets").createQuery()
    query.limit = 100
    liveQuery = query.asLiveQuery()
    liveQuery.addObserver(self, forKeyPath: "rows", options: nil, context: nil)
    liveQuery.start()
}
override func observeValueForKeyPath(keyPath: String, ofObject object: AnyObject,
    change: [NSObject : AnyObject], context: UnsafeMutablePointer&lt;Void&gt;) {
    if object as? NSObject == liveQuery {
        displayRows(liveQuery.rows)
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="querying-key-ranges"><a class="anchor" href="#querying-key-ranges"></a>Querying key ranges</h3>
<div class="paragraph">
<p>There are some subtleties to working with key ranges (<code>startKey</code> and <code>endKey</code>).
The first is that if you reverse the order of keys, by setting the <code>reverse</code> property, then the <code>startKey</code> needs to be <em>greater than</em> the <code>endKey</code>.
That&#8217;s the reason they&#8217;re named <em>start</em> and <em>end</em>, rather than <em>min</em> and <em>max</em>.
In the following example, note that the key range starts at 100 and ends at 90;
if we&#8217;d done it the other way around, we&#8217;d have gotten an empty result set.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// Set up a query for the highest-rated movies:
let query = db.viewNamed("postsByDate").createQuery()
query.descending = true
query.startKey = 100 // Note the start key is higher than the end key
query.endKey = 90</code></pre>
</div>
</div>
<div class="paragraph">
<p>Second is the handling of compound (array) keys.
When a view&#8217;s keys are arrays, it&#8217;s very common to want to query all the rows that have a specific value (or value range) for the first element.
The start key is just a one-element array with that value in it, but it&#8217;s not obvious what the <em>end</em> key should be.
What works is an array that&#8217;s like the starting key but with a second object appended that&#8217;s greater than any possible value.
For example, if the start key is (in JSON) <code>["red"]</code> then the end key could be <code>["red", "ZZZZ"]</code> &#8230;&#8203;
because none of the possible second items could be greater than "ZZZZ", right?
Unfortunately this has obvious problems.
The correct stop value to use turns out to be an empty object/dictionary, <code>{}</code>, making the end key <code>["red", {}]</code>.
This works because the sort order in views puts dictionaries last.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// Assume the view's keys are like [color, model]. We want all the red ones.
let query = db.viewNamed("carsByColorAndModel").createQuery()
query.startKey = ["red"]
query.endKey = ["red",[:]]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reducing"><a class="anchor" href="#reducing"></a>Reducing</h3>
<div class="paragraph">
<p>If the view has a reduce function, it will be run <em>by default</em> when you query the view.
This means that all rows of the output will be aggregated into a single row with no key, whose value is the output of the reduce function.
(See the View documentation for a full description of what reduce functions do.)</p>
</div>
<div class="paragraph">
<p>(It&#8217;s important to realize that the reduce function runs on the rows that <em>would be output</em>, not all the rows in the view.
So if you set the <code>startKey</code> and/or <code>endKey</code>, the reduce function runs only on the rows in that key range.)</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t want the reduce function to be used, set the query&#8217;s <code>mapOnly</code> property to <code>true</code>.
This gives you the flexibility to use a single view for both detailed results and statistics.
For example, adding a typical row-count reduce function to a view lets you get the full results (with <code>mapOnly=true</code>) or just the number of rows (with <code>mapOnly=false</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// This view's keys are order dates, and values are prices.
// The reduce function computes an average of the input values.
let query = ordersByDateView.createQuery()
query.startKey = "2014-01-01"
query.endKey = "2014-02-01"
query.inclusiveEnd = false
// First run without reduce to get the individual orders for January '14:
query.mapOnly = true
var error: NSError?
var result = query.run(&amp;error)
while let row = result?.nextRow() {
    NSLog("On %@: order for $%.2f", row.key as String, row.value as Double);
}
// Now run with reduce to get the average order price for January '14:
query.mapOnly = false
result = query.run(&amp;error)
if let aggregate = result?.nextRow() {
    NSLog("Average order was $%.2f", aggregate.value as Double)
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="grouping-by-key"><a class="anchor" href="#grouping-by-key"></a>Grouping by key</h3>
<div class="paragraph">
<p>The <code>groupLevel</code> property of a query allows you to collapse together (aggregate) rows with the same keys or key prefixes.
And you can compute aggregated statistics of the grouped-together rows by using a reduce function.
One very powerful use of grouping is to take a view whose keys are arrays representing a hierarchy&#8201;&#8212;&#8201;like <code>[genre, artist, album, track]</code> for a music library&#8201;&#8212;&#8201;and query a single level of the hierarchy for use in a navigation UI.</p>
</div>
<div class="paragraph">
<p>In general, <code>groupLevel</code> requires that the keys be arrays;
rows with other types of keys will be ignored.
When the <code>groupLevel</code> is <em>n</em>, the query combines rows that have equal values in the first n items of the key into a single row whose key is the n-item common prefix.</p>
</div>
<div class="paragraph">
<p><code>groupLevel=1</code> is slightly different in that it supports non-array keys: it compares them for equality.
In other words, if a view&#8217;s keys are strings or numbers, a query with <code>groupLevel=1</code> will return a row for each <em>unique</em> key in the index.</p>
</div>
<div class="paragraph">
<p>We&#8217;ve talked about the keys of grouped query rows, but what are the values?
The <code>value</code> property of each row will be the result of running the view&#8217;s reduce function over all the rows that were aggregated;
or if the view has no reduce function, there&#8217;s no value.
(See the View documentation for information on reduce functions.)</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an interesting example.
We have a database of the user&#8217;s music library, and a view containing a row for every audio track, with key of the form <code>[genre, artist, album, trackname]</code> and value being the track&#8217;s duration in seconds.
The view has a reduce function that simply totals the input values.
The user&#8217;s drilled down into the genre "Mope-Rock", then artist "Radiohead", and now we want to display the albums by this artist, showing each album&#8217;s running time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">var albumTitles: [String] = []
var albumTimes: [Int] = []
var error: NSError?
let result = query.run(&amp;error)
while let row = result?.nextRow() {
    albumTitles.append(row.keyAtIndex(2) as String)
    albumTimes.append(row.value as Int)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="replication"><a class="anchor" href="#replication"></a>Replication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A Replication object represents a replication (or "sync") task that transfers changes between a local database and a remote one.
To replicate, you first get a new Replication object from a Database, then configure its settings, then tell it to start.
The actual replication runs asynchronously on a background thread;
you can monitor its progress by observing notifications posted by the Replication object when its state changes, as well as notifications posted by the database when documents are changed by the replicator.</p>
</div>
<div class="paragraph">
<p>A typical application will create a pair of replications (push and pull) at launch time, both pointing to the URL of a server run by the application vendor.
These stay active continuously during the lifespan of the app, uploading and downloading documents as changes occur and when the network is available.</p>
</div>
<div class="paragraph">
<p>(Of course, atypical applications can use replication differently.
The architecture is very flexible, supporting one-way replication, peer-to-peer replication, and replication between multiple devices and servers in arbitrary directed graphs.
An app might also choose to replicate only once in a while, or only with a subset of its documents.)</p>
</div>
<div class="paragraph">
<p>The application code doesn&#8217;t have to pay attention to the details: it just knows that when it makes changes to the local database they will eventually be uploaded to the server, and when changes occur on the server they will eventually be downloaded to the local database.
The app&#8217;s job is to make the UI reflect what&#8217;s in the local database, and to reflect user actions by making changes to local documents.
If it does that, replication will Just Work without much extra effort.</p>
</div>
<div class="sect2">
<h3 id="types-of-replications"><a class="anchor" href="#types-of-replications"></a>Types of replications</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Push vs Pull:</strong> A push replication uploads changes from the local database to the remote one;
a pull downloads changes from the remote database to the local one.</p>
</li>
<li>
<p><strong>One-shot vs Continuous:</strong> By default a replication runs long enough to transfer all the changes from the source to the target database, then quits.
A continuous replication, on the other hand, will stay active indefinitely, watching for further changes to occur and transferring them.</p>
</li>
<li>
<p><strong>Filtered:</strong> Replications can have filters that restrict what documents they&#8217;ll transfer.
This can be useful to limit the amount of a large remote database that&#8217;s downloaded to a device, or to keep some local documents private.
A special type of filter used with the Couchbase Sync Gateway is the set of <strong>channels</strong> that a pull replication will download from.
It&#8217;s also possible to limit a replication to an explicit set of document IDs.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="creating-replications"><a class="anchor" href="#creating-replications"></a>Creating replications</h3>
<div class="paragraph">
<p>You create a Replication object by calling the Database methods <code>createPullReplication</code> or <code>createPushReplication</code>.
Both of these take a single parameter, the URL of the remote database to sync with.
As the names imply, each method creates a replication that transfers changes in one direction only;
if you want bidirectional sync, as most apps do, you should create one of each.</p>
</div>
<div class="paragraph">
<p>Next you can customize the replication settings.
The most common change is to set the <code>continuous</code> property to <code>true</code>.
You may also need to supply authentication credentials, like a username/password or a Facebook token.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let url = NSURL(string: "https://example.com/mydatabase/")
let push = database.createPushReplication(url)
let pull = database.createPullReplication(url)
push.continuous = true
pull.continuous = true
var auth: CBLAuthenticatorProtocol?
auth = CBLAuthenticator.basicAuthenticatorWithName(username, password: password)
push.authenticator = auth
pull.authenticator = auth</code></pre>
</div>
</div>
<div class="paragraph">
<p>You will also probably want to monitor the replication&#8217;s progress, particularly because this will tell you if errors occur, but also if you want to display a progress indicator to the user.
The API for registering as an observer is platform-specific.</p>
</div>
<div class="paragraph">
<p>Once everything is set, you call start to <code>start</code> the replication.
If the replication is continuous, it&#8217;ll keep running indefinitely.
Otherwise, the replication will eventually stop when it&#8217;s transferred everything.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">NSNotificationCenter.defaultCenter().addObserver(self,
    selector: "replicationChanged", name: kCBLReplicationChangeNotification, object: push)
NSNotificationCenter.defaultCenter().addObserver(self,
    selector: "replicationChanged", name: kCBLReplicationChangeNotification, object: pull)
push.start()
pull.start()
// It's important to keep a reference to a running replication,
// or it is likely to be dealloced!
self.push = push;
self.pull = pull;
// The replications are running now; the -replicationChanged: method will
// be called with notifications when their status changes.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="filtered-replications"><a class="anchor" href="#filtered-replications"></a>Filtered replications</h3>
<div class="paragraph">
<p>You can restrict a replication to only a subset of the available documents, by writing a filter function.
There are several types of filtered replication, based on the direction and the type of server.</p>
</div>
<div class="sect3">
<h4 id="filtered-push-replications"><a class="anchor" href="#filtered-push-replications"></a>Filtered push replications</h4>
<div class="paragraph">
<p>During a push replication, the candidate documents live in your local database, so the filter function runs locally.
You define it as a native function (a block in Objective-C, an inner class method in Java), assign it a name, and register it with the Database object.
You then set the filter&#8217;s name as the <code>filter</code> property of the Replication object.</p>
</div>
<div class="paragraph">
<p>The replicator passes your filter function a SavedRevision object.
The function can examine the document&#8217;s ID and properties, and simply returns true to allow the document to be replicated, or false to prevent it from being replicated.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
The filter function will be called on the replicator&#8217;s background thread, so it should be thread-safe.
Ideally it shouldn&#8217;t reference any external state, but this isn&#8217;t strictly required.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The filter function can also be given parameters.
The parameter values are specified in the <code>Replication.filterParams</code> property as a dictionary/map, and passed to the filter function.
This way you can write a generalized filter that can be used with different replications, and also avoid referencing external state from within the function.
For example, a function could filter documents created in any year, accepting the specific year as a parameter.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">db.setFilterNamed("byOwner", asBlock: {
    (revision, params) -&gt; Bool in
        let nameParam = params["name"] as? String
        return nameParam != nil &amp;&amp; nameParam! == revision["owner"] as? String
})
//
// Set up a filtered push replication using the above filter block,
// that will push only docs whose "owner" property equals "Waldo":
var push = db.createPushReplication(url)
push.filter = "byOwner"
push.filterParams = ["name": "Waldo"]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="filtered-pull-from-sync-gateway"><a class="anchor" href="#filtered-pull-from-sync-gateway"></a>Filtered pull from Sync Gateway</h4>
<div class="paragraph">
<p>Channels are used to filter documents being pulled from the Sync Gateway.
Every document stored in a Sync Gateway database is tagged with a set of named channels by the Gateway&#8217;s app-defined sync function.
Every pull replication from the Gateway is already implicitly filtered by the set of channels that the user&#8217;s account is allowed to access;
you can filter it further by creating an array of channel names and setting it as the value of the channels property of a pull Replication.
Only documents tagged with those channels will be downloaded.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// Set up a channel-filtered pull replication that will pull only
// docs in the "sales" channel from the Sync Gateway:
var pull: CBLReplication = database.createPullReplication(url)
pull.channels = ["sales"]</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Replication properties changed after it has already started won&#8217;t have any effect.
If you wish to change replication properties such as channels, authentication, etc, you must create a new replication object using the <code>createPushReplication</code> or <code>createPullReplication</code> method.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="filtered-pull-from-couchdb-pouchdb-or-cloudant"><a class="anchor" href="#filtered-pull-from-couchdb-pouchdb-or-cloudant"></a>Filtered pull from CouchDB, PouchDB or Cloudant</h4>
<div class="paragraph">
<p>Since Couchbase Lite 1.2, filter functions in pull replications with non-Couchbase databases are no longer available.
There is an incompatibility in the way the <code>filter</code> parameter is handled in the <code>POST /{db}/_changes</code> request (see <a href="https://github.com/couchbase/couchbase-lite-ios/issues/1139">#1139</a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="filtering-by-document-ids"><a class="anchor" href="#filtering-by-document-ids"></a>Filtering by document IDs</h4>
<div class="paragraph">
<p>In one-shot <strong>pull</strong> replications with Sync Gateway, it&#8217;s possible to specify a list of document IDs (this feature is not available for replications in continuous mode, see <a href="https://github.com/couchbase/sync_gateway/issues/1703">#1703</a>).
The code below pulls the documents with ID "123" and "xyz" if they exist and the user has access to them.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let pull = database.createPullReplication(kSyncGatewayUrl)
pull.documentIDs = ["123", "xyz"]
pull.start()</code></pre>
</div>
</div>
<div class="paragraph">
<p>For <strong>push</strong> replications with Sync Gateway, this functionality is available in one-shot and continuous replications.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="observing-and-monitoring-replications"><a class="anchor" href="#observing-and-monitoring-replications"></a>Observing and monitoring replications</h3>
<div class="paragraph">
<p>Since a replication runs asynchronously, if you want to know when it completes or when it gets an error, you&#8217;ll need to register as an observer to get notifications from it.
The details of this are platform-specific.</p>
</div>
<div class="paragraph">
<p>A replication has a number of properties that you can access, especially from a notification callback, to check on its status and progress:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>status</code>: An enumeration that gives the current state of the replication.
The values are Stopped, Offline, Idle and Active.</p>
<div class="ulist">
<ul>
<li>
<p>Stopped: A one-shot replication goes into this state after all documents have been transferred or a fatal error occurs.
(Continuous replications never stop.)</p>
</li>
<li>
<p><strong>Offline</strong>: The remote server is not reachable.
Most often this happens because there&#8217;s no network connection, but it can also occur if the server&#8217;s inside an intranet or home network but the device isn&#8217;t.
(The replication will monitor the network state and will try to connect when the server becomes reachable.)</p>
</li>
<li>
<p><strong>Idle</strong>: Indicates that a continuous replication has "caught up" and transferred all documents, but is monitoring the source database for future changes.</p>
</li>
<li>
<p><strong>Active</strong>: The replication is actively working, either transferring documents or determining what needs to be transferred.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>lastError</code>: The last error encountered by the replicator.
(Not all errors are fatal, and a continuous replication will keep running even after a fatal error, by waiting and retrying later.)</p>
</li>
<li>
<p><code>completedChangesCount</code>, <code>changesCount</code>: The number of documents that have been transferred so far, and the estimated total number to transfer in order to catch up.
The ratio of these can be used to display a progress meter.
Just be aware that changesCount may be zero if the number of documents to transfer isn&#8217;t known yet, and in a continuous replication both values will reset to zero when the status goes from Idle back to Active.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">NSNotificationCenter.defaultCenter().addObserver(self,
    selector: "replicationChanged:",
    name: kCBLReplicationChangeNotification,
    object: push)
NSNotificationCenter.defaultCenter().addObserver(self,
    selector: "replicationChanged:",
    name: kCBLReplicationChangeNotification,
    object: pull)
func replicationChanged(n: NSNotification) {
    // The replication reporting the notification is n.object , but we
    // want to look at the aggregate of both the push and pull.

    // First check whether replication is currently active:
    let active = pull.status == CBLReplicationStatus.Active || push.status == CBLReplicationStatus.Active
    self.activityIndicator.state = active
    // Now show a progress indicator:
    self.progressBar.hidden = !active;
    if active {
        var progress = 0.0
        let total = push.changesCount + pull.changesCount
        let completed = push.completedChangesCount + pull.completedChangesCount
        if total &gt; 0 {
            progress = Double(completed) / Double(total);
        }
        self.progressBar.progress = progress;
    }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="detecting-unauthorized-credentials"><a class="anchor" href="#detecting-unauthorized-credentials"></a>Detecting unauthorized credentials</h4>
<div class="paragraph">
<p>The replication listener can also be used to detect when credentials are incorrect or access to Sync Gateway requires authentication.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">    ...

    NSNotificationCenter.defaultCenter().addObserver(self, selector: "changeListener:", name: kCBLReplicationChangeNotification, object: push)
    NSNotificationCenter.defaultCenter().addObserver(self, selector: "changeListener:", name: kCBLReplicationChangeNotification, object: pull)
}

func changeListener(notification: NSNotification) {
    if (push.status == CBLReplicationStatus.Active || pull.status == CBLReplicationStatus.Active) {
        print("Sync in progress")
    } else {
        let error = push.lastError ?? pull.lastError
        print("Error with code \(error?.code)")
        if error?.code == 401 {
            print("Authentication error")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="data-modeling"><a class="anchor" href="#data-modeling"></a>Data Modeling</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you&#8217;re familiar with data modeling for relational databases, you&#8217;ll notice differences in the way it is done for Couchbase Lite.</p>
</div>
<div class="paragraph">
<p>Couchbase Lite is a document database.
Unlike traditional relational databases, data is stored in documents rather than in table rows.
A document is a JSON object containing a number of key-value pairs.
Entities, and relationships between entities, are managed within the document itself.</p>
</div>
<div class="sect2">
<h3 id="the-basics"><a class="anchor" href="#the-basics"></a>The Basics</h3>
<div class="paragraph">
<p>A starting point for data modeling in Couchbase Lite is to look at a denormalized entity stored in a single document.
Consider modeling a contact record stored in a relational database in a CONTACTS table, of the form:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">ID</th>
<th class="tableblock halign-left valign-top">FIRST_NAME</th>
<th class="tableblock halign-left valign-top">LAST_NAME</th>
<th class="tableblock halign-left valign-top">EMAIL</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">John</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Smith</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">john.smith@couchbase.com</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The equivalent representation in JSON document form would be something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">{
   "id": "contact100",
   "type": "contact",
   "first_name":"John",
   "last_name ":"Smith",
   "email": "john.smith@couchbase.com"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Functionally related properties can be grouped using an embedded document.
If we wanted to store address information for our contact, it could be modeled as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">{
   "id": "contact100",
   "type": "contact",
   "first_name": "John",
   "last_name ": "Smith",
   "email": "john.smith@couchbase.com",
   "address": {
      "address_line": "123 Main Street",
      "city": "Mountain View",
      "country": "US"
   }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="one-to-many-relationships"><a class="anchor" href="#one-to-many-relationships"></a>One-to-Many Relationships</h3>
<div class="paragraph">
<p>Things get interesting when the contact record has more than one related record that we want to model.
There are two main options for modeling one-to-many relationships in a document database&#8201;&#8212;&#8201;as embedded documents, and as related documents.</p>
</div>
<div class="sect3">
<h4 id="using-embedded-documents"><a class="anchor" href="#using-embedded-documents"></a>Using Embedded Documents</h4>
<div class="paragraph">
<p>When a contact can have more than one address, the addresses would commonly be stored in a relational database using a separate ADDRESSES table:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">ID</th>
<th class="tableblock halign-left valign-top">CONTACT_ID</th>
<th class="tableblock halign-left valign-top">ADDRESS_LINE</th>
<th class="tableblock halign-left valign-top">CITY</th>
<th class="tableblock halign-left valign-top">COUNTRY</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">123 Main Street</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mountain View</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">US</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">201</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">123 Market</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">San Francisco</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">US</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>In a document database, the address information could instead be stored as an array of embedded documents within the contact document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">{
   "id": "contact100",
   "type": "contact",
   "first_name": "John",
   "last_name" : "Smith",
   "email": "john.smith@couchbase.com",
   "addresses": [
    {
      "address_line": "123 Main Street",
      "city": "Mountain View",
      "country": "US"
    },
    {
      "address_line": "123 Market",
      "city": "San Francisco",
      "country": "US"
    }
   ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The embedded document approach reduces the amount of work that your application needs to do in order to work with the Contact object&#8201;&#8212;&#8201;there is no additional query required to retrieve the embedded information.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-related-documents"><a class="anchor" href="#using-related-documents"></a>Using Related Documents</h4>
<div class="paragraph">
<p>There are scenarios where the embedded document approach isn&#8217;t ideal, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Large number of related entities.</em>
Embedding a large number of related entities results in a large document.
This can result in slower document handling, as the entire document needs to be passed around when making updates.</p>
</li>
<li>
<p><em>Concurrency.</em>
When multiple users are working on a single document, there&#8217;s a higher risk of conflicts being introduced.
Related documents can be used to isolate updates being made by different users.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The most common implementation for related documents is the belongsTo pattern.
Consider the scenario where any user can assign a task to a contact, and a contact can end up with a large number of volatile task records.
Here we define a new task document, which includes the contact key that the task record belongs to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">{
  "id": "task300",
  "type": "task",
  "contact_id": "contact100"
  "description": "Task details",
  "status": "complete"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Under this implementation, users can modify task records concurrently without introducing conflict scenarios for the related contact record.
It can also support a large number of task records per contact without impacting the size of the related contact record.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="model"><a class="anchor" href="#model"></a>Model</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Most applications use the Model/View/Controller design pattern to separate user interface and user interaction from underlying data structures and logic.
Of course, one of the responsibilities of the app&#8217;s object model is persistence.</p>
</div>
<div class="paragraph">
<p>Couchbase Lite on iOS provides support for creating model objects that persist to Couchbase Lite documents, and can be queried using Couchbase Lite queries.
You subclass the abstract class CBLModel and add your own properties, plus a very small amount of annotation that defines how those properties map to JSON in the document.</p>
</div>
<div class="sect2">
<h3 id="what-model-objects-give-you"><a class="anchor" href="#what-model-objects-give-you"></a>What model objects give you</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Native property access:</strong> Access document properties as native properties.</p>
</li>
<li>
<p><strong>Extended type support:</strong> Transparent support for common types that don&#8217;t have a JSON representation, like NSDate and NSData.
You can even represent references to other model objects.</p>
</li>
<li>
<p><strong>Mutable state:</strong> Properties can be <code>readwrite</code>, so they can be changed in memory, then later saved back to the document.</p>
</li>
<li>
<p><strong>Key-Value Observing:</strong> You can observe the value of a property and get notified when it changes.
On Mac OS X, you can also use bindings to connect properties to UI controls.</p>
</li>
<li>
<p><strong>Dynamic typing:</strong> You can use the <code>CBLModelFactory</code> to associate each model class with a document type.
You can create a hierarchy of model classes and have the appropriate subclass instantiated at runtime according to the document&#8217;s type.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="defining-model-classes"><a class="anchor" href="#defining-model-classes"></a>Defining model classes</h3>
<div class="paragraph">
<p>To create your own model class, just make it inherit from <code>CBLModel</code>.
You can create any number of model classes, and they can inherit from each other.
Each model class will correspond to a different type of persistent entity in your application.</p>
</div>
<div class="paragraph">
<p>You define persistent properties of your model classes simply by declaring Objective-C properties in its <code>@interface</code> block using the <code>@property</code> syntax.
To mark a property as persistent, in the <code>@implementation</code> block you must declare it as being <code>@dynamic</code>, as shown in the next example.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
If you forget to declare a persistent property as <code>@dynamic</code>, the compiler will automatically synthesize a regular instance variable with getter/setter methods, so your program will compile and will appear to work except that the property won&#8217;t be persistently saved to the document.
This can be hard to debug! You can have the compiler flag missing <code>@dynamic</code> declarations by enabling the "Implicit Synthesized Properties" warning in the Xcode target build settings, but if you do this you&#8217;ll also need to explicitly use <code>@synthesize</code> declarations for all synthesized properties.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">@objc(Note)
class Note: CBLModel {
    @NSManaged var message: NSString
    @NSManaged var created: NSDate
    @NSManaged var checked: Bool
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is all the code you need to write for a minimal but fully functional model class.
The name of the property is exactly the same as the name of the JSON property in the document.
If you&#8217;re defining a model class for pre-existing documents, make sure you spell the property names the same way, including capitalization and underscores.</p>
</div>
</div>
<div class="sect2">
<h3 id="types-of-properties-and-how-they-re-stored"><a class="anchor" href="#types-of-properties-and-how-they-re-stored"></a>Types of properties and how they&#8217;re stored</h3>
<div class="paragraph">
<p>CBLModel supports a pretty broad range of data types for properties, but not everything goes, and some types require special handling.
Types that can&#8217;t be directly represented in JSON&#8201;&#8212;&#8201;like dates&#8201;&#8212;&#8201;will be converted to a string representation, but will be properly converted back to the property&#8217;s native type when the model object is next read from the database.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Numeric types:</strong> All numeric types will be stored in JSON as numbers.</p>
</li>
<li>
<p><strong>Booleans:</strong> Declare boolean properties as the C99 type <code>bool</code>, not the legacy Objective-C type <code>BOOL</code>.
(Why not?
The latter is really just a typedef for <code>char</code>, so at runtime it just looks like an 8-bit integer, which means it&#8217;ll be stored in JSON as 0 or 1, not true or false.)</p>
</li>
<li>
<p><strong>NSString:</strong> Maps to a JSON string, of course.</p>
</li>
<li>
<p><strong>NSDate:</strong> JSON doesn&#8217;t have a date type, so the date will be stored as a string in the semi-standard ISO-8601 format, and parsed from that format when read in.</p>
</li>
<li>
<p><strong>NSData:</strong> JSON doesn&#8217;t support binary data, so the data will be encoded as Base64 and stored as a string.
(The size and CPU overhead of the conversion make this inefficient for large data.
Consider using an attachment instead.)</p>
</li>
<li>
<p><strong>Other CBLModel classes:</strong> You can create a one-to-one references to another model object by declaring a persistent property whose type is a CBLModel subclass.
The value will be persisted as a JSON string containing the document ID of the model object.</p>
</li>
<li>
<p><strong>NSArray:</strong> An NSArray is saved as a JSON array, with each element of the array converted to JSON according to the rules in this section.
When reading a JSON array from a document, however, it can be ambiguous what type of object to use;
there are annotations that can customize that.
See below.</p>
</li>
<li>
<p><strong>Any class implementing CBLJSONEncoding:</strong> <code>CBLJSONEncoding</code> is a protocol defined by Couchbase Lite.
Any class of yours that implements this protocol can be used as the type of a persistent property;
CBLModel will call the CBLJSONEncoding API to tell the object to convert itself to/from JSON.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If an object-valued property has a value of <code>nil</code>, its corresponding JSON property will be left out entirely when saving the document;
it will <em>not</em> be written with a JSON <code>null</code> as a value.
Similarly, any missing property in the JSON will be converted to a nil or 0 or false value.</p>
</div>
<div class="paragraph">
<p>If a JSON value read from a document has a type that&#8217;s incompatible with the corresponding model property&#8201;&#8212;&#8201;like a string when the property type is <code>int</code>&#8201;&#8212;&#8201;the model property will be set to the appropriate empty value (<code>0</code>, <code>false</code>, or <code>nil</code>).
If you need stricter type matching, you should add a validation function to the Database, to ensure that documents have the correct JSON property types.</p>
</div>
</div>
<div class="sect2">
<h3 id="cbljsonencoding"><a class="anchor" href="#cbljsonencoding"></a>CBLJSONEncoding</h3>
<div class="paragraph">
<p>A <code>CBLModel</code> always represents an entire document.
The <code>CBLJSONEncoding</code> protocol, on the other hand, can be used to represent part of a document.</p>
</div>
<div class="paragraph">
<p>If a model class indicates that one of its properties is of a custom class that implements that protocol, then the protocol&#8217;s init method will be used to construct the object from the JSON object.
Likewise, if a property value in memory is an instance of the protocol, the <code>encodeAsJSON</code> method will be used to get a JSON representation.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s consider the following document as a JSON schema:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "title": "New note",
  "user": {
    "name": "jack"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example maps that document as two native classes: the <code>Note</code> class which is the model class and the <code>User</code> class which represents the user fragment in the JSON schema.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">@objc(Note)
class Note: CBLModel {
    @NSManaged var title: String
    @NSManaged var user: User
}

@objc(User)
class User: NSObject, CBLJSONEncoding {
    var name: String = ""

    required init?(json jsonObject: Any) {
        super.init()
        guard let jsonObject = jsonObject as? [String : AnyObject] else { return }
        self.name = jsonObject["name"] as! String
    }

    func encodeAsJSON() -&gt; Any {
        return ["name": self.name]
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="array-element-types"><a class="anchor" href="#array-element-types"></a>Array element types</h3>
<div class="paragraph">
<p>The <code>NSArray</code> property type often needs special handling, to ensure that the items of JSON arrays are converted to the correct type of object.
By default, the items are simply parsed as JSON;
this breaks round-trip fidelity if you store NSDate or NSData or CBLModel objects&#8201;&#8212;&#8201;they&#8217;ll all be read back in as NSStrings.
And if you store objects implementing CBLJSONEncoding, they&#8217;ll be read back in as whatever JSON-compatible value the object encoded itself as.</p>
</div>
<div class="paragraph">
<p>To prevent this, you can specify that the items of the array property must be of a particular class.
Each item will then be converted from JSON according to the property-type rules for that class, described in the previous section.
To specify the type, implement a class method with a name of the form property name ItemClass, as in this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">@objc(Star)
class Star: CBLModel {
    @NSManaged var observationDates: NSArray // items are NSDates
    class func observationsItemClass() -&gt; AnyClass {
        return NSDate.self
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="raw-access-to-document-properties"><a class="anchor" href="#raw-access-to-document-properties"></a>Raw access to document properties</h3>
<div class="paragraph">
<p>You don&#8217;t <em>have</em> to create a native property for every document property.
It&#8217;s possible to access arbitrary document properties by name, by calling <code>-getValueOfProperty:</code> and <code>-setValue:ofProperty:</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// Let's say Note documents have a JSON property "type" that we haven't
// defined a property for. We can access it like this:
let noteType = note.getValueOfProperty("type") as String
note.setValue(noteType, ofProperty: "type")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="attachments"><a class="anchor" href="#attachments"></a>Attachments</h3>
<div class="paragraph">
<p>Model objects also support access to document attachments.
The API is very similar to that of the UnsavedRevision class: you can access attachments using the attachmentNames property and attachmentNamed method, and modify attachments using setAttachmentNamed and removeAttachmentNamed.
(Changes to attachments aren&#8217;t saved to the database until the model object is saved.)</p>
</div>
</div>
<div class="sect2">
<h3 id="instantiating-model-objects"><a class="anchor" href="#instantiating-model-objects"></a>Instantiating model objects</h3>
<div class="paragraph">
<p>Remember that every model has a one-to-one association with a document in the database.
<strong>CBLModel</strong> has no public initializer methods, and you should not implement any yourself in subclasses.</p>
</div>
<div class="paragraph">
<p>To create a new model object on a new document, use the following class method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let newNote = Note(forNewDocumentInDatabase: self.database);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In a subclass, to set up a transient state of an instance, override the <code>awakeFromInitializer</code> instance method.
This method is called when a new model is instantiating.</p>
</div>
<div class="paragraph">
<p>To instantiate the model for an existing document (or even a document that doesn&#8217;t exist yet but which you want to have a specific ID):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let doc = self.database["some-note"]
let note = Note(forDocument: doc)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>+modelForDocument:</code> method is inherited from CBLModel;
you don&#8217;t need to override it.
But it always creates an instance of the class that it&#8217;s invoked on, <code>Note</code> in the example.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is never more than one model object for a particular document.
If you call <code>+modelForDocument:</code> again on the same CBLDocument, it will return the same model object.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="custom-initialization"><a class="anchor" href="#custom-initialization"></a>Custom initialization</h4>
<div class="paragraph">
<p>If your subclass needs to initialize state when it&#8217;s created, you should create a class method with the desired parameters and call the <code>modelForDocumentInDatabase</code> class method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">class Note: CBLModel {
    @NSManaged var title: String

    class func newNoteInDatabase(database: CBLDatabase, withTitle title: String) -&gt; Note {
        let note = Note(forNewDocumentInDatabase: database)
        note.title = title
        return note
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dynamic-instantiation-using-the-model-factory"><a class="anchor" href="#dynamic-instantiation-using-the-model-factory"></a>Dynamic instantiation using the model factory</h4>
<div class="paragraph">
<p>There&#8217;s one limitation of the default mechanism of instantiating model objects: you have to know what class the model object will be before you instantiate it, since you call <code>+modelForDocument:</code> on that specific class.
This can be a problem if you have a hierarchy of model classes, and want to instantiate different subclasses for different types of documents.</p>
</div>
<div class="paragraph">
<p>For example, let&#8217;s say you have a fancy to-do list that supports not just text notes but voice notes and picture notes.
You&#8217;ve created <code>VoiceNote</code> and <code>PictureNote</code> subclasses of <code>Note</code> for these, and the documents in the database follow the convention of using a <code>"type"</code> property to identify their type, with values <code>"note"</code>, <code>"voice_note"</code> and <code>"picture_note"</code>.
Now, any time you want to instantiate a model object, it seems you&#8217;ll first have to look at the document&#8217;s <code>"type"</code> property, match the value to a <code>Note</code> class, and instantiate that class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// This is the CLUMSY and INEFFICIENT way to handle dynamic typing:
let doc = self.database["some-note"]
var note: Note?
let type = doc["type"] as? String;
if type == "note" {
    note = Note(forDocument: doc)
} else if type == "voice_note" {
    note = VoiceNote(forDocument: doc)
} else if type == "picture_note" {
    note = PictureNote(forDocument: doc)
} else {
    note = nil
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even worse, let&#8217;s say you have a model class that has a reference to a Note, i.e., a property of type <code>Note*</code>.
When resolving this property value, CBLModel will instantiate a <code>Note</code> object, even if the document&#8217;s type indicates it should be represented by a <code>VoiceNote</code> or <code>PictureNote</code>!</p>
</div>
<div class="paragraph">
<p>To solve these problems, register your model classes with the database&#8217;s ModelFactory, specifying a different <code>"type"</code> value for each one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// Do this once per launch, probably right after opening the database:
let factory = self.database.modelFactory
factory.registerClass(Note.self, forDocumentType: "note")
factory.registerClass(VoiceNote.self, forDocumentType: "voice_note")
factory.registerClass(PictureNote.self, forDocumentType: "picture_note")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once you&#8217;ve done this, you can now call <code>+modelForDocument:</code> directly on CBLModel, instead of on your subclass;
the method will look up the document&#8217;s type in the model factory to find out what class to instantiate.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// This is the clean way to handle dynamic typing:
let doc = self.database["some-note"]
let note = CBLModel(forDocument: doc) as Note</code></pre>
</div>
</div>
<div class="paragraph">
<p>This doesn&#8217;t look much different from the usual style;
but by letting CBLModel choose the class, you&#8217;ll dynamically get an object of the correct subclass (Note, VoiceNote or PictureNote) based on the <code>"type"</code> property of the individual document.
Also, when resolving a property value whose type is a model class, the factory will be used to ensure that the correct subclass is instantiated.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For this to work, you do have to make sure your model object sets the document&#8217;s "type" property appropriately!
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="saving-model-objects"><a class="anchor" href="#saving-model-objects"></a>Saving model objects</h3>
<div class="paragraph">
<p>Model objects can have mutable state: their properties can be declared <code>readwrite</code>, and their attachments can be modified.
Such changes are made only in memory, and don&#8217;t affect the underlying Document until the model object is saved.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// Toggle a note's checkbox property and save it:
note.checked = !note.checked
var error: NSError?
if !note.save(&amp;error) {
    handleError(error)
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can efficiently save all changed models at once, by calling the database&#8217;s <code>saveAllModels</code> method.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you don&#8217;t want to deal with saving manually, you can set a model object&#8217;s <code>autosaves</code> property.
When this boolean property is set, the model will automatically call <code>save:</code> shortly after its state is changed.
(The save occurs after the current thread returns back to the runloop, and only happens once even if multiple changes were made.)</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can increase the delay before the auto-save by overriding the <code>autosaveDelay</code> property, whose default value is 0, to a longer time interval.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If instead you want to undo all changes and revert the model object back to the document&#8217;s state, call <code>revertChanges</code>.</p>
</div>
<div class="paragraph">
<p>To delete the document, call <code>deleteDocument:</code>.
(Afterwards, don&#8217;t use the model object anymore;
with a deleted document it&#8217;s no longer in a useable state.)</p>
</div>
<div class="sect3">
<h4 id="customizing-saving"><a class="anchor" href="#customizing-saving"></a>Customizing saving</h4>
<div class="paragraph">
<p>If you need to do something just before a model is saved, don&#8217;t override <code>save</code>&#8201;&#8212;&#8201;it isn&#8217;t called in all cases where the model gets saved.
Instead, override <code>willSave</code>.
This is guaranteed to be called right before a save.
It&#8217;s passed a set of the names of all the modified properties, which could be useful.
Your implementation can even change property values if it wants to, for instance to update a timestamp:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">override func willSave(changedPropertyNames: NSSet!) {
    saveCount++
    lastSaveTime = NSDate()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may need a specific type of customization when deleting a model&#8217;s document: storing some information in the deleted document&#8217;s "tombstone" revision, generally for the use of the server.
To do this, override <code>propertiesToSaveForDeletion</code> and return an NSDictionary of properties.
It&#8217;s best to call the base implementation and modify the dictionary it returns:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">override func propertiesToSaveForDeletion() -&gt; [NSObject : AnyObject]! {
    var props = super.propertiesToSaveForDeletion()
    props["timestamp"] = CBLJSON.JSONObjectWithDate(NSDate())
    return props
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes you don&#8217;t want to save immediately, but you want to get the model&#8217;s current state as a JSON object, i.e., the data that <em>would</em> be saved to the document.
The <code>propertiesToSave</code> method returns this.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="peer-to-peer"><a class="anchor" href="#peer-to-peer"></a>Peer-to-Peer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Two instances of Couchbase Lite can directly sync with each other without a server (peer-to-peer).
At least one of them must use the Couchbase Lite Listener library, which enables any Couchbase Lite database to become the remote in a replication by listening on a TCP port and by exposing the standard replication endpoints on that port.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/docs-listener-diagram.png" alt="docs listener diagram">
</div>
</div>
<div class="paragraph">
<p>It becomes an alternate entry-point into the data store.
Another peer can therefore use the URL and port number in the replicator to sync data to and from the database currently listening.</p>
</div>
<div class="paragraph">
<p>Some typical Listener use cases include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Synchronizing with selected peer devices on the same LAN network.</p>
</li>
<li>
<p>Offline/online: use peer-to-peer in conjunction with Sync Gateway.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="installing-the-listener-library"><a class="anchor" href="#installing-the-listener-library"></a>Installing the Listener library</h3>
<div class="paragraph">
<p>Refer to the <a href="#installation">installation</a> section to install the Listener component.
The Couchbase Lite Listener is coupled to Couchbase Lite.
Both frameworks should always have the same release version.</p>
</div>
</div>
<div class="sect2">
<h3 id="configuring"><a class="anchor" href="#configuring"></a>Configuring</h3>
<div class="paragraph">
<p>To begin using the Listener you must create an instance by specifying a manager instance and port number.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let manager = CBLManager.sharedInstance()
self.listener = CBLListener(manager: manager, port: 55000)
self.listener.passwords = ["hello": "pw123"]
self.listener.start(nil)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Make sure to keep a reference to the listener instance in your application otherwise it may be garbage collected and unexpectedly stop listening for incoming HTTP requests.
In the example above, the listener instance is initialized as an instance property of the class.</p>
</div>
<div class="paragraph">
<p>Basic authentication is the recommended approach for protecting database access on the LAN.
The listening peer can optionally be initialized with a list of username/password pairs.
The peer that intends to run the replication must provide the same username/password <code>http://username:password@hostname:port/dbname</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="discovery"><a class="anchor" href="#discovery"></a>Discovery</h3>
<div class="paragraph">
<p>Once you have set up the Listener as an endpoint for other peers to replicate to or from, you can use different discovery methods to browse for peers and subscribe to those of interest.</p>
</div>
<div class="paragraph">
<p>This section covers two ways to discover peers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Using a QR code to encode the peer&#8217;s remote URL.</p>
</li>
<li>
<p>DNS Service Discovery (DNS-SD, aka Bonjour).</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="qr-code"><a class="anchor" href="#qr-code"></a>QR code</h4>
<div class="sect4">
<h5 id="photodrop"><a class="anchor" href="#photodrop"></a>PhotoDrop</h5>
<div class="paragraph">
<p><a href="https://github.com/couchbaselabs/photo-drop">PhotoDrop</a> is a P2P sharing app similar to the iOS AirDrop feature that you can use to send photos across devices.
The source code is available for iOS and Android.
The QR code is used for advertising an adhoc endpoint URL that a sender can scan and send photos to.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dns-sd"><a class="anchor" href="#dns-sd"></a>DNS-SD</h4>
<div class="paragraph">
<p>DNS Service Discovery is a <a href="https://www.ietf.org/rfc/rfc6763.txt">standard</a> for discovering services based on a service type.
It&#8217;s usually coupled with <a href="https://tools.ietf.org/html/rfc6762">Multicast DNS</a>, which allows devices to broadcast their existence and services on a LAN without requiring a DNS server.
These technologies are usually referred to as Bonjour, which is Apple&#8217;s name for its implementation, but they&#8217;re available under other names on most operating systems.
Android calls them Network Service Discovery.</p>
</div>
<div class="paragraph">
<p>The first step to using Bonjour for peer discovery is to advertise a service with the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Type:</strong> Bonjour can be used by many other types of devices on the LAN (printers, scanners, other apps etc).
The service type is a way to interact only with peers whose service type is the same.</p>
</li>
<li>
<p><strong>Name:</strong> A string to serve as identifier for other peers.
It should be unique for each peer.
It does not need to be human-readable.</p>
</li>
<li>
<p><strong>Port:</strong> The port number the Listener is running on.</p>
</li>
<li>
<p><strong>Metadata:</strong> Optional data that will be sent in the advertizment packets (the size limit is around 1.5KB).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To browse for peers on the network, each implementation has an asynchronous API to get notified as peers go online and offline from the network.
Given this method of device discovery is platform specific, we recommend to follow the guides below.
Once a peer device is discovered and the hostname is resolved, you can start a push and/or pull replication in the same way you would with Sync Gateway.</p>
</div>
<div class="sect4">
<h5 id="resources"><a class="anchor" href="#resources"></a>Resources</h5>
<div class="paragraph">
<p>Useful resources to work with mDNS include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Bonjour for iOS and Mac applications:</strong> The Couchbase Lite SDK exposes part of the Bonjour API for an easier integration.
The official documentation for iOS and Mac applications can be found in the <a href="https://developer.apple.com/library/mac/documentation/Networking/Conceptual/NSNetServiceProgGuide/Introduction.html">NSNetService Programming Guide</a>.</p>
</li>
<li>
<p><strong>NSD for Android applications:</strong> The de facto framework for Android is called Network Service Discovery (NSD) and is compatible with Bonjour since Android 4.1.
The official guide can be found in the <a href="https://developer.android.com/training/connect-devices-wirelessly/nsd.html">Android NSD guide</a>.</p>
</li>
<li>
<p><strong>JmDNS:</strong> Implementation in Java that can be used in Android and Java applications (<a href="https://github.com/jmdns/jmdns">official repository</a>).</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="bonjour-browsers"><a class="anchor" href="#bonjour-browsers"></a>Bonjour browsers</h5>
<div class="paragraph">
<p>Bonjour browsers are useful to monitor devices broadcasting a particular service on the LAN (<a href="http://www.macupdate.com/app/mac/13388/bonjour-browser">OS X Bonjour browser</a>, <a href="https://itunes.apple.com/gb/app/discovery-bonjour-browser/id305441017">iOS app</a>, <a href="http://hobbyistsoftware.com/bonjourbrowser">Windows browser</a>)</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="connecting"><a class="anchor" href="#connecting"></a>Connecting</h3>
<div class="paragraph">
<p>Once the IP address of another device is known you can start replicating data to or from that peer.
However, there are some good practice guidelines to follow in order to replicate the changes as they are persisted to a particular node.</p>
</div>
<div class="sect3">
<h4 id="filter-functions"><a class="anchor" href="#filter-functions"></a>Filter functions</h4>
<div class="paragraph">
<p>It may be desirable to use <a href="#filtered-replications">filtered replications</a> to replicate only the documents of interest to another peer.
Filter functions in a peer-to-peer context are executed when the start method on the replication object is called.
This is a major difference with the Sync Function available on Sync Gateway that builds the access rules when documents are saved to the Sync Gateway database.</p>
</div>
</div>
<div class="sect3">
<h4 id="port-allocation"><a class="anchor" href="#port-allocation"></a>Port allocation</h4>
<div class="paragraph">
<p>If the port number passed to the Listener is hardcoded, there is a small chance that another application may already be using it.
To avoid this scenario, specifying a value of 0 for the port in the Listener constructor will let the TCP stack pick a random available port.</p>
</div>
</div>
<div class="sect3">
<h4 id="remote-uuid"><a class="anchor" href="#remote-uuid"></a>Remote UUID</h4>
<div class="paragraph">
<p>The replication algorithm keeps track of what was last synchronized with a particular remote database.
To identify a remote, it stores a hash of the remote URL <a href="http://hostname:port/dbname" class="bare">http://hostname:port/dbname</a> and other properties such as filters, filter params etc.
In the context of peer-to-peer, the IP address will frequently change which will result in a replication starting from scratch and sending over every single document although they may have already been replicated in the past.
You can override the method of identifying a remote database using the remoteUUID property of the replicator.
If specified, it will be used in place of the remote URL for calculating the remote checkpoint in the replication process.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="security"><a class="anchor" href="#security"></a>Security</h3>
<div class="paragraph">
<p>In addition to using basic authentication, it is also possible to enable SSL over peer-to-peer connections.</p>
</div>
<div class="sect3">
<h4 id="ssl-for-peer-to-peer"><a class="anchor" href="#ssl-for-peer-to-peer"></a>SSL for Peer-to-peer</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">if !listener.setAnonymousSSLIdentityWithLabel("MyApp SSL", error: error) {
   // handle error }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Listener is now serving SSL using an automatically generated identity.</p>
</div>
<div class="sect4">
<h5 id="wait-is-this-secure"><a class="anchor" href="#wait-is-this-secure"></a>Wait, Is This Secure?</h5>
<div class="paragraph">
<p>Yes and no.
It encrypts the connection, which is unquestionably much better than not using SSL.
But unlike the usual SSL-in-a-browser approach you&#8217;re used to, it doesn&#8217;t identify the server/listener to the client.
The client has to take the cert on faith the first time it connects.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="release-notes"><a class="anchor" href="#release-notes"></a>Release Notes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="1-3-1"><a class="anchor" href="#1-3-1"></a>1.3.1</h3>
<div class="ulist">
<div class="title">Performance Improvements</div>
<ul>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1379">#1379</a> ForestDB update_seq on view query less than db&#8217;s update_seq</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Enhancements</div>
<ul>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1400">#1400</a> Support for _oidc_refresh response without ID token</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Bugs</div>
<ul>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1369">#1369</a> PSWebSocket crash iOS 10</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1379">#1379</a> ForestDB update_seq on view query less than db&#8217;s update_seq</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1387">#1387</a> TvOS Unit Test Build has a lot of warnings</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1392">#1392</a> When OIDC Refresh token failed, there is no replication change notification sent.</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1403">#1403</a> CBLSocketChangeTracker endless loop of JSON Parsing Errors</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1406">#1406</a> Encryption is a no-op with the system libsqlite3 on macOS 12</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="1-3"><a class="anchor" href="#1-3"></a>1.3</h3>
<div class="ulist">
<div class="title">Performance Improvements</div>
<ul>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1114">#1114</a> LiveQuery shouldn&#8217;t re-run query if view index didn&#8217;t change</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1150">#1150</a> Optimize &amp; animate CBLUITableController by using the Levenshtein algorithm</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1165">#1165</a> Incrementally purge oldest revisions in SQLite databases</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1242">#1242</a> Fix inefficiencies replicating docs with many revisions</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1340">#1340</a> Optimized multipart download performance</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Enhancements</div>
<ul>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/394">#394</a> Start using NSURLSession in the replicator</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/984">#984</a> Comparing CBLQuery objects</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1100">#1100</a> External property on kCBLDatabaseChangeNotification when CBL is remote</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1107">#1107</a> Logging overhaul</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1117">#1117</a> Redact passwords/tokens in URLs in log messages</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1118">#1118</a> API: Public method for inserting existing revisions (putExistingRevisionWithProperties:&#8230;&#8203;)</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1148">#1148</a> API: Make -[View updateIndex] public; add async version</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1150">#1150</a> Optimize &amp; animate CBLUITableController by using the Levenshtein algorithm</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1165">#1165</a> Incrementally purge oldest revisions in SQLite databases</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1181">#1181</a> API: Document expiration time (TTL)</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1201">#1201</a> Replicator should immediately fail if URL path is invalid</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1245">#1245</a> Expose server error messages in NSErrors from public API</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1266">#1266</a> OpenID Connect authenticator</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1271">#1271</a> Disable App Transport Security on Mac OSX LiteServ</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1291">#1291</a> Allow configuring revs_limit in LiteServ</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1334">#1334</a> Scope cookie storage by database, not by replication</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Bugs</div>
<ul>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/641">#641</a> Enumerate sequence in descending order in CBForest not working</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/966">#966</a> CBLIS : Data loss</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1005">#1005</a> Replication fails without starting on wifi if network depends on a proxy</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1015">#1015</a> Crash when [CBLRemoteRequest connection:didFailWithError:]</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1045">#1045</a> POST _bulk_docs does not support HTTPBodyStream</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1071">#1071</a> [Testfest] Items not showing up in offline mode</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1085">#1085</a> CBLIS : NSIncrementalStore accessed by multiple context dispatch queues</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1095">#1095</a> Obsolete rows left in view index when documentType is used (1.1.1)</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1106">#1106</a> CBLListener readOnly property prevents pulls from updating the database</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1120">#1120</a> Warn if map function calls emit(nil, &#8230;&#8203;)</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1124">#1124</a> Multipart Uploader cannot upload the attachment when using basic auth</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1128">#1128</a> Crash pushing docs with non-downloaded attachments</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1129">#1129</a> CBLIS: NSSet was mutated while being enumerated.</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1131">#1131</a> CBLVersion() incorrectly returns "(unofficial)" in official releases</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1132">#1132</a> CBLReplicator.isDocumentPending is inaccurate when replicator is offline</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1138">#1138</a> Continuous puller with WebSocket not responding with 401 error when changing password</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1139">#1139</a> ChangeTracker POST request are incompatible with CouchDB</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1143">#1143</a> Swift API glitches</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1152">#1152</a> CBLRestReplicator does not properly end bgTask when app is foregrounded</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1163">#1163</a> Fixed macOS 10.10 dependency &amp; updated deployment version to 10.9</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1180">#1180</a> Doc can be saved with missing attachment file, leading to errors</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1188">#1188</a> CBForest bad memory access while purging doc</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1191">#1191</a> Liteserv crashes with Forestdb option when creating local docs after delete operation</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1192">#1192</a> Manual compaction returns error if auto-compact is already running</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1200">#1200</a> Replication rejects attachments generated by PouchDB with revpos:0</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1216">#1216</a> REST API: POST /_replicate can start/stop once, but not restart?</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1228">#1228</a> One-shot push from empty db never stops</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1233">#1233</a> Failure to encrypt SQLite database when using WAL journaling</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1260">#1260</a> Inconsistent response when no conflicts are present and ?conflicts=true</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1263">#1263</a> Incorrect "error" property in REST response for GET of deleted doc</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1274">#1274</a> PendingDocumentIDs is incorrect</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1279">#1279</a> Don&#8217;t stop replicator if one doc gets an error</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1292">#1292</a> _replicate between 2 dbs on same LiteServ fails</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1323">#1323</a> Cannot push encrypted attachments when testing with ToDoLite</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1325">#1325</a> LiteServ crash when delete dbs asyncronously</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1327">#1327</a> Archive build is missing symbols in iOS frameworks</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1335">#1335</a> Database upgrades from 1.1 not copying "content_type" of attachments</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1348">#1348</a> OIDC tokens in Keychain should be per-database</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1362">#1362</a> App crashing on iOS 8.3 device</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1370">#1370</a> TodoLite showing wrong list when deleting tasks</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</article>
</main>
</div>
<footer class="footer">
  <div class="container">
    <div class="footer-links">
      <div class="col">
        <div class="footer-logo">
          <a href="https://www.couchbase.com" class="icon">
            <img src="../../_/img/logo.svg" alt="Couchbase">
          </a>
        </div>
        <div class="contact">
          <p class="address">3250 Olcott Street
Santa Clara, CA 95054
United States</p>
          <a href="https://www.couchbase.com/contact" class="btn white-btn">Contact Us</a>
          <a class="tel" href="tel:1-650-417-7500">1-650-417-7500</a>
        </div>
      </div>
      <div class="col">
        <ul>
          <li><span class="heading">Company</span></li>
          <li><a href="https://www.couchbase.com/about">About</a></li>
          <li><a href="https://www.couchbase.com/leadership">Leadership</a></li>
          <li><a href="https://www.couchbase.com/news-and-press-releases">News &amp; Press</a></li>
          <li><a href="https://www.couchbase.com/careers">Careers</a></li>
          <li><a href="https://www.couchbase.com/resources/events">Events</a></li>
          <li><a href="https://www.couchbase.com/contact">Contact Us</a></li>
          <li><a href="https://www.couchbase.com/request-pricing">Pricing</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><span class="heading">Support</span></li>
          <li><a href="https://developer.couchbase.com" target="_blank" rel="noopener">Developer Portal</a></li>
          <li><a href="https://docs.couchbase.com" target="_blank" rel="noopener">Documentation</a></li>
          <li><a href="https://forums.couchbase.com" target="_blank" rel="noopener">Forums</a></li>
          <li><a href="https://www.couchbase.com/services">Professional Services</a></li>
          <li><a href="https://support.couchbase.com" target="_blank" rel="noopener">Support Login</a></li>
          <li><a href="https://learn.couchbase.com/store" target="_blank" rel="noopener">Training</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><span class="heading">Quicklinks</span></li>
          <li><a href="https://blog.couchbase.com" target="_blank" rel="noopener">Blog</a></li>
          <li><a href="https://www.couchbase.com/downloads">Downloads</a></li>
          <li><a href="https://www.couchbase.com/get-started-developing-nosql">Get Started</a></li>
          <li><a href="https://learn.couchbase.com/store?utf8=%E2%9C%93&ss=1&ct=78327&commit=Filter" target="_blank" rel="noopener">Online Training</a></li>
          <li><a href="https://www.couchbase.com/resources">Resources</a></li>
          <li><a href="https://www.couchbase.com/nosql-resources/why-nosql">Why NoSQL</a></li>
          <li><a href="https://www.couchbase.com/resources/security">Security</a></li>
          <li><a href="https://www.couchbase.com/resources/gdpr">GDPR</a></li>
        </ul>
      </div>
      <div class="col">
        <ul class="social-icons">
          <li>
            <a href="https://www.facebook.com/Couchbase" class="icon">
              <svg width="50px" height="50px" viewBox="26.363 116.363 560.215 560.215"><path d="m586.58 209.58c0-48.96-44.252-93.212-93.212-93.212h-373.79c-48.96 0-93.212 44.252-93.212 93.212v373.79c0 48.96 44.252 93.212 93.212 93.212h186.42v-211.85h-68.732v-93.212h68.732v-36.72c0-63.083 47.077-119.58 105.45-119.58h75.323v93.212h-75.323c-8.474 0-17.889 10.357-17.889 25.422v37.662h93.212v93.212h-93.212v211.85h99.803c48.96 0 93.212-44.252 93.212-93.212v-373.79z"/></svg>
            </a>
          </li>
          <li>
            <a href="https://twitter.com/couchbase" class="icon">
              <svg width="50px" height="50px" viewBox="32.012 176.622 542.326 437.815"><path d="m574.34 227.46c-19.772 8.474-41.428 15.065-64.025 17.889 22.597-14.123 40.486-35.778 48.96-61.2-21.655 13.182-45.194 21.655-70.615 27.305-20.714-21.655-48.96-34.837-80.972-34.837-61.2 0-111.1 49.902-111.1 111.1 0 8.474 0.942 16.948 2.825 25.422-92.271-5.649-174.18-49.902-229.74-117.69-9.415 16.006-15.065 35.778-15.065 55.551 0 38.603 19.772 72.498 49.902 92.271-17.889-0.942-35.778-5.649-50.843-14.123v0.942c0 53.668 38.603 98.862 89.446 109.22-9.415 2.825-18.831 3.766-29.188 3.766-7.532 0-14.123-0.942-20.714-1.883 14.123 44.252 55.551 76.265 103.57 77.206-37.662 30.129-85.68 48.018-138.41 48.018-9.415 0-17.889-0.941-26.363-1.883 48.96 32.012 107.34 49.902 170.42 49.902 204.31 0 316.36-169.48 316.36-316.36v-14.123c21.656-14.125 40.487-33.897 55.551-56.494z"/></svg>
            </a>
          </li>
          <li>
            <a href="https://www.linkedin.com/company/couchbase" class="icon">
              <svg width="50px" height="50px" viewBox="31.071 119.188 539.537 540.443"><path d="m531.97 119.19h-461.35c-21.655 0-39.545 16.948-39.545 38.603v463.24c0 21.655 17.889 38.603 39.545 38.603h460.41c21.655 0 39.545-16.948 39.545-38.603v-463.24c0.942-21.656-16.947-38.603-38.603-38.603zm-337.07 451.94h-81.914v-243.86h81.914v243.86zm-40.486-276.81c-28.246 0-46.135-18.831-46.135-42.369s17.889-42.369 46.135-42.369 45.194 17.889 45.194 42.369c0.942 23.538-16.948 42.369-45.194 42.369zm335.19 276.81h-81.914v-129.93c0-32.954-12.24-55.551-41.428-55.551-22.597 0-35.778 15.065-41.428 30.129-1.883 5.649-2.825 12.24-2.825 19.772v136.52h-81.914s0.942-221.26 0-243.86h81.914v34.837c11.298-16.948 30.129-40.486 73.44-40.486 53.668 0 94.154 34.837 94.154 110.16l1e-3 138.41zm-168.54-208.08s0.941-0.941 0 0z"/></svg>
            </a>
          </li>
          <li>
            <a href="https://plus.google.com/+CouchbaseServer" class="icon">
              <svg width="50px" height="50px" viewBox="36.72 225.573 542.326 343.67"><path d="m209.02 363.05v68.732h93.212c-15.065 44.252-37.662 68.732-93.212 68.732-56.492 0-100.74-46.135-100.74-102.63s44.252-102.63 100.74-102.63c30.129 0 48.96 10.357 66.849 25.422 14.123-14.123 13.182-16.006 48.96-49.902-31.071-28.246-71.557-45.194-115.81-45.194-95.096-0.94-172.3 76.266-172.3 171.36s77.206 172.3 172.3 172.3c142.17 0 177.01-124.28 165.71-206.2-33.896-1e-3 -165.71-1e-3 -165.71-1e-3zm310.71 3.766v-59.317h-42.369v59.317h-61.2v42.369h61.2v61.2h42.369v-61.2h59.317v-42.369h-59.317z"/></svg>
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="footer-terms">
      <span>2018 COUCHBASE All rights reserved.</span>
      <a href="https://www.couchbase.com/privacy-policy">Privacy Policy</a>
      <a href="https://www.couchbase.com/terms-of-use">Terms of Use</a>
      <a href="https://www.couchbase.com/cookie-policy">Cookie Policy</a>
      <a href="https://info.couchbase.com/unsubscribe-or-manage-preferences.html" target="_blank" rel="noopener">Marketing Preference Center</a>
    </div>
  </div>
</footer>
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
