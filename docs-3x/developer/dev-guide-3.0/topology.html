<!DOCTYPE html><html xmlns:related-links="http://dita-ot.sourceforge.net/ns/200709/related-links" class="no-js developer-portal" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><title>Getting cluster topology — Couchbase Server 3.0/3.1</title><meta name="apple-mobile-web-app-title" content="Couchbase"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-precomposed.png"><link rel="stylesheet" href="../../assets/stylesheets/application.css"><link rel="stylesheet" href="../../assets/stylesheets/docs.css"></head><body data-modules="developer-portal-sidebar-navigation developer-portal-versions-navigation">
	<!-- Google Tag Manager -->
				<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-MVPNN2"
					height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
				<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
					new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
					j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
					'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
					})(window,document,'script','dataLayer','GTM-MVPNN2');</script>
				<!-- End Google Tag Manager -->
				<header class="developer-portal-header" role="banner"><div class="layout-wrapper"><div class="developer-portal-header__hgroup"><h1 class="developer-portal-header__logo"><a href="http://couchbase.com" rel="home">Couchbase</a></h1><p class="developer-portal-header__page-title">Couchbase Server 3.0/3.1</p></div><nav class="developer-portal-header__navigation" id="primary-navigation" role="navigation"><div class="developer-portal-header__navigation__wrapper" id="primary-navigation__wrapper"><ul class="developer-portal-header__navigation__items"><li class="developer-portal-header__navigation__item"><a href="/index.html">Documentation Home</a></li><li class="developer-portal-header__navigation__item"><a href="http://www.couchbase.com/nosql-databases/downloads">Downloads</a></li><li class="developer-portal-header__navigation__item"><a href="http://www.couchbase.com/open-source">Open Source Projects</a></li><li class="developer-portal-header__navigation__item"><a href="http://forums.couchbase.com">Forums</a></li></ul><div class="developer-portal-header__search"><script>
					  (function() {
					    var cx = '018016427239405524608:fkg1v30apnm';
					    var gcse = document.createElement('script');
					    gcse.type = 'text/javascript';
					    gcse.async = true;
					    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
					        '//www.google.com/cse/cse.js?cx=' + cx;
					    var s = document.getElementsByTagName('script')[0];
					    s.parentNode.insertBefore(gcse, s);
					  })();
					</script><gcse:search></gcse:search></div></div></nav></div></header><main class="developer-portal-global-content" role="main"><aside class="developer-portal-sidebar"><nav class="developer-portal-sidebar__navigation"><div class="developer-portal-sidebar__navigation__wrapper" id="developer-portal-sidebar-navigation"><ul><li class="section section--has-sub-sections"><a href="../../admin/Couchbase-intro.html"><span>Introduction</span></a></li><li class="section"><a href="../../admin/Whats-new-3.0.html"><span>What's new in 3.0</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/install-intro.html"><span>Installation and upgrade</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/admin-intro.html"><span>Administration</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/Views/views-intro.html"><span>Views and indexes</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/cli-intro.html"><span>CLI reference</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/rest-intro.html"><span>REST API reference</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/rel-notes/rel-notes3.0.html"><span>Release notes</span></a></li><li class="section"><a href="../../admin/pdfs.html"><span>PDFs</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/dev-guide-3.0/intro.html"><span>Overview</span></a></li><li class="section section--has-sub-sections&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;section--active"><a href="../../developer/dev-guide-3.0/concepts.html"><span>Developing applications</span></a><ul class="sub-sections"><li class="section section--has-sub-sections"><a href="../../developer/dev-guide-3.0/first-app.html"><span>Creating your first application</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/dev-guide-3.0/modeling-docs.html"><span>Modeling documents</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/dev-guide-3.0/access-data.html"><span>Accessing data with Couchbase SDKs</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/dev-guide-3.0/store-data.html"><span>Storing data</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/dev-guide-3.0/find-data.html"><span>Finding data with views</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/dev-guide-3.0/advanced-topics.html"><span>Advanced topics in development</span></a></li><li class="section section--has-sub-sections&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;section--active"><a href="../../developer/dev-guide-3.0/client-library.html"><span>Developing a client library</span></a><ul class="sub-sections"><li class="section"><a href="../../developer/dev-guide-3.0/sasl.html"><span>Providing SASL authentication</span></a></li><li class="section"><a href="../../developer/dev-guide-3.0/topology.html" class="current"><span>Getting cluster topology</span></a><ul class="sub-sections"></ul></li><li class="section"><a href="../../developer/dev-guide-3.0/observe-functions.html"><span>Providing observe functions</span></a></li><li class="section"><a href="../../developer/dev-guide-3.0/replica-read-functions.html"><span>Replica read</span></a></li><li class="section"><a href="../../developer/dev-guide-3.0/protocol-extensions.html"><span>Couchbase protocol extensions</span></a></li></ul></li></ul></li><li class="section section--has-sub-sections"><a href="../../developer/dev-guide-3.0/old-versions.html"><span>Older SDK versions</span></a></li></ul></div></nav></aside><div class="developer-portal-content"><div class="developer-portal-content__wrapper textblock__content">
	<h1 class="title topictitle1" id="ariaid-title1">Getting cluster topology</h1>

	<div class="body conbody">
		<p class="p">Your SDK will be responsible for storing keys on particular nodes; therefore your SDK needs
			to be able to retrieve current cluster topology. The way that Couchbase Server stores all
			addresses for existing keys in a cluster is by providing a vBucket map. Your SDK will need
			to request a vBucket map from Couchbase Server and maintain an open connection for
			streaming updates from the server. Couchbase Server will provide vBucket maps and updates
			as JSON. To create and maintain such a connection, you can do a REST request from your SDK,
			and Couchbase Server will send an initial vBucket Map and stream updates as needed.</p>

		<p class="p">You should provide the appropriate REST endpoints to your SDK as some initial configuration
			parameter specified in a developer’s application. The client application should bootstrap
			the REST/JSON information by building URLs discovered from a standard base URL. After
			following the bootstrapping sequence and retrieving the URL for vBucket maps, your client
			library will have a REST/JSON URL that appears as follows:</p>

		<pre class="pre codeblock"><code><samp class="ph codeph">http://HOST:PORT/pools/default/bucketsStreaming/BUCKET_NAME
</samp></code></pre>

		<p class="p">For example:</p>

		<pre class="pre codeblock"><code><samp class="ph codeph">http://couchbase1:8091/pools/default/bucketsStreaming/default
</samp></code></pre>

		<p class="p">The following is an example response from that URL, in JSON:</p>

		<pre class="pre codeblock"><code><samp class="ph codeph">{
    "name" : "default",
    "bucketType" : "couchbase",
...
    "vBucketServerMap" : {
        "hashAlgorithm" : "CRC",
        "numReplicas" : 1,
        "serverList" : ["10.1.2.14:11210"],
        "vBucketMap" : [[0,-1],[0,-1],[0,-1],[0,-1],[0,-1] : ]
   }
}
</samp></code></pre>

		<p class="p">The REST/JSON URLs might be under HTTP Basic Auth authentication control, so the client
			application may also have to provide (optional) user/password information to the your
			client library so that the proper HTTP/REST request can be made.</p>

		<p class="p">The REST/JSON URLs are ‘streaming’, in that the Couchbase Server does not close the HTTP
			REST connection after responding with one vBucket map. Instead, Couchbase Server keeps the
			connection open and continues to stream vBucket maps to your client library when there are
			cluster changes, for instance new server nodes are added, removed, or when vBuckets are
			reassigned to different servers. In the Couchbase Server streaming response, new
			vBucket-to-server map JSON messages are delimited by four newlines (“\n\n\n\n”)
			characters.</p>

		<p class="p">The above section describes what we call named-bucket REST endpoints. That is, each named
			bucket on a specified port has a streaming REST endpoint in the form:</p>

		<pre class="pre codeblock"><code><samp class="ph codeph">http://HOST:PORT/pools/default/bucketsStreaming/BUCKET_NAME
</samp></code></pre>

		<p class="p">There is another kind of REST endpoint which describes all SASL-authenticated buckets. This
			SASL-authenticated endpoint has the form of:</p>

		<pre class="pre codeblock"><code><samp class="ph codeph">http://HOST:PORT/pools/default/saslBucketsStreaming
</samp></code></pre>

		<p class="p">Sample output:</p>

		<pre class="pre codeblock"><code><samp class="ph codeph">{"buckets":[
    {"name":"default",
            "nodeLocator":"vbucket",
            "saslPassword":"",
            "nodes":[
             {"clusterMembership":"active","status":"healthy","hostname":"10.1.4.11:8091",
             "version":"1.6.1rc1","os":"x86_64-unknown-linux-gnu",
             "ports":{"proxy":11211,"direct":11210}},
             {"clusterMembership":"active","status":"healthy","hostname":"10.1.4.12:8091",
             "version":"1.6.1pre_21_g5aa2027","os":"x86_64-unknown-linux-gnu",
             "ports":{"proxy":11211,"direct":11210}}],
            "vBucketServerMap":{
            "hashAlgorithm":"CRC","numReplicas":1,
        "serverList":["10.1.4.11:11210","10.1.4.12:11210"],
        "vBucketMap":[[0,-1],[1,-1],...,[0,-1],[0,-1]]}}

 ]
        }
</samp></code></pre>

		<p class="p">One main difference between the SASL-based bucket response versus the per-bucket response
			is that the SASL-based response can describe more than one bucket in a cluster. In the SASL
			REST/JSON response, these multiple buckets would be found in the JSON response under the
			“buckets” array.</p>

		<p class="p"></p>

		<section class="section"><h2 class="title sectiontitle">Parsing the JSON</h2><p class="p">Once your client library has received a complete
				vBucket-to-server map message, it should use its favorite JSON parser to process the map
				into more useful data structures. An implementation of this kind of JSON parsing in C
				exists as a helper library in <a class="xref" href="http://github.com/membase/libvbucket" target="_blank">libvbucket</a>, or for Java, <a class="xref" href="http://github.com/membase/jvbucket" target="_blank">jvbucket</a>.</p>
<p class="p">The <samp class="ph codeph">libvbucket</samp> and <samp class="ph codeph">jvbucket</samp>
				helper libraries don’t do any connection creation, socket management, protocol
				serialization, etc. That’s the job of your higher-level library. These helper libraries
				instead just know how to parse a JSON vBucket-to-server map and provide an API to access
				the map
				information.</p>
<p class="p"></p>
</section>

		<section class="section"><h2 class="title sectiontitle">Handling vBucketMap information</h2><p class="p">The <samp class="ph codeph">vBucketMap</samp>
				value within the returned JSON describes the vBucket organization. For
				example:</p>
<pre class="pre codeblock"><code><samp class="ph codeph">"serverList":["10.1.4.11:11210","10.1.4.12:11210"], "vBucketMap":[[0,1],[1,0],[1,0],[1,0],:,[0,1],[0,1]]
</samp></code></pre>
<p class="p">The
				vBucketMap is zero-based indexed by vBucketId. So, if you have a vBucket whose vBucketId
				is 4, you’d look up vBucketMap[4]. The entries in the vBucketMap are arrays of integers,
				where each integer is a zero-based index into the serverList array. The 0th entry in
				this array describes the primary server for a vBucket. Here’s how you read this stuff,
				based on the above config:</p>
<p class="p">The vBucket with vBucketId of 0 has a configuration of
					<samp class="ph codeph">vBucketMap[0]</samp>, or <samp class="ph codeph">[0, 1]</samp>. So vBucket 0’s primary
				server is at <samp class="ph codeph">serverList[0]</samp>, or
				<samp class="ph codeph">10.1.4.11:11210</samp>.</p>
<p class="p">While vBucket 0’s first replica server is at
					<samp class="ph codeph">serverList[1]</samp>, which is <samp class="ph codeph">10.1.4.12:11210</samp>.</p>
<p class="p">The
				vBucket with vBucketId of 1 has a configuration of <samp class="ph codeph">vBucketMap[1]</samp>, or
					<samp class="ph codeph">[1, 0]</samp>. So vBucket 1’s primary server is at
					<samp class="ph codeph">serverList[1]</samp>, or <samp class="ph codeph">10.1.4.12:11210</samp>. And vBucket 1’s
				first replica is at <samp class="ph codeph">serverList[0]</samp>, or
				<samp class="ph codeph">10.1.4.11:11210</samp>.</p>
<p class="p">This structure and information repeats for every
				configured vBucket.</p>
<p class="p">If you see a -1 value, it means that there is no server yet at
				that position. That is, you might
				see:</p>
<pre class="pre codeblock"><code><samp class="ph codeph">"vBucketMap":[[0,-1],[0,-1],[0,-1],[0,-1],:]
</samp></code></pre>
<p class="p">Sometimes
				early before the system has been completely configured, you might see variations
				of:</p>
<pre class="pre codeblock"><code><samp class="ph codeph">"serverList":[], "vBucketMap":[]
</samp></code></pre>
<p class="p"></p>
</section>

		<section class="section"><h2 class="title sectiontitle">Encoding the vBucketId</h2><p class="p">As the user’s application makes item data API
				invocations on your client library (mc.get(“some_key”), mc.delete(“some_key”), your
				client library will hash the key (“some_key”) into a vBucketId. Your client library must
				also encode a binary request message (following <samp class="ph codeph">memcached</samp> binary
				protocol), but also also needs to include the vBucketId as part of that binary request
				message.</p>

			<div class="note note"><span class="notetitle">Note:</span> Python-aware readers might look at this implementation for an <a class="xref" href="http://github.com/membase/ep-engine/blob/master/management/mc_bin_client.py" target="_blank">example</a>.</div>
<p class="p">Each Couchbase Server will
				double-check the vBucketId as it processes requests, and would return NOT_MY_VBUCKET
				error responses if your client library provided the wrong vBucketId to the wrong
				couchbase server. This mismatch is expected in the normal course of the lifetime of a
				cluster – especially when the cluster is changing configuration, such as during a
				Rebalance.</p>
<p class="p"></p>
</section>

		<section class="section"><h2 class="title sectiontitle">Handling rebalances in your client library</h2><p class="p">A major operation in a
				cluster of Couchbase servers is rebalancing. A Couchbase system administrator may choose
				to initiate a rebalance because new servers might have been added, old servers need to
				be decommissioned and need to be removed, etc. An underlying part of rebalancing is the
				controlled migration of vBuckets (and the items in those migrating vBuckets) from one
				Couchbase server to another.</p>
<p class="p">There is a certain amount of time, given the
				distributed nature of couchbase servers and clients, where vBuckets ownership may have
				changed and migrated from one server to another server, but your client library has not
				been informed. So, your client library could be trying to talk to the ‘wrong’ or
				outdated server for a given item, since your client library is operating with an
				out-of-date vBucket-to-server map.</p>
<p class="p">Below is a walk-through of this situation in
				more detail and how to handle this case:</p>
<p class="p">Before the Rebalance starts, any
				existing, connected clients should be operating with the cluster’s pre-rebalance
				vBucket-to-server map.</p>
<p class="p">As soon as the rebalance starts, Couchbase will “broadcast”
				(via the streaming REST/JSON channels) a slightly updated vBucket-to-server map message.
				The assignment of vBuckets to servers does not change at this point at the start of the
				rebalance, but the serverList of all the servers in the Couchbase cluster does change.
				That is, vBuckets have not yet moved (or are just starting to move), but now your client
				library knows the addresses of any new couchbase servers that are now part of the
				cluster. Knowing all the servers in the cluster (including all the newly added servers)
				is important, as you will soon see.</p>
<p class="p">At this point, the Couchbase cluster will be
				busy migrating vBuckets from one server to another.</p>
<p class="p">Concurrently, your client
				library will be trying to do item data operations (Get/Set/Delete’s) using its
				pre-Rebalance vBucket-to-server map. However, some vBuckets might have been migrated to
				a new server already. In this case, the server your client library was trying to use
				will return a NOT_MY_VBUCKET error response.</p>
<p class="p">Your client library should handle
				that NOT_MY_VBUCKET error response by retrying the request against another server in the
				cluster. The retry, of course, might fail with another NOT_MY_VBUCKET error response, in
				which your client library should keep probing against another server in the
				cluster.</p>
<p class="p">Eventually, one server will respond with success, and your client library
				has then independently discovered the new, correct owner of that vBucketId. Your client
				library should record that knowledge in its vBucket-server-map(s) for use in future
				operations time.</p>
<p class="p">An implementation of this can be seen in the libvBucket API
					<samp class="ph codeph">vbucket_found_incorrect_master()</samp>.</p>
<p class="p">The following shows a
				swim-lane diagram of how moxi interacts with libvBucket during NOT_MY_VBUCKET errors
					<a class="xref" href="http://www.couchbase.com/wiki/download/attachments/3342379/libvbucket_notmyvbucket.pdf?version=2&amp;modificationDate=1289323788000" target="_blank">libvbucket_notmyvbucket.pdf</a>.</p>
<p class="p">At the end of
				the Rebalance, the couchbase cluster will notify streaming REST/JSON clients, finally,
				with a new vBucket-to-server map. This can be handled by your client library like any
				other vBucket-to-server map update message. However, in the meantime, your client
				library didn’t require granular map updates during the Rebalancing, but found the
				correct vBucket owners on its
				own.</p>
<p class="p"></p>
</section>

		<section class="section"><h2 class="title sectiontitle">Fast forward map</h2><p class="p">A planned, forthcoming improvement to the above
				NOT_MY_VBUCKET handling approach is that Couchbase will soon send an optional second map
				during the start of the Rebalance. This second map, called a “fast forward map”,
				provides the final vBucket-to-server map that would represent the cluster at the end of
				the Rebalance. A client library can use the optional fast forward map during
				NOT_MY_VBUCKET errors to avoid linear probing of all servers and can instead just jump
				straight to talking with the eventual vBucket owner.</p>
<p class="p">Please see the implementation
				in <a class="xref" href="http://github.com/membase/libvbucket/blob/master/tests/testapp.c#L67" target="_blank">libvBucket</a> that handles a
				fast-forward-map.</p>
<p class="p">The linear probing, however, should be retained by client
				library implementations as a good fallback, just-in-case error handling
				codepath.</p>
<p class="p"></p>
</section>

		<section class="section"><h2 class="title sectiontitle">Redundancy and availability</h2><p class="p">Client library authors should enable
				their user applications to specify multiple URLs into the Couchbase cluster for
				redundancy. Ideally, the user application would specify an odd number of URLs, and the
				client library should compare responses from every REST/JSON URL until is sees a
				majority of equivalent cluster configuration responses. With an even number of URLs
				which provide conflicting cluster configurations (such as when there’s only two
				couchbase servers in the cluster and there’s a split-brain issue), the client library
				should provide an error to the user application rather than attempting to access items
				from wrong nodes (nodes that have been Failover’ed out of the cluster).</p>
<p class="p">The
				libvBucket C library has an API for comparing two configurations to support these kinds
				of comparisons. See the <a class="xref" href="http://github.com/membase/libvbucket/blob/master/include/libvbucket/vbucket.h" target="_blank">vbucket_compare() function</a>.</p>
<p class="p">As an
				advanced option, the client library should keep multiple REST/JSON streams open and do
				continual “majority vote” comparisons between streamed configurations when there are
				re-configuration events.</p>
<p class="p">As an advanced option, the client library should “learn”
				about multiple cluster nodes from its REST/JSON responses. For example, the user may
				have specified just one URL into a multi-node cluster. The REST/JSON response from that
				one node will list all other nodes, which the client library can optionally, separately
				contact. This allows the client library to proceed even if the first URL/node fails (as
				long as the client library continues running).</p>
</section>

	</div>

	
<nav class="related-links"><h2>Related information</h2>
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="../../developer/dev-guide-3.0/client-library.html">Developing a client library</a></div>
<div class="previouslink"><strong>Previous topic:</strong> <a class="link" href="../../developer/dev-guide-3.0/sasl.html">Providing SASL authentication</a></div>
<div class="nextlink"><strong>Next topic:</strong> <a class="link" href="../../developer/dev-guide-3.0/observe-functions.html">Providing observe functions</a></div>
</div>
</nav></div><footer class="developer-portal-footer" role="contentinfo"><p class="legal"><span class="license">© 2011–2015 <b class="company-name">Couchbase</b>. All rights reserved.</span><a href="http://support.couchbase.com/">Customer Login</a><a href="http://www.couchbase.com/terms-of-service">Terms of Service</a><a href="http://www.couchbase.com/privacy-policy">Privacy Policy</a></p></footer></div></main><script src="../../assets/javascripts/vendor/prism.js"></script><script type="text/javascript">var BASEPATH='../../';</script><script src="../../assets/javascripts/init.js"></script><script type="text/javascript" src="https://issues.couchbase.com/s/en_US-pvmaib-418945332/845/131/1.2.9/_/download/batch/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector.js?collectorId=86389172"></script></body></html>