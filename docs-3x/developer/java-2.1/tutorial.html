<!DOCTYPE html><html xmlns:related-links="http://dita-ot.sourceforge.net/ns/200709/related-links" class="no-js developer-portal" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><title>Java SDK tutorial — Couchbase Server 3.0/3.1</title><meta name="apple-mobile-web-app-title" content="Couchbase"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-precomposed.png"><link rel="stylesheet" href="../../assets/stylesheets/application.css"><link rel="stylesheet" href="../../assets/stylesheets/docs.css"></head><body data-modules="developer-portal-sidebar-navigation developer-portal-versions-navigation">
	<!-- Google Tag Manager -->
				<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-MVPNN2"
					height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
				<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
					new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
					j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
					'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
					})(window,document,'script','dataLayer','GTM-MVPNN2');</script>
				<!-- End Google Tag Manager -->
				<header class="developer-portal-header" role="banner"><div class="layout-wrapper"><div class="developer-portal-header__hgroup"><h1 class="developer-portal-header__logo"><a href="http://couchbase.com" rel="home">Couchbase</a></h1><p class="developer-portal-header__page-title">Couchbase Server 3.0/3.1</p></div><nav class="developer-portal-header__navigation" id="primary-navigation" role="navigation"><div class="developer-portal-header__navigation__wrapper" id="primary-navigation__wrapper"><ul class="developer-portal-header__navigation__items"><li class="developer-portal-header__navigation__item"><a href="/index.html">Documentation Home</a></li><li class="developer-portal-header__navigation__item"><a href="http://www.couchbase.com/nosql-databases/downloads">Downloads</a></li><li class="developer-portal-header__navigation__item"><a href="http://www.couchbase.com/open-source">Open Source Projects</a></li><li class="developer-portal-header__navigation__item"><a href="http://forums.couchbase.com">Forums</a></li></ul><div class="developer-portal-header__search"><script>
					  (function() {
					    var cx = '018016427239405524608:fkg1v30apnm';
					    var gcse = document.createElement('script');
					    gcse.type = 'text/javascript';
					    gcse.async = true;
					    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
					        '//www.google.com/cse/cse.js?cx=' + cx;
					    var s = document.getElementsByTagName('script')[0];
					    s.parentNode.insertBefore(gcse, s);
					  })();
					</script><gcse:search></gcse:search></div></div></nav></div></header><main class="developer-portal-global-content" role="main"><aside class="developer-portal-sidebar"><nav class="developer-portal-sidebar__navigation"><div class="developer-portal-sidebar__navigation__wrapper" id="developer-portal-sidebar-navigation"><ul><li class="section section--has-sub-sections"><a href="../../admin/Couchbase-intro.html"><span>Introduction</span></a></li><li class="section"><a href="../../admin/Whats-new-3.0.html"><span>What's new in 3.0</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/install-intro.html"><span>Installation and upgrade</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/admin-intro.html"><span>Administration</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/Views/views-intro.html"><span>Views and indexes</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/cli-intro.html"><span>CLI reference</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/rest-intro.html"><span>REST API reference</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/rel-notes/rel-notes3.0.html"><span>Release notes</span></a></li><li class="section"><a href="../../admin/pdfs.html"><span>PDFs</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/dev-guide-3.0/intro.html"><span>Overview</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/dev-guide-3.0/concepts.html"><span>Developing applications</span></a></li><li class="section section--has-sub-sections&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;section--active"><a href="../../developer/dev-guide-3.0/old-versions.html"><span>Older SDK versions</span></a><ul class="sub-sections"><li class="section section--has-sub-sections&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;section--active"><a href="../../developer/java-2.1/java-intro.html"><span>Java SDK 2.1</span></a><ul class="sub-sections"><li class="section"><a href="../../developer/java-2.1/overview.html"><span>Overview</span></a></li><li class="section"><a href="../../developer/java-2.1/download-links.html"><span>Download and API Reference</span></a></li><li class="section"><a href="../../developer/java-2.1/migrate.html"><span>Migrating from Java SDK 1.4.x to 2.x</span></a></li><li class="section section--has-sub-sections&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;section--active"><a href="../../developer/java-2.1/getting-started.html"><span>Getting started with the Java SDK</span></a><ul class="sub-sections"><li class="section"><a href="../../developer/java-2.1/hello-couchbase.html"><span>Hello Couchbase Example</span></a></li><li class="section"><a href="../../developer/java-2.1/tutorial.html" class="current"><span>Java SDK tutorial</span></a><ul class="sub-sections"></ul></li></ul></li><li class="section"><a href="../../developer/java-2.1/managing-connections.html"><span>Managing connections</span></a></li><li class="section"><a href="../../developer/java-2.1/env-config.html"><span>Configuring the environment</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/java-2.1/documents.html"><span>Working with documents</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/java-2.1/querying.html"><span>Querying buckets</span></a></li><li class="section"><a href="../../developer/java-2.1/observables.html"><span>Mastering observables</span></a></li><li class="section"><a href="../../developer/java-2.1/logging.html"><span>Setting up logging</span></a></li><li class="section"><a href="../../developer/java-2.1/release-notes.html"><span>Release notes</span></a></li></ul></li><li class="section section--has-sub-sections"><a href="../../developer/java-2.0/java-intro.html"><span>Java SDK 2.0</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/dotnet-2.1/dotnet-intro.html"><span>.NET SDK 2.1</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/dotnet-2.0/dotnet-intro.html"><span>.NET SDK 2.0</span></a></li></ul></li></ul></div></nav></aside><div class="developer-portal-content"><div class="developer-portal-content__wrapper textblock__content">
	<h1 class="title topictitle1" id="ariaid-title1">Java SDK tutorial</h1>

	
	<div class="body conbody"><p class="shortdesc">The Java SDK tutorial introduces some advanced concepts by walking through a complete
		web application.</p>


		<section class="section">
			<p class="p">The full source code for the tutorial is available<a class="xref" href="https://github.com/couchbaselabs/beersample-java2" target="_blank"> on GitHub</a>. The primary focus of the tutorial is to explain
				the function and theory connected to the Couchbase Java client and how it connects
				to Couchbase server. The code that generates the web application is provided with
				the source code but is not discussed in this tutorial.</p>

		</section>


		<section class="section"><h2 class="title sectiontitle">Preview the application</h2>
			
			<p class="p">The complete working source is in the master branch <a class="xref" href="https://github.com/couchbaselabs/beersample-java2" target="_blank">on GitHub</a>. To build from source and preview the application,
				clone the repository and run the following shell commands from the repository
				folder:</p>

			<pre class="pre codeblock language-bash"><code>mvn clean package
cd target
java -jar beersample-java2.jar</code></pre>

			<p class="p">You should see the Spring framework start up and begin logging the application. After it has
				finished initializing, you can navigate to <a class="xref" href="http://localhost:8080/">http://localhost:8080/</a> and view the application or use a
				tool like <samp class="ph codeph">curl</samp> or <samp class="ph codeph">postman</samp> to use all REST
				endpoints described in <a class="xref" href="https://github.com/couchbaselabs/beersample-java2#rest-api" target="_blank">the README</a> file.</p>

		</section>

		<section class="section"><h2 class="title sectiontitle">Preparation</h2>
			<p class="p">To get ready to build your first app, you need to install
				Couchbase Server, create a view, and set up your development environment (IDE).</p>

			<strong class="ph b">Installing Couchbase Server</strong>
			<p class="p">Download <a class="xref" href="http://www.couchbase.com/download" target="_blank">Couchbase Server</a> and install it. As you follow the download
				instructions and setup wizard, make sure you install the sample bucket named
					<samp class="ph codeph">beer-sample</samp> because it contains the beer and brewery data used
				in this tutorial.</p>
<p class="p">If you already have Couchbase Server installed but did not
				install the <samp class="ph codeph">beer-sample</samp> bucket, open the Couchbase Web Console and
				select <span class="ph menucascade"><span class="ph uicontrol">Settings</span> &gt; <span class="ph uicontrol">Sample Buckets</span></span>. Select the <samp class="ph codeph">beer-sample</samp> check box, and then click
					<span class="ph uicontrol">Create</span>. A notification box in the upper-right corner
				disappears when the bucket is ready to use.</p>

			<strong class="ph b">Creating a view</strong>
			<p class="p">Views enable you to index and query data from your database. The
					<samp class="ph codeph">beer-sample</samp> bucket comes with a small set of predefined view
				functions, but to add further functionality to the application you need to add an
				additional view. Adding a view offers a very good chance for you to see how you can
				manage views inside the Couchbase Web Console. </p>
<p class="p">We want our users to be able
				to view a list of both beers and breweries. Therefore, we need to define one view
				function for each type of document that will respond with the relevant information
				for each query. As such we will be creating one view function for beers: </p>

			<ol class="ol">
				<li class="li">In Couchbase Web Console, click <span class="ph uicontrol">Views</span>.</li>

				<li class="li">From the drop-down list of bucket names, choose the
						<span class="ph uicontrol">beer-sample</span> bucket.<p class="p">You should see a design
						document named <samp class="ph codeph">_design/beer</samp> that has some views already
						defined (<samp class="ph codeph">brewery_beers</samp> and <samp class="ph codeph">by_location</samp>).
						If you do not see the views, make sure that Production Views is selected.
						You can toggle between Development Views and Production Views by clicking
						the buttons at the top of the list.</p>
</li>

				<li class="li">Click <span class="ph uicontrol">Copy to Dev</span>, and then in the Copy Design Document
					window click <span class="ph uicontrol">Copy</span>.<p class="p">You are now looking at the
						Development Views version of the <samp class="ph codeph">_design/dev_beer</samp> design
						document, where you can add new views or make changes to existing views in
						the design document.</p>
</li>

				<li class="li">Click <span class="ph uicontrol">Add View</span>.</li>

				<li class="li">In the Create Development View window, enter the following names for the design
					document and the view:<ul class="ul">
						<li class="li">Design Document Name: <samp class="ph codeph">_design/dev_beer</samp></li>

						<li class="li">View Name: <samp class="ph codeph">by_name</samp></li>

					</ul>

				</li>

				<li class="li">Click the <span class="ph uicontrol">Edit</span> button for the <samp class="ph codeph">by_name</samp>
						view.<p class="p">You are now in the view editor, where you can see sample documents
						and edit map and reduce functions.</p>
</li>

				<li class="li">Under View Code, insert the following JavaScript map function and click
						<span class="ph uicontrol">Save</span>:<pre class="pre codeblock language-javascript"><code>function (doc, meta) {
   if(doc.type &amp;&amp; doc.type == "beer") {
	 emit(doc.name, doc.brewery_id);
   }
}</code></pre>
</li>

			</ol>

			<p class="p">Every <samp class="ph codeph">map</samp> function takes the full document (<samp class="ph codeph">doc</samp>)
				and its associated metadata (<samp class="ph codeph">meta</samp>) as the arguments. Your map
				function can then inspect this data and <samp class="ph codeph">emit</samp> the item to a result
				set to be added to an index. In this case, the name of the beer
					(<samp class="ph codeph">doc.name</samp>) is emitted when the document has a type field, and
				the type is <samp class="ph codeph">beer</samp>. We also want to use the brewery associated with
				the beer, so for our value we will emit the <samp class="ph codeph">doc.brewery_id</samp>.
				</p>
<p class="p">In general, you should try to keep the index as small as possible. You should
				resist the urge to include the full document with <samp class="ph codeph">emit(meta.id,
					doc)</samp> because that increases the size of your view indexes and
				potentially impacts application performance. If you need to access the full document
				or large parts of it, use the <samp class="ph codeph">.document()</samp> method, which does a
					<samp class="ph codeph">get()</samp> call with the document ID in the background.</p>
 At this
			point, you could also add a reduce function to perform further computation on the index
			results. This example does not use <samp class="ph codeph">reduce</samp> functions, but you can play
			around with <samp class="ph codeph">reduce</samp> functions to see how they work. <p class="p">The final step is
				to push the design documents to production mode for Couchbase Server. While the
				design documents are in development mode, the index is applied only on the local
				node. For more information about design document modes, see <a class="xref" href="http://docs.couchbase.com/admin/admin/Views/views-development.html" target="_blank">Development views</a> and <a class="xref" href="http://docs.couchbase.com/admin/admin/Views/views-production.html" target="_blank">Production views</a>.</p>
<p class="p">To have the index
				on the whole data set, you need to publish the design documents to move them into
				production mode: </p>
<ol class="ol">
				<li class="li">In Couchbase Web Console, click <span class="ph uicontrol">Views</span>.</li>

				<li class="li">Click the <span class="ph uicontrol">Publish</span> button on the design document.</li>

				<li class="li">Accept any dialog that warns you about overriding the old view function (since
					you copied them).</li>

			</ol>
<p class="p">For more information about using views for indexing and querying from Couchbase
				Server, see the following resources: </p>
<ul class="ul">
				<li class="li">General Information about views: <a class="xref" href="http://docs.couchbase.com/admin/admin/Views/views-intro.html" target="_blank">Views and indexes</a>
				</li>

				<li class="li">Examples and patterns you can use for views, including patterns for extracting
					information based on date or time: <a class="xref" href="http://docs.couchbase.com/admin/admin/Views/views-querySample.html" target="_blank">View and query pattern samples</a></li>

			</ul>

			<strong class="ph b">Setting up your IDE</strong>
			<p class="p">This project makes heavy use of <a class="xref" href="http://maven.apache.org/" target="_blank">Maven</a> for dependency management, so you
				should familiarize yourself with using Maven for your chosen IDE or from the command
				line. Here is the <span class="ph filepath">pom.xml</span> that you can use for full dependency
				management (included in the example application):</p>

			<pre class="pre codeblock language-xml"><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

	&lt;groupId&gt;com.couchbase&lt;/groupId&gt;
	&lt;artifactId&gt;beersample2&lt;/artifactId&gt;
	&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

	&lt;parent&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
		&lt;version&gt;1.1.9.RELEASE&lt;/version&gt;
	&lt;/parent&gt;

	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;com.couchbase.client&lt;/groupId&gt;
			&lt;artifactId&gt;java-client&lt;/artifactId&gt;
			&lt;version&gt;2.1.6&lt;/version&gt;

		&lt;/dependency&gt;
	&lt;/dependencies&gt;

	&lt;build&gt;
		&lt;finalName&gt;beersample-java2&lt;/finalName&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
				&lt;version&gt;3.1&lt;/version&gt;
				&lt;configuration&gt;
					&lt;source&gt;1.6&lt;/source&gt;
					&lt;target&gt;1.6&lt;/target&gt;
				&lt;/configuration&gt;
			&lt;/plugin&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
				&lt;executions&gt;
					&lt;execution&gt;
						&lt;goals&gt;
							&lt;goal&gt;repackage&lt;/goal&gt;
						&lt;/goals&gt;
					&lt;/execution&gt;
				&lt;/executions&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;
&lt;/project&gt;
</code></pre>

			<p class="p">For reference, here is the directory structure used for this example application:</p>

			<pre class="pre codeblock language-java"><code>
├── src
│&nbsp;&nbsp; └── main
│&nbsp;&nbsp;	 ├── java
│&nbsp;&nbsp;	 │&nbsp;&nbsp; └── com
│&nbsp;&nbsp;	 │&nbsp;&nbsp;	 └── couchbase
│&nbsp;&nbsp;	 │&nbsp;&nbsp;		 └── beersample
│&nbsp;&nbsp;	 │&nbsp;&nbsp;			 ├── beers
│&nbsp;&nbsp;	 │&nbsp;&nbsp;			 ├── breweries
│&nbsp;&nbsp;	 │&nbsp;&nbsp;			 └── config
│&nbsp;&nbsp;	 └── resources
│&nbsp;&nbsp;		 └── public
└── target
</code></pre>

			<strong class="ph b">Download the framework</strong>
			<p class="p">The framework/stub for the tutorial can be downloaded from <a class="xref" href="https://github.com/couchbaselabs/beersample-java2/tree/tutorialStub" target="_blank">github</a>. It includes the <a class="xref" href="http://projects.spring.io/spring-boot/#quick-start" target="_blank">Spring Boot</a> application framework and the surrounding code
				that takes our Couchbase connections and forms a complete application. The next
				section of the tutorial explains the inner workings of the
					<span class="keyword apiname">CouchbaseService</span> class, currently blank, that deals with the
				applications connections with your Couchbase server and implements key data-related
				methods.</p>
<p class="p">The best way to go is to clone the repository and use the
					<samp class="ph codeph">tutorialStub</samp> branch:</p>
<pre class="pre codeblock language-shell"><code>git clone https://github.com/couchbaselabs/beersample-java2.git
cd beersample-java2
git checkout tutorialStub				</code></pre>
<p class="p">You can then import the project as a Maven project in
				your favorite IDE and start filling in the blanks in
					<span class="keyword apiname">CouchbaseService</span>. </p>
</section>


		<section class="section"><h2 class="title sectiontitle">Couchbase service</h2>
			
			<p class="p">The primary focus of this tutorial is the <span class="keyword apiname">CouchbaseService</span> class
				located in the <span class="ph filepath">src/main/java/com/couchbase/beersample</span> directory.
				The class is responsible for dealing with all interactions between the application and
				the Couchbase server. The constructor and <span class="keyword apiname">preDestroy()</span> method are the
				part of the class that deals with connecting to and disconnecting from Couchbase.</p>

			<p class="p">The application is parameterized through the
					<span class="ph filepath">src/main/resources/application.yml</span> configuration file, which
				gets injected by Spring Boot into the <span class="keyword apiname">Database</span> class. You need to
				customize this to your cluster setup and use the configuration for connection.</p>

			<p class="p">Try to implement them and compare with the code extract below:</p>

			<pre class="pre codeblock language-java"><code>@Service
public class CouchbaseService {

	private final Database config;

	private final Bucket bucket;
	private final Cluster cluster;

	@Autowired
	public CouchbaseService(final Database config) {
		this.config = config;

		//connect to the cluster and open the configured bucket
		this.cluster = CouchbaseCluster.create(config.getNodes());
		this.bucket = cluster.openBucket(config.getBucket(), config.getPassword());
	}

	@PreDestroy
	public void preDestroy() {
		if (this.cluster != null) {
			this.cluster.disconnect();
		}
	}
}</code></pre>


			<p class="p">It is important to reuse the Couchbase connections so that the underlying resources are
				not duplicated for each connection. Here the <samp class="ph codeph">@Service</samp> annotation
				ensures that the Spring framework creates only one instance of the class. The important
				message is that you only create one connection to the Couchbase cluster and one
				connection to each bucket you are using, then statically reference those connections for
				each use.</p>


			<p class="p">The line <samp class="ph codeph">this.cluster = CouchbaseCluster.create(config.getNodes());</samp> creates a
				new Couchbase connection object and makes the initial connection to the cluster. In
				this example, we supply a list of IP addresses obtained from the
					<span class="keyword apiname">Database</span> configuration object, populated by Spring Boot with
				the contents of the <samp class="ph codeph">application.yml</samp> file. You can supply a string,
				or several strings concatenated with commas so that it can fall back to another node
				should a connection to a single node fail.</p>


			<p class="p">Next, connect to the bucket that is storing the data, in this case, the <strong class="ph b">beer-sample</strong>
				bucket provided as part of your Couchbase installation. As with connecting to the
				cluster, it is important to create a single connection and reuse it multiple times
				throughout your code. The line <samp class="ph codeph">this.bucket = cluster.openBucket
					(config.getBucket(), config.getPassword());</samp> creates a connection to the
				bucket defined in the configuration. The Couchbase Java SDK provides both
				synchronous and asynchronous APIs that allow you to harness easily the power of
				asynchronous computation while maintaining the simplicity of synchronous operations.
				In this case, we are choosing to connect to both the cluster and the bucket
				synchronously as most of our application will be required to be synchronous, loading
				data before a web page can be generated. However, the asynchronous API is explained
				later on for use in creating view queries.</p>


			<p class="p">The disconnect method is included even though it is not explicitly called in this
				example. Spring framework will invoke the method annotated with
					<samp class="ph codeph">PreDestroy</samp> when destroying the context and shutting down the
				application.</p>


			<p class="p">Now that we have dealt with connecting to the cluster and the bucket we can move onto
				completing some useful operations, beginning with querying the database for a single
				document. We will be using the following code, which connects to the Couchbase server,
				searches for a given key identifier, and returns the associated
					<samp class="ph codeph">JsonDocument</samp>.</p>

			<pre class="pre codeblock language-java"><code>/**
* READ the document from database
*/
public JsonDocument read(String id) {
	return bucket.get(id);
}
</code></pre>


			<p class="p">When data is stored in Couchbase as JSON, it will be converted by the Java SDK into a
					<strong class="ph b">JsonDocument</strong> object. This allows you to use a very simple JSON library, built
				into the Couchbase SDK, to access, modify and re-save the data held in the document.
				This makes working with data with Couchbase very simple as you have direct access to the
				data as it is stored in the database, allowing for rapid operations from both the client
				and the server.</p>

			<p class="p">Another important aspect is error management. When the document doesn't exist, the SDK
				simply returns null. But should another error condition arise, a specific exception will
				be thrown (like a <samp class="ph codeph">TimeOutException</samp> wrapped in a
					<span class="keyword apiname">RuntimeException </span> if the server couldn't respond in time). So it
				is important to ensure that your application can handle the errors that the SDK will
				pass up to it.</p>


			<p class="p">Next see if you can complete the very similar methods <samp class="ph codeph">create</samp>,
					<samp class="ph codeph">delete</samp> and <samp class="ph codeph">update</samp>. Their corresponding SDK methods
				are <samp class="ph codeph">insert</samp> (or <samp class="ph codeph">upsert</samp>), <samp class="ph codeph">remove</samp> and
					<samp class="ph codeph">update</samp>.</p>


			<p class="p">Some methods like the insert method can additionally specify a durability requirement as is
				covered in more detail in the document-updating section of the documentation.
				Briefly, it allows you to control the performance-persistence relationship. By
				default, the server will acknowledge the operation as soon as the document has
				reached its cache layer, this provides the best performance as the client can
				receive a response very quickly. However, in some situations you want or need
				greater assurances that an operation has completed, and so you can specify at what
				point during the persistence process the server will respond that the operation has
				completed.</p>


			<p class="p">Also, it may be confusing that we are returning a <span class="keyword apiname">JsonDocument</span> value.
				This is because the operations update the document's metadata. So the returned document
				reflects this, for example by having the <samp class="ph codeph">cas</samp> field updated.</p>

		</section>


		<section class="section"><h2 class="title sectiontitle">Querying views</h2>
			
			<p class="p">The next section of the <span class="keyword apiname">CouchbaseService</span> class is going to handle
				making a view query to the Couchbase cluster to allow us to display a list of all the
				beers ( and potentially limiting that list).</p>

			<p class="p">The first thing to consider when designing a view is the data requirement for the operation.
				Due to the increase in the amount of data being sent, a view query is slower than a
				basic get operation. Therefore, we need to consider what data we need from the view
				so that we only emit the values necessary. For our application, we have written a
				view function for beers that emits the name of the beer and the ID of its associated
				brewery.</p>


			<p class="p">The <samp class="ph codeph">findAllBeers</samp> method is the first example of querying a view. We need to
				prepare the query, optionally add parameters if a limit or a skip value have been
				provided then execute the query properly. The returned object,
					<span class="keyword apiname">ViewResult</span>, has a collection of rows, representing each key
				and value pair emitted by the view function. One can iterate over it by using the
					<span class="keyword apiname">rows()</span> method, which is what is used by the
					<span class="keyword apiname">BeerController</span> in the <span class="keyword apiname">listBeers()</span> method.
				Note that the controller transforms the result into a slightly different JSON object
				that better reflect what we want to expose in our REST API.</p>

			<p class="p">Try to implement <span class="keyword apiname">findAllBeers</span> and compare with the solution
				below:</p>

			<pre class="pre codeblock language-java"><code>public ViewResult findAllBeers(Integer offset, Integer limit) {
	ViewQuery query = ViewQuery.from("beer", "by_name");
	if (limit != null &amp;&amp; limit &gt; 0) {
		query.limit(limit);
	}
	if (offset != null &amp;&amp; offset &gt; 0) {
		query.skip(offset);
	}
	ViewResult result = bucket.query(query);
	return result;
}</code></pre>


			<p class="p">As the view query is more complex than a get operation, it is advantageous to leverage
				the asynchronous API in the SDK. To achieve this, we can use the
					<samp class="ph codeph">async()</samp> method on the bucket, this tells the SDK to use the
				underlying asynchronous operations and not to apply any blocking code to it. This allows
				us far greater control over the execution of the operation. Additionally, we will now be
				dealing with observables (as made more explicit in the API by having the return types
				being prefixed with <samp class="ph codeph">Async</samp>).</p>

			<p class="p">Try to implement the <span class="keyword apiname">findAllBeersAsync()</span> method and compare with the
				solution below:</p>

			<pre class="pre codeblock language-java"><code>/**
* Retrieves all the beers using a view query, returning the result asynchronously.
*/
public Observable&lt;AsyncViewResult&gt; findAllBeersAsync() {
	ViewQuery allBeers = ViewQuery.from("beer", "by_name");
	return bucket.async().query(allBeers);
}</code></pre>


			<p class="p">As you can see, going from sync to async is quite easy, by just calling
					<span class="keyword apiname">async()</span>. Methods that returned an <samp class="ph codeph">X</samp> in the
				sync variant now return an <samp class="ph codeph"> Observable&lt;X&gt;</samp>. You can then apply
				Rx transformations to it if necessary, as we'll see in the next section. For now,
				try also to do the simple implementation of <span class="keyword apiname">asyncRead()</span>.</p>


			<p class="p">There are two last view-related methods to implement before jumping into more advanced
				asynchronous data flows: <span class="keyword apiname">createQueryBeersForBrewery()</span> and
					<span class="keyword apiname">findBeersForBreweryAsync()</span>. The second one just executes the query
				produced by the first one in an asynchronous manner. The idea of the query is to use the
					<samp class="ph codeph">brewery_beers</samp> view to retrieve all beers brewed in a particular
				brewery. This can be done by specifying a very narrow range of keys.</p>

			<p class="p">In this view, note how the key is a JSON array of the brewery identifier and the beer
				identifier for beers. If we provide a <samp class="ph codeph">startKey</samp> with just the
				brewery identifier BW and an <samp class="ph codeph">endKey</samp> that would limit us to the last
				[BW, <em class="ph i">beer Id</em>] pair (included), we would be good. The trick here is to use the
				UTF-8 character <samp class="ph codeph">\uefff</samp>. This is a big enough char that we're sure
				no beer identifier will come after it, alphabetically speaking. So this results in
				the correct range we're seeking:</p>

			<p class="p">Try to implement <span class="keyword apiname">createQueryBeersForBrewery</span> and
					<span class="keyword apiname">FindBeersForBreweryAsync</span> and compare with the solution below:</p>

			<pre class="pre codeblock language-java"><code>public static ViewQuery createQueryBeersForBrewery(String breweryId) {
	ViewQuery forBrewery = ViewQuery.from("beer", "brewery_beers");
	forBrewery.startKey(JsonArray.from(breweryId));
	//the trick here is that sorting is UTF8 based, uefff is the largest UTF8 char
	forBrewery.endKey(JsonArray.from(breweryId, "\uefff"));
	return forBrewery;
}

public Observable&lt;AsyncViewResult&gt; findBeersForBreweryAsync(String breweryId) {
	return bucket.async().query(createQueryBeersForBrewery(breweryId));
}
					</code></pre>

		</section>


		<section class="section"><h2 class="title sectiontitle">More advanced asynchronous flow</h2>
			
			<p class="p">Let's have a look at a more advanced data flow coded in
				<span class="keyword apiname">BreweriesController</span>'s <span class="keyword apiname">getBrewery()</span> method. The
				idea of this method is to display a brewery's details (as obtained from the
				database), but with the addition of a <samp class="ph codeph">beers</samp> field that contains an
				array of all the beers produced by this brewery. Prepare two asynchronous
				observables to retrieve the relevant data: : one to retrieve the brewery's document
				itself, the other to list this brewery's beers and assemble them into a
					<samp class="ph codeph">List</samp> (using the <samp class="ph codeph">findBeersForBreweryAsync()</samp>
				query we just did).</p>

			<p class="p">So far, only <span class="keyword apiname">Observable</span> have been produced, and there's not been any
				consumption of data by calling <span class="keyword apiname">subscribe()</span> with an
					<span class="keyword apiname">Observer</span>. This means the flow hasn't been started, we are
				just describing what it will do. Next step needs to combine each item in these two
				streams to result in a stream of JSON as we want it presented to the user ( combine
				a brewery document with a list of beers documents and produce a JSON object similar
				to the brewery document with an additional <em class="ph i">beers</em> field). This is the role of
				the <samp class="ph codeph">concatBeerInfoToBrewery()</samp> method, that we now need to
				implement.</p>

			<p class="p">Notice that the controller uses the <span class="keyword apiname">singleOrDefault</span> Rx operator to specify
				a default JSON value to return to the user if the brewery document is not found (or
				no list of beers could be compiled). Notice as well that in the case of exceptions
				being detected, they are trapped and transformed into a JSON object emitted to the
				user by the <span class="keyword apiname">onErrorReturn</span> Rx operator.</p>

			<p class="p">The resulting stream is subscribed to a few lines below by waiting for a single
				emission, getting the JSON content and returning it as the REST API call's result.
				Subscription and blocking is done by calling
					<samp class="ph codeph">fullBeers.toBlocking().single()</samp>.</p>

			<p class="p">Try to implement <samp class="ph codeph">concatBeerInfoToBrewery()</samp> and compare with the
				solution below:</p>

			<pre class="pre codeblock language-java"><code>public static Observable&lt;JsonDocument&gt; concatBeerInfoToBrewery(Observable&lt;JsonDocument&gt; brewery,
	Observable&lt;List&lt;JsonDocument&gt;&gt; beers) {
		return Observable.zip(brewery, beers,
		new Func2&lt;JsonDocument, List&lt;JsonDocument&gt;, JsonDocument&gt;() {
			@Override
			public JsonDocument call(JsonDocument breweryDoc, List&lt;JsonDocument&gt; beersDoc) {
				JsonArray beers = JsonArray.create();
				for (JsonDocument beerDoc : beersDoc) {
					JsonObject beer = JsonObject.create()
					.put("id", beerDoc.id())
					.put("beer", beerDoc.content());
					beers.add(beer);
				}
				breweryDoc.content().put("beers", beers);
				return breweryDoc;
			}
		});
	}</code></pre>


			<p class="p">Last data flow is the one used for searching beers by partial name. In
					<samp class="ph codeph">searchBeer</samp> we'll try to start from the stream of all beers, rework
				the data to stick to the REST API return format and filter to find only beers that match
				the search token.</p>

			<p class="p">The REST controller will then subscribe to the resulting flow and send the collected
				data to the user. The expected format is a JSON object with the beer's
					<samp class="ph codeph">id</samp>, <samp class="ph codeph">name</samp> and the full beer document content under
				the <samp class="ph codeph">detail</samp> attribute. This must be done for every beer (and so the
				input of the method is a stream of every beer obtained by calling
					<span class="keyword apiname">findAllBeersAsync</span>).</p>

			<p class="p">The first step is to transform each query result row in the stream into the expected JSON
				object format. One can use the <span class="keyword apiname">map</span> Rx operator to do that, but
				this is done on the row's <span class="keyword apiname">document()</span> method, which returns an
					<samp class="ph codeph">Observable</samp>. So we have a nested Observable (the document one in
				the observable of rows) and need to flatten it. This can be achieved by wrapping the
				mapping in a <span class="keyword apiname">flatMap</span> Rx operator call.</p>

			<p class="p">Try to code the first part of <span class="keyword apiname">searchBeer</span> and compare to the solution
				below:</p>

			<pre class="pre codeblock language-java"><code>allBeers
//extract the document from the row and carve a result object using its content and id
.flatMap(new Func1&lt;AsyncViewRow, Observable&lt;JsonObject&gt;&gt;() {
	@Override
	public Observable&lt;JsonObject&gt; call(AsyncViewRow row) {
		return row.document().map(new Func1&lt;JsonDocument, JsonObject&gt;() {
			@Override
			public JsonObject call(JsonDocument jsonDocument) {
				return JsonObject.create()
				.put("id", jsonDocument.id())
				.put("name", jsonDocument.content().getString("name"))
				.put("detail", jsonDocument.content());
			}
		});
	}
})</code></pre>

			<p class="p">Then comes the filtering, only keeping beers which name contains the search token,
				ignoring case. This can be achieved using the <span class="keyword apiname">filter</span> Rx operator. Try
				to code this second part of <span class="keyword apiname">searchBeer</span> and compare to the solution
				below:</p>

			<pre class="pre codeblock language-java"><code>//reject beers that don't match the partial name
.filter(new Func1&lt;JsonObject, Boolean&gt;() {
	@Override
	public Boolean call(JsonObject jsonObject) {
		String name = jsonObject.getString("name");
		return name != null &amp;&amp; name.toLowerCase().contains(token.toLowerCase());
	}
})</code></pre>

			<p class="p">Finally, since what we want to output is a big JSON array of all the matching rows, we
				need to collect each transformed item that passed the filter into a single
					<samp class="ph codeph">JsonArray</samp>. The <span class="keyword apiname">collect</span> Rx operator does just
				that. It needs a "factory function" to create the initial collecting structure (here an
				empty <samp class="ph codeph">JsonArray</samp>) and a section function that populates the collecting
				structure, called for each emitted upstream item.</p>

			<p class="p">Try to apply the <samp class="ph codeph">collect</samp> operator to our case in the third part of
					<span class="keyword apiname">searchBeer</span> and compare with the solution below:</p>

			<pre class="pre codeblock language-java"><code>//collect results into a JSON array (one could also just use toList() since a List would be
// transcoded into a JSON array)
.collect(new Func0&lt;JsonArray&gt;() { //this creates the array (once)
	@Override
	public JsonArray call() {
		return JsonArray.empty();
	}
}, new Action2&lt;JsonArray, JsonObject&gt;() { //this populates the array (each item)
	@Override
	public void call(JsonArray objects, JsonObject jsonObject) {
		objects.add(jsonObject);
	}
});</code></pre>

		</section>

	</div>

<nav class="related-links"><h2>Related information</h2>
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="../../developer/java-2.1/getting-started.html" title="This guide provides a foundational introduction to the Couchbase Java SDK. It shows you how to install the SDK and write a basic sample application that highlights important aspects. After you install the SDK, you can start exploring it on your own or proceed with a tutorial to build a complete, production-grade application.">Getting started with the Java SDK</a></div>
<div class="previouslink"><strong>Previous topic:</strong> <a class="link" href="../../developer/java-2.1/hello-couchbase.html">Hello Couchbase Example</a></div>
</div>
</nav></div><footer class="developer-portal-footer" role="contentinfo"><p class="legal"><span class="license">© 2011–2015 <b class="company-name">Couchbase</b>. All rights reserved.</span><a href="http://support.couchbase.com/">Customer Login</a><a href="http://www.couchbase.com/terms-of-service">Terms of Service</a><a href="http://www.couchbase.com/privacy-policy">Privacy Policy</a></p></footer></div></main><script src="../../assets/javascripts/vendor/prism.js"></script><script type="text/javascript">var BASEPATH='../../';</script><script src="../../assets/javascripts/init.js"></script><script type="text/javascript" src="https://issues.couchbase.com/s/en_US-pvmaib-418945332/845/131/1.2.9/_/download/batch/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector.js?collectorId=86389172"></script></body></html>