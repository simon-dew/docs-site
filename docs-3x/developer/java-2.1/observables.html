<!DOCTYPE html><html xmlns:related-links="http://dita-ot.sourceforge.net/ns/200709/related-links" class="no-js developer-portal" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><title>Mastering observables — Couchbase Server 3.0/3.1</title><meta name="apple-mobile-web-app-title" content="Couchbase"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-precomposed.png"><link rel="stylesheet" href="../../assets/stylesheets/application.css"><link rel="stylesheet" href="../../assets/stylesheets/docs.css"></head><body data-modules="developer-portal-sidebar-navigation developer-portal-versions-navigation">
	<!-- Google Tag Manager -->
				<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-MVPNN2"
					height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
				<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
					new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
					j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
					'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
					})(window,document,'script','dataLayer','GTM-MVPNN2');</script>
				<!-- End Google Tag Manager -->
				<header class="developer-portal-header" role="banner"><div class="layout-wrapper"><div class="developer-portal-header__hgroup"><h1 class="developer-portal-header__logo"><a href="http://couchbase.com" rel="home">Couchbase</a></h1><p class="developer-portal-header__page-title">Couchbase Server 3.0/3.1</p></div><nav class="developer-portal-header__navigation" id="primary-navigation" role="navigation"><div class="developer-portal-header__navigation__wrapper" id="primary-navigation__wrapper"><ul class="developer-portal-header__navigation__items"><li class="developer-portal-header__navigation__item"><a href="/index.html">Documentation Home</a></li><li class="developer-portal-header__navigation__item"><a href="http://www.couchbase.com/nosql-databases/downloads">Downloads</a></li><li class="developer-portal-header__navigation__item"><a href="http://www.couchbase.com/open-source">Open Source Projects</a></li><li class="developer-portal-header__navigation__item"><a href="http://forums.couchbase.com">Forums</a></li></ul><div class="developer-portal-header__search"><script>
					  (function() {
					    var cx = '018016427239405524608:fkg1v30apnm';
					    var gcse = document.createElement('script');
					    gcse.type = 'text/javascript';
					    gcse.async = true;
					    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
					        '//www.google.com/cse/cse.js?cx=' + cx;
					    var s = document.getElementsByTagName('script')[0];
					    s.parentNode.insertBefore(gcse, s);
					  })();
					</script><gcse:search></gcse:search></div></div></nav></div></header><main class="developer-portal-global-content" role="main"><aside class="developer-portal-sidebar"><nav class="developer-portal-sidebar__navigation"><div class="developer-portal-sidebar__navigation__wrapper" id="developer-portal-sidebar-navigation"><ul><li class="section section--has-sub-sections"><a href="../../admin/Couchbase-intro.html"><span>Introduction</span></a></li><li class="section"><a href="../../admin/Whats-new-3.0.html"><span>What's new in 3.0</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/install-intro.html"><span>Installation and upgrade</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/admin-intro.html"><span>Administration</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/Views/views-intro.html"><span>Views and indexes</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/cli-intro.html"><span>CLI reference</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/rest-intro.html"><span>REST API reference</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/rel-notes/rel-notes3.0.html"><span>Release notes</span></a></li><li class="section"><a href="../../admin/pdfs.html"><span>PDFs</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/dev-guide-3.0/intro.html"><span>Overview</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/dev-guide-3.0/concepts.html"><span>Developing applications</span></a></li><li class="section section--has-sub-sections&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;section--active"><a href="../../developer/dev-guide-3.0/old-versions.html"><span>Older SDK versions</span></a><ul class="sub-sections"><li class="section section--has-sub-sections&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;section--active"><a href="../../developer/java-2.1/java-intro.html"><span>Java SDK 2.1</span></a><ul class="sub-sections"><li class="section"><a href="../../developer/java-2.1/overview.html"><span>Overview</span></a></li><li class="section"><a href="../../developer/java-2.1/download-links.html"><span>Download and API Reference</span></a></li><li class="section"><a href="../../developer/java-2.1/migrate.html"><span>Migrating from Java SDK 1.4.x to 2.x</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/java-2.1/getting-started.html"><span>Getting started with the Java SDK</span></a></li><li class="section"><a href="../../developer/java-2.1/managing-connections.html"><span>Managing connections</span></a></li><li class="section"><a href="../../developer/java-2.1/env-config.html"><span>Configuring the environment</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/java-2.1/documents.html"><span>Working with documents</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/java-2.1/querying.html"><span>Querying buckets</span></a></li><li class="section"><a href="../../developer/java-2.1/observables.html" class="current"><span>Mastering observables</span></a><ul class="sub-sections"></ul></li><li class="section"><a href="../../developer/java-2.1/logging.html"><span>Setting up logging</span></a></li><li class="section"><a href="../../developer/java-2.1/release-notes.html"><span>Release notes</span></a></li></ul></li><li class="section section--has-sub-sections"><a href="../../developer/java-2.0/java-intro.html"><span>Java SDK 2.0</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/dotnet-2.1/dotnet-intro.html"><span>.NET SDK 2.1</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/dotnet-2.0/dotnet-intro.html"><span>.NET SDK 2.0</span></a></li></ul></li></ul></div></nav></aside><div class="developer-portal-content"><div class="developer-portal-content__wrapper textblock__content">
	<h1 class="title topictitle1" id="ariaid-title1">Mastering observables</h1>

	
	<div class="body conbody"><p class="shortdesc">This guide helps you getting up to speed with asynchronous programming and
		<samp class="ph codeph">Observable</samp> objects in particular. This guide is not tied to the Java
		SDK exclusively and aims to give you a general understanding of how to build full-stack,
		asynchronous applications.</p>

		

		<section class="section"><h2 class="title sectiontitle">Motivation</h2>
			

			<p class="p">Asynchronous and reactive methodologies allow you to utilize better the system resources.
                Instead of wasting a thread waiting for network or disk I/O, it can be fully
                utilized to perform other work instead.</p>


			<p class="p">A broad range of technologies exists to facilitate this style of programming, ranging from the
				very limited and not really usable <samp class="ph codeph">java.util.concurrent.Future</samp> to
				complete libraries and runtimes like <a class="xref" href="http://akka.io" target="_blank">Akka</a>. For a database driver, the following requirements must
				be met:</p>


			<ul class="ul">
				<li class="li">Rich functionality</li>

				<li class="li">Interoperable and not opinionated</li>

				<li class="li">Performant</li>

				<li class="li">Small dependency and runtime footprint</li>

			</ul>


			<p class="p">After evaluating the requirements and solutions closely, one library stood out: <a class="xref" href="http://reactivex.io/" target="_blank">RxJava</a>. It has
				a very rich set to compose asynchronous workflows, has no dependencies on its own and is
				used at high-profile companies like Netflix. The Rx model is mature and well thought
				out, and the community is vibrant.</p>


			<p class="p">We hope that after you read through the introduction and get more familiar with the concept,
				you never want to go back. We certainly don't. That said, we fully support blocking
				operations as well, so you can still use a traditional blocking-based model if you
				absolutely want to.</p>


			<p class="p">The next section gradually introduces you to the world of observables, the first step to
				masterhood. If you want to learn more about the motivation, read on here.</p>

		</section>


		<section class="section"><h2 class="title sectiontitle">Java 8, lambdas and anonymous classes</h2>Before jumping into the details, one
            thing warrants clarification: RxJava and, therefore, the Java SDK fully supports Java 8.
            This support brings some great improvements, most prominently support for lambdas and
            method references.<p class="p">Because the Java SDK has support for Java 6 and 7, most of the
                examples shown in the documentation use anonymous classes instead of lambdas. You
                are free and even encouraged to use them if you can, but Java 8 on production
                servers is still a few months or even years away at most companies. That said, we
                expect the SDK to be around for a long time and want to pave the way for the future
                right now. </p>
<p class="p">To whet your appetite, compare some Java 6 code to Java 8 code
                (same code).Here's an example with Java 6 code:</p>
<pre class="pre codeblock language-java"><code>// Loads 3 documents in parallel
Observable
    .just("doc1", "doc2", "doc3")
    .flatMap(new Func1&lt;String, Observable&lt;JsonDocument&gt;&gt;() {
        @Override
        public Observable&lt;JsonDocument&gt; call(String id) {
            return bucket.get(id);
        }
    }).subscribe(new Action1&lt;JsonDocument&gt;() {
        @Override
        public void call(JsonDocument document) {
            System.out.println("Got: " + document);
        }
    });</code></pre>
 Here's the same code written in Java 8: <pre class="pre codeblock language-java"><code>// Loads 3 documents in parallel
Observable
    .just("doc1", "doc2", "doc3")
    .flatMap(bucket::get)
    .subscribe(document -&gt; System.out.println("Got: " + document));</code></pre>

            <p class="p">RxJava has support for other languages like Scala, Groovy or Clojure. If you are
                using one of those languages, refer to the RxJava documentation on how to use the
                adapters.</p>
</section>


		<section class="section"><h2 class="title sectiontitle">Understanding observables</h2>
			

			<p class="p">You can think of an <samp class="ph codeph">Observable</samp> as the push-based, asynchronous cousin
				("dual") of the pull-based, synchronous <samp class="ph codeph">Iterable</samp>. The contract of an
					<samp class="ph codeph">Observable</samp> is that zero to N data events can happen, followed by a
				complete event. In addition, an error event can happen at any time, also completing the
					<samp class="ph codeph">Observable</samp>.</p>


			
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="concept2677__table_qpl_ttq_44" class="table" frame="border" border="1" rules="all"><caption><span class="tablecap">Table 1. The duality of iterable and observable</span></caption>
    <col style="width:33.56269113149847%">
    <col style="width:32.798165137614674%">
    <col style="width:33.63914373088685%">
    <thead class="thead" style="text-align:left;">
     <tr class="row">
      <th class="entry cellrowborder" style="text-align:left;vertical-align:top;" id="d190024e120">Event</th>

      <th class="entry cellrowborder" style="text-align:left;vertical-align:top;" id="d190024e123">Iterable (Pull)</th>

      <th class="entry cellrowborder" style="text-align:left;vertical-align:top;" id="d190024e126">Observable (Push)</th>

     </tr>

    </thead>

    <tbody class="tbody">
      <tr class="row">
        <td class="entry cellrowborder" style="text-align:left;vertical-align:top;" headers="d190024e120 ">retrieve data</td>

        <td class="entry cellrowborder" style="text-align:left;vertical-align:top;" headers="d190024e123 "><samp class="ph codeph">T next()</samp></td>

        <td class="entry cellrowborder" style="text-align:left;vertical-align:top;" headers="d190024e126 "><samp class="ph codeph">onNext(T)</samp></td>

      </tr>

      <tr class="row">
        <td class="entry cellrowborder" style="text-align:left;vertical-align:top;" headers="d190024e120 ">discover error</td>

        <td class="entry cellrowborder" style="text-align:left;vertical-align:top;" headers="d190024e123 "><samp class="ph codeph">throws Exception</samp></td>

        <td class="entry cellrowborder" style="text-align:left;vertical-align:top;" headers="d190024e126 "><samp class="ph codeph">onError(Exception)</samp></td>

      </tr>

      <tr class="row">
        <td class="entry cellrowborder" style="text-align:left;vertical-align:top;" headers="d190024e120 ">complete</td>

        <td class="entry cellrowborder" style="text-align:left;vertical-align:top;" headers="d190024e123 "><samp class="ph codeph">returns</samp></td>

        <td class="entry cellrowborder" style="text-align:left;vertical-align:top;" headers="d190024e126 "><samp class="ph codeph">onCompleted()</samp></td>

      </tr>

    </tbody>

   </table>
</div>


		<p class="p">An <samp class="ph codeph">Observable</samp> can also be converted into a
				<samp class="ph codeph">BlockingObservable</samp>, which then, unsurprisingly, behaves very much like
				an <samp class="ph codeph">Iterable</samp>.</p>


		<p class="p">The key element to take away is that an <samp class="ph codeph">Observable&lt;T&gt;</samp> can emit 0 to N
				events, which is very different than a <samp class="ph codeph">Future&lt;T&gt;</samp>, which only
				contains one value. After you start to work on streams instead of single values, you
				will very much appreciate this fact.</p>


		<p class="p">Also, important to understand is that by definition, an <samp class="ph codeph">Observable</samp> does not
                imply that the underlying code is executed asynchronously. As a consumer of an
                    <samp class="ph codeph">Observable</samp>, you leave the actual implementation to the
                supplier, who can change it later on without you having to adapt your code. Imagine,
                you are consuming this API:</p>


<pre class="pre codeblock language-java"><code>public interface FooService {
    Observable&lt;String&gt; load();
}</code></pre>


		<p class="p">It could be that when <samp class="ph codeph">load()</samp> is called, the <samp class="ph codeph">String</samp> value is
                fetched right out of a <samp class="ph codeph">Map</samp> in memory (or even a hard-coded value).
                In this case, there is no need to move the execution away from the caller thread,
                because the value will be returned instantaneously. Later, if the implementation
                needs to be changed so that the <samp class="ph codeph">String</samp> is loaded through a web
                service introducing latency and other semantics, the API doesn't need to be changed
                because the underlying implementation is free to move it to the
                    <samp class="ph codeph">Scheduler</samp>.</p>


		</section>


		<section class="section"><h2 class="title sectiontitle">Consuming observables</h2>
			

			<p class="p">The first thing you want to do when working with observables is to consume them. Consuming an
				observable means subscribing to it. Here is an example that subscribes and prints out
				all the items emitted:</p>


<pre class="pre codeblock language-java"><code>Observable
    .just(1, 2, 3)
    .subscribe(new Subscriber&lt;Integer&gt;() {
        @Override
        public void onCompleted() {
            System.out.println("Completed Observable.");
        }

        @Override
        public void onError(Throwable throwable) {
            System.err.println("Whoops: " + throwable.getMessage());
        }

        @Override
        public void onNext(Integer integer) {
            System.out.println("Got: " + integer);
        }
    });</code></pre>


    <p class="p">The example prints the following lines:</p>


<pre class="pre codeblock"><code>Got: 1
Got: 2
Got: 3
Completed Observable.</code></pre>


	<div class="p">You can see that our <samp class="ph codeph">Observer</samp> gets notified of every event and also receives
                the completed event.<div class="note note"><span class="notetitle">Note:</span> A well-formed observable invokes its subscriber’s
                        <samp class="ph codeph">onNext</samp> method zero or more times and then invokes either
                    the <samp class="ph codeph">onCompleted</samp> or <samp class="ph codeph">onError</samp> method exactly
                    once.</div>
</div>


	<p class="p">You can also test the error case by throwing an artificial exception when the value 2 is emitted:</p>


<pre class="pre codeblock language-java"><code>Observable
    .just(1, 2, 3)
    .doOnNext(new Action1&lt;Integer&gt;() {
        @Override
        public void call(Integer integer) {
            if (integer.equals(2)) {
                throw new RuntimeException("I don't like 2");
            }
        }
    })
    .subscribe(new Subscriber&lt;Integer&gt;() {
        @Override
        public void onCompleted() {
            System.out.println("Completed Observable.");
        }

        @Override
        public void onError(Throwable throwable) {
            System.err.println("Whoops: " + throwable.getMessage());
        }

        @Override
        public void onNext(Integer integer) {
            System.out.println("Got: " + integer);
        }
    });</code></pre>


    <p class="p">The example prints:</p>


<pre class="pre codeblock"><code>Got: 1
Whoops: I don't like 2</code></pre>


	<p class="p">The first value gets through without problems, the second value throws an exception and,
                therefore, terminates the observable (and no subsequent values are allowed to be
                emitted after an error event).</p>


	<div class="p"><div class="note note"><span class="notetitle">Note:</span> The <samp class="ph codeph">subscribe</samp> method also returns a <samp class="ph codeph">Subscription</samp> that you
                    can use to <samp class="ph codeph">unsubscribe</samp> and, therefore, do not receive further
                    events.</div>
</div>


	<p class="p">Even if you don't unsubscribe explicitly, operations like <samp class="ph codeph">take</samp> do that for you
				implicitly. The following code only takes the first five values and then
				unsubscribes:</p>


<pre class="pre codeblock language-java"><code>Observable
    .just("The", "Dave", "Brubeck", "Quartet", "Time", "Out")
    .take(5)
    .subscribe(new Subscriber&lt;String&gt;() {
        @Override
        public void onCompleted() {
            System.out.println("Completed Observable.");
        }

        @Override
        public void onError(Throwable throwable) {
            System.err.println("Whoops: " + throwable.getMessage());
        }

        @Override
        public void onNext(String name) {
            System.out.println("Got: " + name);
        }
    });</code></pre>


	<p class="p">This prints:</p>


<pre class="pre codeblock"><code>Got: The
Got: Dave
Got: Brubeck
Got: Quartet
Got: Time
Completed Observable.</code></pre>


		<div class="p"><div class="note note"><span class="notetitle">Note:</span> If you take a close look at the API, <samp class="ph codeph">subscribe()</samp> can be fed with either an
                        <samp class="ph codeph">Observer</samp> or a <samp class="ph codeph">Subscriber</samp>. Unless you are
                    implementing a custom <samp class="ph codeph">Observer</samp>, always use
                        <samp class="ph codeph">Subscriber</samp> (because otherwise it will be wrapped in one
                    internally and you are saving unnecessary object allocations).</div>
</div>


		<p class="p">You do not need to implement the full subscriber every time. If you are only interested in the
				data events, you can subscribe like this:</p>


<pre class="pre codeblock language-java"><code>Observable
    .just(1, 2, 3)
    .subscribe(new Action1&lt;Integer&gt;() {
        @Override
        public void call(Integer integer) {
            System.out.println("Got: " + integer);
        }
    });</code></pre>


    <p class="p">Be aware though that if an error happens, the following exception will be propagated:</p>


<pre class="pre codeblock"><code>Exception in thread "main" rx.exceptions.OnErrorNotImplementedException
	at rx.Observable$36.onError(Observable.java:8412)
	at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:128)
	at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:97)
	at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:67)
	at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:78)
	at rx.internal.operators.OnSubscribeFromIterable$IterableProducer
          .request(OnSubscribeFromIterable.java:76)
	...</code></pre>


	<p class="p">Always implement an error handler right from the beginning since things can and will go wrong at
                some point. It can come in handy though if you just want to try things out quickly
                or for illustrative purposes.</p>


		</section>


		<section class="section"><h2 class="title sectiontitle">From asynchronous to synchronous</h2>
			

			<p class="p">As long as your <samp class="ph codeph">Observable</samp> works on the same thread all the time, there is no
                need for communication between threads since only one is executing. When your
                    <samp class="ph codeph">Observable</samp> flow gets executed on a different thread, you need
                to take some extra care to make sure you are not missing values. This is not
                specific to <samp class="ph codeph">Observables</samp> though, and every time you need to deal
                with parallel threads you need to think about synchronization and communication.</p>


            <div class="p"><div class="note note"><span class="notetitle">Note:</span> Most of the snippets in this documentation only call <samp class="ph codeph">subscribe</samp>. You should
                    ensure that your program doesn't terminate before <samp class="ph codeph">onCompleted()</samp>
                    is called (e.g., via <samp class="ph codeph">toBlocking()</samp> or a
                        <span class="keyword apiname">CountDownLatch</span>). This is most often to watch for when
                    trying to replicate a snippet in its Main class.</div>
</div>


            <div class="p"><div class="note note"><span class="notetitle">Note:</span> You should never perform long-running blocking operations inside of an asynchronous stream
                    (e.g., inside of <samp class="ph codeph">map</samp>s or <samp class="ph codeph">flatMap</samp>s).</div>
</div>


			<p class="p">The following code emits an increasing value every second, and this is done on a different
                thread:</p>


<pre class="pre codeblock language-java"><code>public static void main(String... args) {
    Observable
        .interval(1, TimeUnit.SECONDS)
        .subscribe(new Action1&lt;Long&gt;() {
            @Override
            public void call(Long counter) {
                System.out.println("Got: " + counter);
            }
        });
}</code></pre>


    <p class="p">It works perfectly fine; the only problem is though chances are you won't see anything
                printed out. This is because your main thread exits before the background thread had
                a chance to run and emit values.</p>


    <p class="p">A common way to deal with such a situation is to add a <samp class="ph codeph">CountDownLatch</samp>, which
                allows you to synchronize between different threads. One thread counts down the
                latch; the other one waits until it is counted down:</p>


<pre class="pre codeblock language-java"><code>final CountDownLatch latch = new CountDownLatch(5);
Observable
    .interval(1, TimeUnit.SECONDS)
    .subscribe(new Action1&lt;Long&gt;() {
        @Override
        public void call(Long counter) {
            latch.countDown();
            System.out.println("Got: " + counter);
        }
    });

latch.await();</code></pre>


    <p class="p">The example prints the following lines and then exits:</p>


<pre class="pre codeblock"><code>Got: 0
Got: 1
Got: 2
Got: 3
Got: 4</code></pre>


	<div class="p"><div class="note note"><span class="notetitle">Note:</span> One common mistake is to use <samp class="ph codeph">Thread.sleep()</samp> instead of a latch to synchronize
                    the execution between threads. This is a bad idea because it doesn't synchronize
                    anything but just keeps one thread alive for a specific amount of time. If the
                    actual calls take less time you are wasting time, and if it takes longer you
                    won't get the desired effect. If you do this in unit tests, be prepared for a
                    good amount of non-determinism and randomly failing tests. <strong class="ph b">Always use a
                            <samp class="ph codeph">CountDownLatch</samp>.</strong></div>
</div>


	<p class="p">A technique unique to observables is to convert it into a <samp class="ph codeph">BlockingObservable</samp> to
                achieve the same effect. In simple terms, it converts an observable into an iterable
                and making it execute on the caller thread, blocking it until one or more values
                arrive. This technique is used extensively in the documentation to show concepts,
                while not having to deal with countdown latches all the time. It can also be used if
                you for some reason are not able to use asynchronous computations.</p>


	<p class="p">The conversion itself doesn't do any blocking in the first place, only subsequent calls will:</p>


<pre class="pre codeblock language-java"><code>// This does not block.
BlockingObservable&lt;Long&gt; observable = Observable
    .interval(1, TimeUnit.SECONDS)
    .toBlocking();

// This blocks and is called for every emitted item.
observable.forEach(new Action1&lt;Long&gt;() {
    @Override
    public void call(Long counter) {
        System.out.println("Got: " + counter);
    }
});</code></pre>


    <p class="p">Because this will run forever, you are free to chain any asynchronous computations before.
				Thus, you can build an asynchronous workflow and then block at the very end. This
				resembles the same code as with the <samp class="ph codeph">CountDownLatch</samp> before:</p>


<pre class="pre codeblock language-java"><code>Observable
    .interval(1, TimeUnit.SECONDS)
    .take(5)
    .toBlocking()
    .forEach(new Action1&lt;Long&gt;() {
        @Override
        public void call(Long counter) {
            System.out.println("Got: " + counter);
        }
    });</code></pre>


    <p class="p">If you know that only a single value is ever returned, you can use the
					<span class="keyword apiname">single()</span> method:</p>


<pre class="pre codeblock language-java"><code>int value = Observable
    .just(1)
    .toBlocking()
    .single();</code></pre>


    <p class="p">Be aware though that if more items get emitted, you get an exception:</p>


<pre class="pre codeblock"><code>Exception in thread "main" java.lang.IllegalArgumentException: Sequence contains too many elements
	at rx.internal.operators.OperatorSingle$1.onNext(OperatorSingle.java:58)
	at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:76)
	at rx.Subscriber.setProducer(Subscriber.java:148)
	at rx.Subscriber.setProducer(Subscriber.java:144)
	....</code></pre>


	<p class="p">The same thing happens if no value gets emitted:</p>


<pre class="pre codeblock"><code>Exception in thread "main" java.util.NoSuchElementException: Sequence contains no elements
	at rx.internal.operators.OperatorSingle$1.onCompleted(OperatorSingle.java:82)
	at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:79)
	at rx.Subscriber.setProducer(Subscriber.java:148)
	at rx.Subscriber.setProducer(Subscriber.java:144)
	at rx.Subscriber.setProducer(Subscriber.java:144)
	at rx.Subscriber.setProducer(Subscriber.java:144)
	....</code></pre>


	<p class="p">As an alternative, you can use singleOrDefault() so that a fallback value gets returned.</p>


	<p class="p">You can use this technique with the Java SDK if you are loading a document and it does not exist:</p>


<pre class="pre codeblock language-java"><code>JsonDocument doc = bucket.get("id").toBlocking().singleOrDefault(null);
if (doc == null) {
    System.err.println("Document not found!");
} else {
    System.out.println(doc);
}</code></pre>


	<p class="p">If you check out the API documentation of the BlockingObservable, you will discover many more possibilities, including iterators or grabbing the first and/or last values.</p>


	<p class="p">One last thing that comes in handy with blocking calls: sometimes you want to collect all emitted values into a list. You can combine the blocking calls with the toList() operator to achieve something like this:</p>


<pre class="pre codeblock language-java"><code>List&lt;Integer&gt; list = Observable
    .just(1, 2, 3)
    .toList()
    .toBlocking()
    .single();

// Prints: [1, 2, 3]
System.out.println(list);</code></pre>


		</section>


		<section class="section"><h2 class="title sectiontitle">Creating observables</h2>
			

			<p class="p">There are many ways to create observables, and you've already seen <span class="keyword apiname">just()</span>
                and <span class="keyword apiname">interval()</span>. There are many more convenience methods available
                on the <samp class="ph codeph">Observable</samp> class, but they all boil down to the
                    <span class="keyword apiname">create()</span> method. You can simulate the example from before
                with this:</p>


<pre class="pre codeblock language-java"><code>Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() {
    @Override
    public void call(Subscriber&lt;? super Integer&gt; subscriber) {
        try {
            if (!subscriber.isUnsubscribed()) {
                for (int i = 0; i &lt; 5; i++) {
                    subscriber.onNext(i);
                }
                subscriber.onCompleted();
            }
        } catch (Exception ex) {
            subscriber.onError(ex);
        }
    }
}).subscribe(new Action1&lt;Integer&gt;() {
    @Override
    public void call(Integer integer) {
        System.out.println("Got: " + integer);
    }
});</code></pre>


		<p class="p">Every time a Subscriber subscribes, the <span class="keyword apiname">call()</span> method is executed. You can
				then call <samp class="ph codeph">onNext</samp>, <samp class="ph codeph">onComplete</samp> and
					<samp class="ph codeph">onError</samp> as you wish, but keep in mind that both
					<samp class="ph codeph">onComplete</samp> and <samp class="ph codeph">onError</samp> should only be called once,
				and afterward no subsequent <span class="keyword apiname">onNext</span> is allowed to follow so that the
				contract is met.</p>


		<p class="p">You can see that no blocking call is needed because the observable is completely handled on the
                current thread. In the section on schedulers, you learn more about that.</p>


		<div class="p"><div class="note note"><span class="notetitle">Note:</span> This example shows why it is crucial to call <span class="keyword apiname">subscribe()</span> on the observable, because only such a call triggers the actual execution of the pipeline. This is a little different with subjects, which are covered later in this guide. Nevertheless, always call <span class="keyword apiname">subscribe()</span> on your observables.</div>
</div>


		<p class="p">Refer to the RxJava documentation for many more methods that you can use to create observables.
                If you are dealing with the Java SDK, in most places this is done for you, but there
                are situations where it comes in handy.</p>


		<p class="p">The Java SDK does not expose bulk methods anymore on the API because you can do this already
                with the help of observables. Compare these two examples, one only loads one
                document, the other loads a few (you'll learn about <span class="keyword apiname">flatMap()</span> in
                the next section):</p>


<pre class="pre codeblock language-java"><code>// Loads one document and prints it:
bucket
    .get("doc1")
    .subscribe(new Action1&lt;JsonDocument&gt;() {
        @Override
        public void call(JsonDocument document) {
            System.out.println("Got: " + document);
        }
    });</code></pre>



<pre class="pre codeblock language-java"><code>// Loads 3 documents in parallel
Observable
    .just("doc1", "doc2", "doc3")
    .flatMap(new Func1&lt;String, Observable&lt;JsonDocument&gt;&gt;() {
        @Override
        public Observable&lt;JsonDocument&gt; call(String id) {
            return bucket.get(id);
        }
    }).subscribe(new Action1&lt;JsonDocument&gt;() {
        @Override
        public void call(JsonDocument document) {
            System.out.println("Got: " + document);
        }
    });</code></pre>


		</section>


		<section class="section"><h2 class="title sectiontitle">Transforming observables</h2>
			

			<p class="p">Observables can transform their values in various ways. One of the most basic ones is <span class="keyword apiname">map()</span>, which converts the incoming value into a different one. You surely like division, so here is the FizzBuzz game:</p>


<pre class="pre codeblock language-java"><code>Observable
    .interval(10, TimeUnit.MILLISECONDS)
    .take(20)
    .map(new Func1&lt;Long, String&gt;() {
        @Override
        public String call(Long input) {
            if (input % 3 == 0) {
                return "Fizz";
            } else if (input % 5 == 0) {
                return "Buzz";
            }
            return Long.toString(input);
        }
    })
    .toBlocking()
    .forEach(new Action1&lt;String&gt;() {
        @Override
        public void call(String s) {
            System.out.println(s);
        }
    });</code></pre>


    <p class="p">The map function is used to convert the input number into a string and do some checks to satisfy the FizzBuzz game. As a more practical example, consider loading a document from the Java SDK and only extracting the first name of a user before passing it on:</p>


<pre class="pre codeblock language-java"><code>bucket
    .get("id")
    .map(new Func1&lt;JsonDocument, String&gt;() {
        @Override
        public String call(JsonDocument document) {
            return document.content().getString("firstname");
        }
    }).subscribe();</code></pre>


    <p class="p">A variation of <span class="keyword apiname">map()</span> is called <span class="keyword apiname">flatMap()</span>, which allows
				you to do those transformations with asynchronous calls. Taking the example from above,
				we want to map from String (the document ID) to a <samp class="ph codeph">JsonDocument</samp> (the
				loaded document). With a normal <span class="keyword apiname">map()</span>, call you would either need to
				block on the observable or at some point deal with an
					<samp class="ph codeph">Observable&lt;Observable&lt;JsonDocument&gt;&gt;</samp>.</p>


    <p class="p">Thankfully, <span class="keyword apiname">flatMap()</span> flattens the resulting values for us and return them
				into the original flow:</p>


<pre class="pre codeblock language-java"><code>// Loads 3 documents in parallel
Observable
    .just("doc1", "doc2", "doc3")
    .flatMap(new Func1&lt;String, Observable&lt;JsonDocument&gt;&gt;() {
        @Override
        public Observable&lt;JsonDocument&gt; call(String id) {
            return bucket.get(id);
        }
    }).subscribe(new Action1&lt;JsonDocument&gt;() {
        @Override
        public void call(JsonDocument document) {
            System.out.println("Got: " + document);
        }
    });</code></pre>


 	<p class="p">You can see that <span class="keyword apiname">flatMap()</span> returns an Observable&lt;T&gt; whereas the normal map just returns &lt;T&gt;. You will use <span class="keyword apiname">flatMap()</span> a lot when dealing with flows like this, so keep it in mind.</p>


 	<p class="p">Another helpful transformation is <span class="keyword apiname">scan()</span>. It applies a function to each value emitted by an observable, sequentially, and emits each successive value. We can use it to aggregate values like this:</p>


<pre class="pre codeblock language-java"><code>Observable
    .just(1, 2, 3, 4, 5)
    .scan(new Func2&lt;Integer, Integer, Integer&gt;() {
        @Override
        public Integer call(Integer sum, Integer value) {
            return sum + value;
        }
    }).subscribe(new Action1&lt;Integer&gt;() {
        @Override
        public void call(Integer integer) {
            System.out.println("Sum: " + integer);
        }
    });</code></pre>


         <p class="p">This prints:</p>


<pre class="pre codeblock"><code>Sum: 1
Sum: 3
Sum: 6
Sum: 10
Sum: 15</code></pre>


<p class="p">Finally, <span class="keyword apiname">groupBy()</span> comes in handy, which emits one observable by each group, defined by a function. The following example emits two observables, one for even and one for odd values:</p>


<pre class="pre codeblock language-java"><code>Observable
    .just(1, 2, 3, 4, 5)
    .groupBy(new Func1&lt;Integer, Boolean&gt;() {
        @Override
        public Boolean call(Integer integer) {
            return integer % 2 == 0;
        }
    }).subscribe(new Action1&lt;GroupedObservable&lt;Boolean, Integer&gt;&gt;() {
        @Override
        public void call(GroupedObservable&lt;Boolean, Integer&gt; grouped) {
            grouped.toList().subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {
                @Override
                public void call(List&lt;Integer&gt; integers) {
                    System.out.println(integers + " (Even: " + grouped.getKey() + ")");
                }
            });
        }
    });</code></pre>


   <p class="p">The example prints:</p>


<pre class="pre codeblock"><code>[1, 3, 5] (Even: false)
[2, 4] (Even: true)</code></pre>


	<p class="p">Combined with the Java SDK, this technique can be used to separate returned Documents based on their content. The following example uses a view to load all documents from the <samp class="ph codeph">beer-sample</samp> bucket, groups them by type and counts the number of occurrences:</p>


<pre class="pre codeblock language-java"><code>bucket
    .query(ViewQuery.from("my_design_doc", "my_view"))
    .flatMap(ViewResult::rows)
    .flatMap(ViewRow::document)
    .groupBy(document -&gt; document.content().getString("type"))
    .subscribe(observable -&gt;
        observable.count().subscribe(integer -&gt;
            System.out.println(observable.getKey() + ": " + integer)
        )
    );</code></pre>


    <p class="p">This code queries the view, extracts all rows, loads the full document for each row, groups it by the <samp class="ph codeph">type</samp> property in the JSON document and then uses the <span class="keyword apiname">count()</span> operator to count the number of rows emitted by each observable. This prints something like the following:</p>


<pre class="pre codeblock"><code>brewery: 1412
beer: 5891</code></pre>


		</section>


		<section class="section"><h2 class="title sectiontitle">Filtering observables</h2>
			

			<p class="p">In addition to transforming observables, you can also filter them. Filtering doesn't change the emitted values itself, but rather how much and at which point (and if at all) they are emitted.</p>


			<p class="p">For example, you can filter based on some criteria:</p>


<pre class="pre codeblock language-java"><code>// This will only let 3 and 4 pass.
Observable
    .just(1, 2, 3, 4)
    .filter(new Func1&lt;Integer, Boolean&gt;() {
        @Override
        public Boolean call(Integer integer) {
            return integer &gt; 2;
        }
    }).subscribe();</code></pre>


			<p class="p">Or take only the first N values emitted and then unsubscribe:</p>


<pre class="pre codeblock language-java"><code>// Only 1 and 2 will pass.
Observable
    .just(1, 2, 3, 4)
    .take(2)
    .subscribe();</code></pre>


			<p class="p">Or use only the first or last value emitted:</p>


<pre class="pre codeblock language-java"><code>// Only 1 will pass
Observable
    .just(1, 2, 3, 4)
    .first()
    .subscribe();</code></pre>


<pre class="pre codeblock language-java"><code>// Only 4 will pass
Observable
    .just(1, 2, 3, 4)
    .last()
    .subscribe();</code></pre>


			<p class="p">Finally, you can use distinct() to suppress duplicate values:</p>


<pre class="pre codeblock language-java"><code>// 1, 2, 3, 4 will be emitted
Observable
    .just(1, 2, 1, 3, 4, 2)
    .distinct()
    .subscribe();</code></pre>


    <div class="p"><div class="note note"><span class="notetitle">Note:</span> <span class="keyword apiname">distinct()</span> also allows you to pass in a function that returns the key to select by. You can use this, for example, to separate out duplicate <samp class="ph codeph">JsonDocument</samp> objects.</div>
</div>

		</section>


		<section class="section"><h2 class="title sectiontitle">Combining observables</h2>
			

			<p class="p">Multiple observables can also be merged to form a combined one. Depending on how you want those to be merged, there are different operators available. Two of the most used ones are <span class="keyword apiname">merge()</span> and <span class="keyword apiname">zip()</span> which are covered here.</p>


			<p class="p">Merge really just merges all emitted values by the source observables in the order they arrive:</p>

<pre class="pre codeblock language-java"><code>Observable
    .merge(evens, odds)
    .subscribe(new Action1&lt;Integer&gt;() {
        @Override
        public void call(Integer integer) {
            System.out.println(integer);
        }
    });</code></pre>


    	<p class="p">The example prints something similar to the following:</p>


<pre class="pre codeblock"><code>2
4
6
8
10
1
3
5
7
9</code></pre>


		<p class="p">With the zip operator, you can combine two streams in the strictly same order, defined by a function:</p>


<pre class="pre codeblock language-java"><code>Observable&lt;Integer&gt; evens = Observable.just(2, 4, 6, 8, 10);
Observable&lt;Integer&gt; odds = Observable.just(1, 3, 5, 7, 9);

Observable
    .zip(evens, odds, (v1, v2) -&gt; v1 + " + " + v2 + " is: " + (v1 + v2))
    .subscribe(System.out::println);</code></pre>


    	<p class="p">This zips the pairs together in order and prints:</p>


<pre class="pre codeblock"><code>2 + 1 is: 3
4 + 3 is: 7
6 + 5 is: 11
8 + 7 is: 15
10 + 9 is: 19</code></pre>


		</section>


		<section class="section"><h2 class="title sectiontitle">Error handling</h2><p class="p">Error handling is a vital component of every real world
                application and needs to be considered from the start. RxJava provides sophisticated
                mechanisms to deal with errors that happen inevitably in your observable
                flows.</p>
<p class="p">In general, you want to react in the following ways:</p>
<ul class="ul">
                <li class="li">Return a default value instead</li>

                <li class="li">Flip over to a backup observable</li>

                <li class="li">Retry the observable (immediately or with backoff)</li>

            </ul>
<p class="p">Returning a default value is a good idea if you cannot afford to retry or you
                just don't care (maybe because the flow is not crucial to your data flow). The
                following code throws an exception at the first emitted item, but falls back to a
                default value:</p>
<p class="p">Note that you can pass in a function that also takes the
                exception, so you can return different values for different exception types or use
                it for logging purposes.</p>
<pre class="pre codeblock language-java"><code>// Prints:
// Default
// Oops: I don't like: Apples
Observable
    .just("Apples", "Bananas")
    .doOnNext(s -&gt; {
        throw new RuntimeException("I don't like: " + s);
    })
    .onErrorReturn(throwable -&gt; {
        System.err.println("Oops: " + throwable.getMessage());
        return "Default";
    }).subscribe(System.out::println);</code></pre>
<p class="p">You can also flip to a backup observable
                that will be called if the first one fails. The Java SDK has a<span class="keyword apiname">
                    getFromReplica()</span> command, which allows you to read stale data from its
                replicas and treat availability for consistency on reads. You can use this approach
                to fall back:</p>
<pre class="pre codeblock language-java"><code>bucket
    .get("id")
    .onErrorResumeNext(bucket.getFromReplica("id", ReplicaMode.ALL))
    .subscribe();</code></pre>
<p class="p">Normally you want to have more control on which observable should
                be run next depending on the type of error. The following example will only go to
                the replica if a <samp class="ph codeph">TimeoutException</samp> happened (if not the error is
                passed down):</p>
<pre class="pre codeblock language-java"><code>bucket
    .get("id")
    .timeout(500, TimeUnit.MILLISECONDS)
    .onErrorResumeNext(new Func1&lt;Throwable, Observable&lt;? extends JsonDocument&gt;&gt;() {
        @Override
        public Observable&lt;? extends JsonDocument&gt; call(Throwable throwable) {
            if (throwable instanceof TimeoutException) {
                return bucket.getFromReplica("id", ReplicaMode.ALL);
            }
            return Observable.error(throwable);
        }
    });</code></pre>
<p class="p">Finally, it is possible to retry the observable by resubscribing. This can
                be done as quickly as possible, or with a backoff interval, which is preferred when
                external resources are involved.</p>
<p class="p">The following program desperately tries to
                read the numbers from 1 to 10, but a (not so hidden) flaw makes it randomly throw an
                exception. If that happens, the code retries. Since lots of values might be already
                emitted, we can use <span class="keyword apiname">distinct()</span> to filter those out.</p>
<pre class="pre codeblock language-java"><code>Observable
    .just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    .doOnNext(integer -&gt; {
        if (new Random().nextInt(10) + 1 == 5) {
            throw new RuntimeException("Boo!");
        }
    })
    .retry()
    .distinct()
    .subscribe(System.out::println);</code></pre>
<div class="p">
                <div class="note note"><span class="notetitle">Note:</span> If you only want to retry for a max amount, replace the
                        <span class="keyword apiname">retry()</span> with a <span class="keyword apiname">retry(count)</span>
                    call.</div>

            </div>
<p class="p">If you want to retry with backoff, you can use a technique like this:</p>
<pre class="pre codeblock language-java"><code>Observable
    .range(1, 10)
    .doOnNext(integer -&gt; {
        if (new Random().nextInt(10) + 1 == 5) {
            throw new RuntimeException("Boo!");
        }
    })
    .retryWhen(attempts -&gt;
        attempts.zipWith(Observable.range(1, 3), (n, i) -&gt; i)
        .flatMap(i -&gt; {
            System.out.println("delay retry by " + i + " second(s)");
            return Observable.timer(i, TimeUnit.SECONDS);
        }))
    .distinct()
    .subscribe(System.out::println);</code></pre>
<p class="p">The attempts get passed into the
                    <span class="keyword apiname">retryWhen()</span> method and zipped with the number of seconds to
                wait. The timer method is used to complete once its timer is done. If you run this
                code a few times to generate an exception (or more), you will see something similar
                to this:</p>
<pre class="pre codeblock"><code>1
2
3
4
delay retry by 1 second(s)
delay retry by 2 second(s)
5
6
7
8
9
10</code></pre>
Since Java SDK 2.1.2 the advanced <samp class="ph codeph">retryWhen</samp> are easier to write
            using the <samp class="ph codeph">RetryBuilder</samp> helper class. You can specify a filter on which
            kind of <samp class="ph codeph">Exception</samp> to retry, for how many attempts, and with any kind of
                <samp class="ph codeph">Delay</samp>.</section>


		<section class="section"><h2 class="title sectiontitle">Schedulers and threads</h2>
			

			<p class="p">Schedulers in RxJava are used to manage and control concurrency. Some operators implicitly use
				one or allow you to pass in a custom one.</p>


			<p class="p">RxJava ships with a bunch of preconfigured Schedulers by default, which are all accessible through the Schedulers class:</p>


			<ul class="ul">
				<li class="li"><span class="keyword apiname">Schedulers.computation()</span>: Event-loop style scheduler for purely computational work.</li>

		        <li class="li"><span class="keyword apiname">Schedulers.immediate()</span>: Executes the work immediately on the current thread.</li>

		        <li class="li"><span class="keyword apiname">Schedulers.io()</span>: Executes work on a Executor-backed pool, which
                    grows as needed.</li>

		        <li class="li"><span class="keyword apiname">Schedulers.newThread()</span>: Creates a new thread for each unit of work.</li>

		        <li class="li"><span class="keyword apiname">Schedulers.trampoline()</span>: Queues the work on the current thread and gets executed after the current work completes.</li>

		        <li class="li"><span class="keyword apiname">Schedulers.test()</span>: Test scheduler used for testing and debugging, which allows manual advancing of the clock.</li>

			</ul>


			<p class="p">As a rule of thumb, the computation scheduler should always be used for in-memory processing, while the I/O scheduler should only be used for blocking-style I/O operations (so do not use it together with the Java SDK because it is asynchronous anyway).</p>


			<p class="p">You can instruct an observable to be executed on such a scheduler in the following different ways:</p>


			<ul class="ul">
				<li class="li">Implicitly by using an operator that makes use of one</li>

				<li class="li">Explicitly by passing the Scheduler to such an operator</li>

				<li class="li">By using <span class="keyword apiname">subscribeOn(Scheduler)</span></li>

				<li class="li">By using <span class="keyword apiname">observeOn(Scheduler)</span></li>

			</ul>


			<p class="p">Operators like buffer, replay, skip, delay, parallel and so forth use a Scheduler by default if not instructed otherwise. A list of default schedulers can be found here: https://github.com/ReactiveX/RxJava/wiki/Scheduler#default-schedulers-for-rxjava-observable-operators</p>


			<p class="p">As a rule of thumb, all of those operators allow you to pass in a custom scheduler if needed, but most of the time sticking with the defaults is a good idea.</p>


			<div class="p"><div class="note note"><span class="notetitle">Note:</span> The Java SDK uses an internal scheduler similar to the computation scheduler to proper isolate the inner mechanisms from user-land. It is possible to change that Scheduler through the environment, but not recommended.</div>
</div>


			<p class="p">If you want the whole subscribe chain to be executed on a specific scheduler, you use the <span class="keyword apiname">subscribeOn()</span> operator. Without a scheduler set, the following code executes on the main thread:</p>


<pre class="pre codeblock language-java"><code>Observable
    .range(1, 5)
    .map(integer -&gt; {
        System.out.println("Map: (" + Thread.currentThread().getName() + ")");
        return integer + 2;
    })
    .subscribe(integer -&gt;
        System.out.println("Got: " + integer + " (" + Thread.currentThread().getName() + ")")
    );</code></pre>


            <p class="p">The example prints:</p>


<pre class="pre codeblock"><code>Map: (main)
Got: 3 (main)
Map: (main)
Got: 4 (main)
Map: (main)
Got: 5 (main)
Map: (main)
Got: 6 (main)
Map: (main)
Got: 7 (main)</code></pre>


		<p class="p">This example shows the <span class="keyword apiname">subscribeOn()</span> method added to the flow (it doesn't
				matter where you add it):</p>


<pre class="pre codeblock language-java"><code>Observable
    .range(1, 5)
    .map(integer -&gt; {
        System.out.println("Map: (" + Thread.currentThread().getName() + ")");
        return integer + 2;
    })
    .subscribeOn(Schedulers.computation())
    .subscribe(integer -&gt;
            System.out.println("Got: " + integer + " (" + Thread.currentThread().getName() + ")")
    );</code></pre>


        <p class="p">In the output of the example that uses <span class="keyword apiname">subscribeOn()</span>, you can see it
				is executed on the same thread, but on the computation thread pool:</p>


<pre class="pre codeblock"><code>Map: (RxComputationThreadPool-6)
Got: 3 (RxComputationThreadPool-6)
Map: (RxComputationThreadPool-6)
Got: 4 (RxComputationThreadPool-6)
Map: (RxComputationThreadPool-6)
Got: 5 (RxComputationThreadPool-6)
Map: (RxComputationThreadPool-6)
Got: 6 (RxComputationThreadPool-6)
Map: (RxComputationThreadPool-6)
Got: 7 (RxComputationThreadPool-6)</code></pre>


		<p class="p">If you need tighter control regarding which parts are executed on what pool, use
					<span class="keyword apiname">observeOn()</span>. Here, the order matters:</p>


<pre class="pre codeblock language-java"><code>Observable
    .range(1, 5)
    .map(integer -&gt; {
        System.out.println("Map: (" + Thread.currentThread().getName() + ")");
        return integer + 2;
    })
    .observeOn(Schedulers.computation())
    .subscribe(integer -&gt;
            System.out.println("Got: " + integer + " (" + Thread.currentThread().getName() + ")")
    );</code></pre>


       <p class="p">Everything before the <span class="keyword apiname">observeOn()</span> call is executed in
					<samp class="ph codeph">main</samp>, everything below in the scheduler:</p>


<pre class="pre codeblock"><code>Map: (main)
Map: (main)
Map: (main)
Got: 3 (RxComputationThreadPool-6)
Got: 4 (RxComputationThreadPool-6)
Got: 5 (RxComputationThreadPool-6)
Map: (main)
Map: (main)
Got: 6 (RxComputationThreadPool-6)
Got: 7 (RxComputationThreadPool-6)</code></pre>


		<p class="p">There is also a way to use schedulers directly to schedule operations. For more information
				about schedulers, refer to the RxJava documentation about schedulers.
				https://github.com/ReactiveX/RxJava/wiki/Scheduler#using-schedulers</p>

		</section>


		<section class="section"><h2 class="title sectiontitle">Subjects</h2>
			

			<p class="p">A subject is a hybrid between an observable and a subscriber. It can both receive and emit
				events. Most of the time you don't need subjects and can handle everything fine through
				observables alone, but there are certain cases when they come in handy.</p>


			<p class="p">There is a distinction between different observables that have not been covered yet:</p>


			<ul class="ul">
				<li class="li">A <strong class="ph b">cold</strong> Observable waits for a subscription until it emits values and does this freshly for every subscriber.</li>

				<li class="li">A <strong class="ph b">hot</strong> Observable begins emitting values upfront and presents them to every subscriber subsequently. Subjects are hot observables.</li>

			</ul>


			<div class="p"><div class="note note"><span class="notetitle">Note:</span> Because of the network layer in between, the Java SDK needs to use subjects for its request and response cycles. This also makes sense because if you subscribe twice to a <span class="keyword apiname">bucket.get()</span> call, you actually only want one network call instead of two.</div>
</div>


			<p class="p">Currently, these subjects are supported by RxJava, slightly differing in their functionality:</p>


			<ul class="ul">
				<li class="li"><samp class="ph codeph">AsyncSubject</samp>: emits the last value (and only the last value) emitted by the
					source observable, and only after that source observable completes. (If the source
					observable does not emit any values, the AsyncSubject also completes without emitting
					any values.)</li>

				<li class="li"><samp class="ph codeph">BehaviorSubject</samp>: When a subscriber subscribes to a
                        <samp class="ph codeph">BehaviorSubject</samp>, it begins by emitting the item most
                    recently emitted by the source observable (or an optional seed or default value
                    if none has yet been emitted) and then continues to emit any other items emitted
                    later by the source observables.</li>

				<li class="li"><samp class="ph codeph">PublishSubject:</samp>
					<samp class="ph codeph">PublishSubject</samp> emits to a subscriber only those items that are
					emitted by the source observables subsequent to the time of the subscription.</li>

				<li class="li"><samp class="ph codeph">ReplaySubject</samp>: <samp class="ph codeph">ReplaySubject</samp> emits to any subscriber all
					of the items that were emitted by the source observables, regardless of when the
					subscriber subscribes.</li>

			</ul>


			<p class="p">As an example: if you call <span class="keyword apiname">bucket.get()</span>, an <samp class="ph codeph">AsyncSubject</samp>
                is created under the covers and returned to you immediately. In addition, it is
                passed down the I/O layer and stored. When a response arrives from the server, the
                subject is fed with the response, and you get notified appropriately.</p>


			<p class="p">If you need to use a subject, choose wisely which one to use in order to keep resource usage low (some of them cache data for subscribers) especially if you push lots of data through them. You can read more about them here: https://github.com/ReactiveX/RxJava/wiki/Subject</p>


			<p class="p">There is one last thing you need to know when dealing with subjects: because you are not getting new values when resubscribing (because it's cached), the following won't work (doing a get call every second):</p>


<pre class="pre codeblock language-java"><code>bucket
    .get("id")
    .delay(1, TimeUnit.SECONDS)
    .repeat()
    .subscribe();</code></pre>


            <p class="p">This will only execute one get call, because subsequent attempts only load the cached value. For this reason <span class="keyword apiname">Observable.defer()</span> was added, which creates a new observable for every subscriber that comes along:</p>


<pre class="pre codeblock language-java"><code>Observable.defer(new Func0&lt;Observable&lt;JsonDocument&gt;&gt;() {
    @Override
    public Observable&lt;JsonDocument&gt; call() {
        return bucket.get("id");
    }
})
.delay(1, TimeUnit.SECONDS)
.repeat()
.subscribe();</code></pre>


		</section>


	</div>

<nav class="related-links"><h2>Related information</h2>
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="../../developer/java-2.1/java-intro.html" title="The Couchbase Java SDK provides synchronous and asynchronous (reactive) interfaces that allow your applications to efficiently interact with a Couchbase Server cluster. It provides capabilities to store, update, and retrieve documents in the database and query the database by using N1QL.">Java SDK 2.1</a></div>
<div class="previouslink"><strong>Previous topic:</strong> <a class="link" href="../../developer/java-2.1/querying.html" title="The Java SDK supports a wide range of querying features, including views and the N1QL query language.">Querying buckets</a></div>
<div class="nextlink"><strong>Next topic:</strong> <a class="link" href="../../developer/java-2.1/logging.html" title="The Couchbase Java SDK has no hard dependency on a specific logger implementation. It tries to find a logger on the class path and uses that logger if it is supported by the SDK. If no logger implementation is found, the standard JDK logger is used.">Setting up logging</a></div>
</div>
</nav></div><footer class="developer-portal-footer" role="contentinfo"><p class="legal"><span class="license">© 2011–2015 <b class="company-name">Couchbase</b>. All rights reserved.</span><a href="http://support.couchbase.com/">Customer Login</a><a href="http://www.couchbase.com/terms-of-service">Terms of Service</a><a href="http://www.couchbase.com/privacy-policy">Privacy Policy</a></p></footer></div></main><script src="../../assets/javascripts/vendor/prism.js"></script><script type="text/javascript">var BASEPATH='../../';</script><script src="../../assets/javascripts/init.js"></script><script type="text/javascript" src="https://issues.couchbase.com/s/en_US-pvmaib-418945332/845/131/1.2.9/_/download/batch/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector.js?collectorId=86389172"></script></body></html>