<!DOCTYPE html><html xmlns:related-links="http://dita-ot.sourceforge.net/ns/200709/related-links" class="no-js developer-portal" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><title>Bulk operations — Couchbase Server 3.0/3.1</title><meta name="apple-mobile-web-app-title" content="Couchbase"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-precomposed.png"><link rel="stylesheet" href="../../assets/stylesheets/application.css"><link rel="stylesheet" href="../../assets/stylesheets/docs.css"></head><body data-modules="developer-portal-sidebar-navigation developer-portal-versions-navigation">
	<!-- Google Tag Manager -->
				<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-MVPNN2"
					height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
				<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
					new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
					j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
					'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
					})(window,document,'script','dataLayer','GTM-MVPNN2');</script>
				<!-- End Google Tag Manager -->
				<header class="developer-portal-header" role="banner"><div class="layout-wrapper"><div class="developer-portal-header__hgroup"><h1 class="developer-portal-header__logo"><a href="http://couchbase.com" rel="home">Couchbase</a></h1><p class="developer-portal-header__page-title">Couchbase Server 3.0/3.1</p></div><nav class="developer-portal-header__navigation" id="primary-navigation" role="navigation"><div class="developer-portal-header__navigation__wrapper" id="primary-navigation__wrapper"><ul class="developer-portal-header__navigation__items"><li class="developer-portal-header__navigation__item"><a href="/index.html">Documentation Home</a></li><li class="developer-portal-header__navigation__item"><a href="http://www.couchbase.com/nosql-databases/downloads">Downloads</a></li><li class="developer-portal-header__navigation__item"><a href="http://www.couchbase.com/open-source">Open Source Projects</a></li><li class="developer-portal-header__navigation__item"><a href="http://forums.couchbase.com">Forums</a></li></ul><div class="developer-portal-header__search"><script>
					  (function() {
					    var cx = '018016427239405524608:fkg1v30apnm';
					    var gcse = document.createElement('script');
					    gcse.type = 'text/javascript';
					    gcse.async = true;
					    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
					        '//www.google.com/cse/cse.js?cx=' + cx;
					    var s = document.getElementsByTagName('script')[0];
					    s.parentNode.insertBefore(gcse, s);
					  })();
					</script><gcse:search></gcse:search></div></div></nav></div></header><main class="developer-portal-global-content" role="main"><aside class="developer-portal-sidebar"><nav class="developer-portal-sidebar__navigation"><div class="developer-portal-sidebar__navigation__wrapper" id="developer-portal-sidebar-navigation"><ul><li class="section section--has-sub-sections"><a href="../../admin/Couchbase-intro.html"><span>Introduction</span></a></li><li class="section"><a href="../../admin/Whats-new-3.0.html"><span>What's new in 3.0</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/install-intro.html"><span>Installation and upgrade</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/admin-intro.html"><span>Administration</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/Views/views-intro.html"><span>Views and indexes</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/cli-intro.html"><span>CLI reference</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/rest-intro.html"><span>REST API reference</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/rel-notes/rel-notes3.0.html"><span>Release notes</span></a></li><li class="section"><a href="../../admin/pdfs.html"><span>PDFs</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/dev-guide-3.0/intro.html"><span>Overview</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/dev-guide-3.0/concepts.html"><span>Developing applications</span></a></li><li class="section section--has-sub-sections&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;section--active"><a href="../../developer/dev-guide-3.0/old-versions.html"><span>Older SDK versions</span></a><ul class="sub-sections"><li class="section section--has-sub-sections"><a href="../../developer/java-2.1/java-intro.html"><span>Java SDK 2.1</span></a></li><li class="section section--has-sub-sections&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;section--active"><a href="../../developer/java-2.0/java-intro.html"><span>Java SDK 2.0</span></a><ul class="sub-sections"><li class="section"><a href="../../developer/java-2.0/overview.html"><span>Overview</span></a></li><li class="section"><a href="../../developer/java-2.0/download-links.html"><span>Download and API Reference</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/java-2.0/getting-started.html"><span>Getting started</span></a></li><li class="section"><a href="../../developer/java-2.0/managing-connections.html"><span>Managing connections</span></a></li><li class="section section--has-sub-sections&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;section--active"><a href="../../developer/java-2.0/documents.html"><span>Working with documents</span></a><ul class="sub-sections"><li class="section"><a href="../../developer/java-2.0/documents-basics.html"><span>Document basics</span></a></li><li class="section"><a href="../../developer/java-2.0/documents-creating.html"><span>Creating documents</span></a></li><li class="section"><a href="../../developer/java-2.0/documents-updating.html"><span>Updating documents</span></a></li><li class="section"><a href="../../developer/java-2.0/documents-retrieving.html"><span>Retrieving documents</span></a></li><li class="section"><a href="../../developer/java-2.0/documents-deleting.html"><span>Deleting documents</span></a></li><li class="section"><a href="../../developer/java-2.0/documents-atomic.html"><span>Atomic operations</span></a></li><li class="section"><a href="../../developer/java-2.0/documents-bulk.html" class="current"><span>Bulk operations</span></a><ul class="sub-sections"></ul></li></ul></li><li class="section section--has-sub-sections"><a href="../../developer/java-2.0/querying.html"><span>Querying buckets</span></a></li><li class="section"><a href="../../developer/java-2.0/observables.html"><span>Mastering observables</span></a></li><li class="section"><a href="../../developer/java-2.0/logging.html"><span>Setting up logging</span></a></li><li class="section"><a href="../../developer/java-2.0/release-notes.html"><span>Release notes</span></a></li></ul></li><li class="section section--has-sub-sections"><a href="../../developer/dotnet-2.1/dotnet-intro.html"><span>.NET SDK 2.1</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/dotnet-2.0/dotnet-intro.html"><span>.NET SDK 2.0</span></a></li></ul></li></ul></div></nav></aside><div class="developer-portal-content"><div class="developer-portal-content__wrapper textblock__content">
	<h1 class="title topictitle1" id="ariaid-title1">Bulk operations</h1>

	
	<div class="body conbody"><p class="shortdesc">Describes how to operate on more than one document at the same time.</p>


		<section class="section"><h2 class="title sectiontitle">Introduction</h2>
			

			<p class="p">The Java SDK 1.4 and earlier had explicit methods for batch operations, that is operate on more than
				one document at the same time. They have been removed from both the sync and async APIs on this SDK,
				but we are planning to bring them back in the 2.1 release.</p>


			<p class="p">We understand that there is a need to perform all kinds of operations in batches to get beter resource
				utilization, and there is a very good way to do it right now. Because of the asynchronous nature of the
				underlying core package, we can utilize RxJava's operations to provide implict batching facilities combined
				with the asynchronous operations of the SDK.</p>


			<p class="p">If you understand the general approach to batching, you can apply it to any operation against the SDK, not
				just with <samp class="ph codeph">get()</samp> calls like in the 1.* series.</p>

		</section>


		<section class="section"><h2 class="title sectiontitle">Batching with RxJava</h2>
			


			<div class="p">Implicit batching is performed by utilizing a few operators:
				<ul class="ul">
					<li class="li"><samp class="ph codeph">Observable.just()</samp> or <samp class="ph codeph">Observable.from()</samp> to generate an Observable that contains the data we want to batch on.</li>

					<li class="li"><samp class="ph codeph">flatMap()</samp> to send those events against the Couchbase Java SDK and merge the results
					asynchronously.</li>

					<li class="li"><samp class="ph codeph">last()</samp> if we want to wait until we receive the last element of the batch.</li>

					<li class="li"><samp class="ph codeph">toList()</samp> if we care about the responses and want to aggregate it easily.</li>

					<li class="li">If we have more than one subscriber, using <samp class="ph codeph">cache()</samp> to prevent accessing the network
					over and over again with every subscribe.</li>

				</ul>

			</div>


			<p class="p">The following example creates an Observable stream of 5 keys (which we want to load in a batch), asynchronously fires off <samp class="ph codeph">get()</samp> requests against the SDK, waits until the last result
			has arrived, and then converts the result into a list and blocks at the very end:</p>


<pre class="pre codeblock language-java"><code>Cluster cluster = CouchbaseCluster.create();
Bucket bucket = cluster.openBucket();


List&lt;JsonDocument&gt; foundDocs = Observable
    .just("key1", "key2", "key3", "key4", "key5")
    .flatMap(new Func1&lt;String, Observable&lt;JsonDocument&gt;&gt;() {
        @Override
        public Observable&lt;JsonDocument&gt; call(String id) {
            return bucket.async().get(id);
        }
    })
    .toList()
    .toBlocking()
    .single();</code></pre>


 			<p class="p">Note that this will return you always a list, but it may contain 0 to 5 documents, depending on how much are actually found. Also, at the very end we are converting the Observable into a blocking one, but everything before that, including the network calls and the aggregation, is happening completely asynchronously.</p>


 			<p class="p">Inside the SDK, this provides much more efficient resource utilization because the requests are very quickly stored in the internal <samp class="ph codeph">Request RingBuffer</samp> and the IO threads are able to pick batches as large
 			as they can. Afterwards, whatever server returns a result first it is stored in the list, so there are is no serialization of responses going on.</p>


 			<p class="p">If you wrap the code in a helper method, you can provide very nice encapsulated batching semantics:</p>


 <pre class="pre codeblock language-java"><code>public List&lt;JsonDocument&gt; bulkGet(final Collection&lt;String&gt; ids) {
    return Observable
        .from(ids)
        .flatMap(new Func1&lt;String, Observable&lt;JsonDocument&gt;&gt;() {
            @Override
            public Observable&lt;JsonDocument&gt; call(String id) {
                return bucket.async().get(id);
            }
        })
        .toList()
        .toBlocking()
        .single();
}</code></pre>


		</section>


		<section class="section"><h2 class="title sectiontitle">Batching mutations</h2>
			

			<p class="p">In the previous Java SDK, we did only provide bulk operations for <samp class="ph codeph">get()</samp>. With the techniques shown above, you are able to perfom any kind of operation as a batch.</p>


			<p class="p">The following code generates a number of fake documents and inserts them in one batch. Note that you can decide to either collect the results with <samp class="ph codeph">toList()</samp> as shown above or just use <samp class="ph codeph">last()</samp> as shown here to wait until the last document is properly inserted.</p>


 <pre class="pre codeblock language-java"><code>// Generate a number of dummy JSON documents
int docsToCreate = 100;
List&lt;JsonDocument&gt; documents = new ArrayList&lt;JsonDocument&gt;();
for (int i = 0; i &lt; docsToCreate; i++) {
    JsonObject content = JsonObject.create()
        .put("counter", i)
        .put("name", "Foo Bar");
    documents.add(JsonDocument.create("doc-"+i, content));
}

// Insert them in one batch, waiting until the last one is done.
Observable
    .from(documents)
    .flatMap(new Func1&lt;JsonDocument, Observable&lt;JsonDocument&gt;&gt;() {
        @Override
        public Observable&lt;JsonDocument&gt; call(final JsonDocument docToInsert) {
            return bucket.async().insert(docToInsert);
        }
    })
    .last()
    .toBlocking()
    .single();</code></pre>


		</section>


		<section class="section"><h2 class="title sectiontitle">Performance</h2>
			

			<p class="p">Here are two code samples, both synchronous, which showcase serialized and batched loading of documents. Note that more important than the absolute operations per second is the relative improvement with the same workload.</p>


 <pre class="pre codeblock language-java"><code>// Serialized workload of loading documents
while(true) {
    List&lt;JsonDocument&gt; loaded = new ArrayList&lt;JsonDocument&gt;();
    int docsToLoad = 10;
    for (int i = 0; i &lt; docsToLoad; i++) {
        JsonDocument doc = bucket.get("doc-" + i);
        if (doc != null) {
            loaded.add(doc);
        }
    }
}</code></pre>


			<p class="p">
				<img class="image" id="concept2677__image_i31_yqb_3p" src="images/batching-single.png">
			</p>


 <pre class="pre codeblock language-java"><code>// Same workload, utilizing batching effects
while(true) {
    int docsToLoad = 10;
    Observable
        .range(0, docsToLoad)
        .flatMap(new Func1&lt;Integer, Observable&lt;?&gt;&gt;() {
            @Override
            public Observable&lt;?&gt; call(Integer i) {
                return bucket.async().get("doc-"+i);
            }
        })
        .toList()
        .toBlocking()
        .single();

}</code></pre>


			<p class="p">
				<img class="image" id="concept2677__image_batch_bulk" src="images/batching-bulk.png">
			</p>



		</section>


	</div>

<nav class="related-links"><h2>Related information</h2>
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="../../developer/java-2.0/documents.html">Working with documents</a></div>
<div class="previouslink"><strong>Previous topic:</strong> <a class="link" href="../../developer/java-2.0/documents-atomic.html" title="The CouchbaseBucket class provides atomic operations such as counter(), append(), and prepend().">Atomic operations</a></div>
</div>
</nav></div><footer class="developer-portal-footer" role="contentinfo"><p class="legal"><span class="license">© 2011–2015 <b class="company-name">Couchbase</b>. All rights reserved.</span><a href="http://support.couchbase.com/">Customer Login</a><a href="http://www.couchbase.com/terms-of-service">Terms of Service</a><a href="http://www.couchbase.com/privacy-policy">Privacy Policy</a></p></footer></div></main><script src="../../assets/javascripts/vendor/prism.js"></script><script type="text/javascript">var BASEPATH='../../';</script><script src="../../assets/javascripts/init.js"></script><script type="text/javascript" src="https://issues.couchbase.com/s/en_US-pvmaib-418945332/845/131/1.2.9/_/download/batch/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector.js?collectorId=86389172"></script></body></html>