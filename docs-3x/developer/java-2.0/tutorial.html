<!DOCTYPE html><html xmlns:related-links="http://dita-ot.sourceforge.net/ns/200709/related-links" class="no-js developer-portal" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><title>Tutorial — Couchbase Server 3.0/3.1</title><meta name="apple-mobile-web-app-title" content="Couchbase"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-precomposed.png"><link rel="stylesheet" href="../../assets/stylesheets/application.css"><link rel="stylesheet" href="../../assets/stylesheets/docs.css"></head><body data-modules="developer-portal-sidebar-navigation developer-portal-versions-navigation">
	<!-- Google Tag Manager -->
				<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-MVPNN2"
					height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
				<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
					new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
					j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
					'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
					})(window,document,'script','dataLayer','GTM-MVPNN2');</script>
				<!-- End Google Tag Manager -->
				<header class="developer-portal-header" role="banner"><div class="layout-wrapper"><div class="developer-portal-header__hgroup"><h1 class="developer-portal-header__logo"><a href="http://couchbase.com" rel="home">Couchbase</a></h1><p class="developer-portal-header__page-title">Couchbase Server 3.0/3.1</p></div><nav class="developer-portal-header__navigation" id="primary-navigation" role="navigation"><div class="developer-portal-header__navigation__wrapper" id="primary-navigation__wrapper"><ul class="developer-portal-header__navigation__items"><li class="developer-portal-header__navigation__item"><a href="/index.html">Documentation Home</a></li><li class="developer-portal-header__navigation__item"><a href="http://www.couchbase.com/nosql-databases/downloads">Downloads</a></li><li class="developer-portal-header__navigation__item"><a href="http://www.couchbase.com/open-source">Open Source Projects</a></li><li class="developer-portal-header__navigation__item"><a href="http://forums.couchbase.com">Forums</a></li></ul><div class="developer-portal-header__search"><script>
					  (function() {
					    var cx = '018016427239405524608:fkg1v30apnm';
					    var gcse = document.createElement('script');
					    gcse.type = 'text/javascript';
					    gcse.async = true;
					    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
					        '//www.google.com/cse/cse.js?cx=' + cx;
					    var s = document.getElementsByTagName('script')[0];
					    s.parentNode.insertBefore(gcse, s);
					  })();
					</script><gcse:search></gcse:search></div></div></nav></div></header><main class="developer-portal-global-content" role="main"><aside class="developer-portal-sidebar"><nav class="developer-portal-sidebar__navigation"><div class="developer-portal-sidebar__navigation__wrapper" id="developer-portal-sidebar-navigation"><ul><li class="section section--has-sub-sections"><a href="../../admin/Couchbase-intro.html"><span>Introduction</span></a></li><li class="section"><a href="../../admin/Whats-new-3.0.html"><span>What's new in 3.0</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/install-intro.html"><span>Installation and upgrade</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/admin-intro.html"><span>Administration</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/Views/views-intro.html"><span>Views and indexes</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/cli-intro.html"><span>CLI reference</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/rest-intro.html"><span>REST API reference</span></a></li><li class="section section--has-sub-sections"><a href="../../admin/rel-notes/rel-notes3.0.html"><span>Release notes</span></a></li><li class="section"><a href="../../admin/pdfs.html"><span>PDFs</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/dev-guide-3.0/intro.html"><span>Overview</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/dev-guide-3.0/concepts.html"><span>Developing applications</span></a></li><li class="section section--has-sub-sections&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;section--active"><a href="../../developer/dev-guide-3.0/old-versions.html"><span>Older SDK versions</span></a><ul class="sub-sections"><li class="section section--has-sub-sections"><a href="../../developer/java-2.1/java-intro.html"><span>Java SDK 2.1</span></a></li><li class="section section--has-sub-sections&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;section--active"><a href="../../developer/java-2.0/java-intro.html"><span>Java SDK 2.0</span></a><ul class="sub-sections"><li class="section"><a href="../../developer/java-2.0/overview.html"><span>Overview</span></a></li><li class="section"><a href="../../developer/java-2.0/download-links.html"><span>Download and API Reference</span></a></li><li class="section section--has-sub-sections&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;section--active"><a href="../../developer/java-2.0/getting-started.html"><span>Getting started</span></a><ul class="sub-sections"><li class="section"><a href="../../developer/java-2.0/hello-couchbase.html"><span>Hello Couchbase Example</span></a></li><li class="section"><a href="../../developer/java-2.0/tutorial.html" class="current"><span>Tutorial</span></a><ul class="sub-sections"></ul></li></ul></li><li class="section"><a href="../../developer/java-2.0/managing-connections.html"><span>Managing connections</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/java-2.0/documents.html"><span>Working with documents</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/java-2.0/querying.html"><span>Querying buckets</span></a></li><li class="section"><a href="../../developer/java-2.0/observables.html"><span>Mastering observables</span></a></li><li class="section"><a href="../../developer/java-2.0/logging.html"><span>Setting up logging</span></a></li><li class="section"><a href="../../developer/java-2.0/release-notes.html"><span>Release notes</span></a></li></ul></li><li class="section section--has-sub-sections"><a href="../../developer/dotnet-2.1/dotnet-intro.html"><span>.NET SDK 2.1</span></a></li><li class="section section--has-sub-sections"><a href="../../developer/dotnet-2.0/dotnet-intro.html"><span>.NET SDK 2.0</span></a></li></ul></li></ul></div></nav></aside><div class="developer-portal-content"><div class="developer-portal-content__wrapper textblock__content">
	<h1 class="title topictitle1" id="ariaid-title1">Tutorial</h1>

	<div class="body conbody">

		<section class="section">
			<p class="p">This tutorial builds on the material covered in the Getting Started section and
				introduces some more advanced concepts to build a complete web application. The full
				source code for the example is available <a class="xref" href="https://github.com/couchbaselabs/beersample-java2" target="_blank"> on GitHub</a>. The primary focus of this tutorial is to explain the
				function and theory behind the Couchbase client and how it connects to Couchbase server.
				Therefore, we will provide the surrounding code that will generate a full web
				application and its operation is not included in the scope of this tutorial.</p>

		</section>


		<section class="section"><h2 class="title sectiontitle">Preview the Application</h2>
			
			<p class="p">Download the JAR archive and run it using the command <samp class="ph codeph">java -jar
					couchbaseBeersampleExample.jar</samp>. You should see the Spring framework start up
				and begin logging the application, once it has finished initializing you can navigate to
					<a class="xref" href="http://localhost:8081/">http://localhost:8081/</a> to
				view the application.</p>

		</section>

		<section class="section"><h2 class="title sectiontitle">Preparation</h2>
			
			<p class="p">To get ready to build your first app, you need to install Couchbase Server and set up
				your IDE.</p>

			<strong class="ph b">Installing Couchbase Server</strong>
			<p class="p">Download the latest <a class="xref" href="http://www.couchbase.com/download" target="_blank">Couchbase Server 3.0 release</a> and install it. As you follow the
				download instructions and setup wizard, make sure you install the beer-sample default
				bucket as it contains the beer and brewery sample data used in this tutorial.</p>

			<p class="p">If you already have Couchbase Server 3.0 but do not have the
					<samp class="ph codeph">beer-sample</samp> bucket installed, open the Couchbase Web Console and
				select Settings &gt; Sample Buckets. Select the beer-sample checkbox, and then click
				Create. A notification box in the upper-right corner disappears when the bucket is ready
				to use.</p>

			<strong class="ph b">Creating your views</strong>
			<p class="p">Views enable you to index and query data from your database. The
					<samp class="ph codeph">beer-sample</samp> bucket comes with a small set of predefined view
				functions, but to add further functionality to our application we will need some more.
				This is also a very good chance for you to see how you can manage views inside the
				Couchbase Web Console. </p>

			<p class="p">We want our users to be able to view a list of both beers and breweries. Therefore we
				need to define one view function for each type of document that will respond with the
				relevant information for each query. As such we will be creating two view functions, one
				for beers and one for breweries. First, the beers;</p>

			<ol class="ol">
				<li class="li">In Couchbase Web Console, click <strong class="ph b">Views</strong></li>

				<li class="li">From the drop-down list box, choose the <strong class="ph b">beer-sample</strong> bucket</li>

				<li class="li">Click <span class="ph uicontrol">Development Views</span>, and then click <span class="ph uicontrol">Create Development View</span> to
					define your first view.</li>

				<li class="li">Give the view the names of both the design document and the actual view. Insert the
					following names: <ul class="ul">
						<li class="li">Design Document Name: <samp class="ph codeph">_design/dev_beer</samp></li>

						<li class="li">View Name: <samp class="ph codeph">by_name</samp></li>

					</ul>
 The next step is to define the <samp class="ph codeph">map</samp> function and optionally a
						<samp class="ph codeph">reduce</samp> function to perform further computation on the index
					results. In our example, we do not use the <samp class="ph codeph">reduce</samp> functions at all,
					but you can play around with reduce functions to see how they work. For more
					information about reduce functions, see <a class="xref" href="../dev-guide-3.0/built-in-reduce.html#concept4045">Using built-in reduces</a> and <a class="xref" href="../dev-guide-3.0/custom-reduces.html#concept8148">Creating custom reduces</a>. 
				</li>

				<li class="li">Insert the following JavaScript <samp class="ph codeph">map</samp> function and click <strong class="ph b">Save</strong>. <pre class="pre codeblock language-javascript"><code>
function (doc, meta) {
   if(doc.type &amp;&amp; doc.type == "beer") {
     emit(doc.name, doc.brewery_id);
   }
}</code></pre>

				</li>

			</ol>

			<p class="p">Every <samp class="ph codeph">map</samp> function takes the full document (<samp class="ph codeph">doc</samp>) and
				its associated metadata (<samp class="ph codeph">meta</samp>) as the arguments. Your map function can
				then inspect this data and <samp class="ph codeph">emit</samp> the item to a result set to be added to
				an index. In our case we emit the name of the beer (<samp class="ph codeph">doc.name</samp>) when the
				document has a type field and the type is <samp class="ph codeph">beer</samp>. We also want to use the
				brewery associated with the beer, so for our value we will emit the
					<samp class="ph codeph">doc.brewery_id</samp>.</p>

			<p class="p">In general, you should try to keep the index as small as possible. You should resist the
				urge to include the full document with <samp class="ph codeph">emit(meta.id, doc)</samp>, because it
				will increase the size of your view indexes and potentially impact application
				performance. If you need to access the full document or large parts of it, use the
					<samp class="ph codeph">.document()</samp> method, which does a <samp class="ph codeph">get()</samp> call with
				the document ID in the background.</p>

			<p class="p">Now we need to provide a similar map function for the breweries. Because you already
				know how to do this, here is all the information you need to create it is below. An
				important thing to note is that for our application we do not need a further value other
				than the brewery name; therefore we emit a <samp class="ph codeph">null</samp> here.</p>

			<ol class="ol">
				<li class="li">Design Document Name: <samp class="ph codeph">_design/dev_brewery</samp></li>

				<li class="li">View Name: <samp class="ph codeph">by_name</samp></li>

				<li class="li">Map Function: <pre class="pre codeblock language-javascript"><code>
function (doc, meta) {
   if(doc.type &amp;&amp; doc.type == "brewery") {
     emit(doc.name, null);
   }
}</code></pre>

				</li>

			</ol>

			<p class="p">The final step is to push the design documents to production mode for Couchbase Server.
				While the design documents are in development mode, the index is applied only on the
				local node. For more information about design document modes, see <a class="xref" href="http://docs.couchbase.com/admin/admin/Views/views-development.html" target="_blank">Development views</a> and <a class="xref" href="http://docs.couchbase.com/admin/admin/Views/views-production.html" target="_blank">Production views</a>.</p>

			<p class="p"> To have the index on the whole data set:</p>

			<ol class="ol">
				<li class="li">In Couchbase Web Console, click <strong class="ph b">Views</strong></li>

				<li class="li">Click the <strong class="ph b">Publish</strong> button on both design document</li>

				<li class="li">Accept any dialog that warns you from overriding the old view function</li>

			</ol>

			<p class="p">For more information about using views for indexing and querying from Couchbase Server,
				see the following useful resources:</p>

			<ul class="ul">
				<li class="li">General Information about views: 
					<a class="xref" href="http://docs.couchbase.com/admin/admin/Views/views-intro.html" target="_blank">Views and indexes</a>
					</li>

				<li class="li">Examples and patterns you can use for views, including patterns for extracting information based on date or time: 
					<a class="xref" href="http://docs.couchbase.com/admin/admin/Views/views-querySample.html" target="_blank">View and query pattern samples</a></li>

					
				
			</ul>

			<strong class="ph b">Setting up your IDE</strong>
			<p class="p">In this project will we be making heavy use of <a class="xref" href="http://maven.apache.org/" target="_blank">Maven</a> for dependency management, therefore it
				is recommended that you familiarize yourself with Maven for your chosen IDE or from the
				command line. Here is the <span class="ph filepath">pom.xml</span> that you can use for full
				dependency management:</p>

			<pre class="pre codeblock language-xml"><code>
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;com.couchbase&lt;/groupId&gt;
  &lt;artifactId&gt;beersample&lt;/artifactId&gt;
  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

  &lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.1.5.RELEASE&lt;/version&gt;
  &lt;/parent&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;log4j&lt;/groupId&gt;
      &lt;artifactId&gt;log4j&lt;/artifactId&gt;
      &lt;version&gt;1.2.17&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.couchbase.client&lt;/groupId&gt;
        &lt;artifactId&gt;java-client&lt;/artifactId&gt;
        &lt;version&gt;2.0.0&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</code></pre>

			<p class="p">For reference, here is the directory structure used for this example application:</p>

			<pre class="pre codeblock language-java"><code>
|-target
|-src
|---com
|------couchbase
|---------beersample
|---------resources
|------------css
|---------templates</code></pre>

			<strong class="ph b">Download the framework</strong>
			<p class="p">The framework for the tutorial can be downloaded from <a class="xref" href="http://www.example.org/" target="_blank">here</a>. It
				includes the <a class="xref" href="http://spring.io" target="_blank">Spring</a>
				web framework and the surrounding code that will take our Couchbase connections and form
				a complete application. The next section of the tutorial will explain the inner workings
				of the <span class="keyword apiname">ConnctionManager</span> class, currently blank, that will deal with
				the applications connections with your Couchbase server.</p>

		</section>


		<section class="section"><h2 class="title sectiontitle">Connection Manager</h2>
			
			<p class="p">The primary focus of this tutorial is the <span class="keyword apiname">ConnectionManager</span> class
				located in the <strong class="ph b">src/com/couchbase/beersample</strong> directory. The class will be
				responsible for starting and stopping the <samp class="ph codeph">CouchbaseClient</samp> and dealing
				with all interactions between the application and the Couchbase server. Here is the
				initial part of the class that deals with connecting to Couchbase:</p>

			<pre class="pre codeblock language-java"><code>
public class ConnectionManager {

private static final ConnectionManager connectionManager = new ConnectionManager();

  public static ConnectionManager getInstance() {
  	return connectionManager;
  }

  static Cluster cluster = CouchbaseCluster.create();
  static Bucket bucket = cluster.openBucket("beer-sample");

  public static void disconnect() {
  	cluster.disconnect().toBlocking().single();
  }</code></pre>


			<p class="p">As discussed in the managing connections section of the documentation, it is important
				to reuse the Couchbase connections so that the underlying resources are not duplicated
				for each connection. Therefore the ConnectionManager class has been created as a
					singleton. The Spring framework automatically creates all classes as
				singletons automatically, but the class is also written to be a singleton regardless of
				the framework you are using. The important message is that you only create one
				connection to the Couchbase cluster and one connection to each bucket you are using,
				then statically reference those connections for each use. The line
					<samp class="ph codeph">ConnectionManager connectionManager = new ConnectionManager();</samp> and
				the <samp class="ph codeph">getInstance()</samp> method are used to create a single instance of the
				class and allow other classes to access the singleton.</p>


			<p class="p">The line <samp class="ph codeph">static Cluster cluster = CouchbaseCluster.create();</samp> creates a
				new Couchbase connection object and makes the initial connection to the cluster. In this
				example we have not supplied any IP addresses to connect to as we are running a
				Couchbase server on the local machine. However, if you are using a cluster external to
				your local machine you can pass the ConnectionManager method a string, several strings
				or a list of strings so that it can connect to multiple nodes should a connection to a
				single node fail.</p>


			<p class="p">We next need to connect to the bucket that is storing our data, in this case we are
				using the <strong class="ph b">beer-sample</strong> bucket provided as part of your Couchbase install. As with
				connecting to the cluster it is important to create a single connection and re-use it
				multiple times throughout your code. In this line <samp class="ph codeph">static Bucket bucket =
					cluster.openBucket("beer-sample");</samp> we are creating a connection to the
				bucket. As covered in other areas of the documentation, the Couchbase Java SDK provides
				both synchronous and asynchronous APIs that allow you to easily harness
				the power of asynchronous computation while maintaining the simplicity of synchronous
				operations. In this case we are choosing to connect to both the cluster and the bucket
				synchronously as most of our application will be required to be synchronous, loading
				data before a web page can be generated. However, the asynchronous API is explained later
				on for use in creating view queries.</p>


			<p class="p">The disconnect method is included even though it is not explicitly called in this example. It
				is worth noting that when you call the <span class="keyword apiname">disconnect()</span> method on the
				cluster it will, like many other commands, return an <samp class="ph codeph">observable</samp> that
				you can use to verify that an operation has completed. Once again we call
					<span class="keyword apiname">toBlocking()</span> and <span class="keyword apiname">single()</span> to synchronize the
				operation. Although the method given in this example does not return the object
				generated by the disconnect operation, we could modify it to and use the object to
				ensure the cluster has disconnected before moving on.</p>


			<p class="p">Now that we have dealt with connecting to the cluster and the bucket we can move onto
				completing some useful operations, beginning with querying the database for a single
				document. We will be using the following code, which connects to the Couchbase server,
				searches for a given key id, and returns the associated
				<samp class="ph codeph">JsonDocument</samp>.</p>

			<pre class="pre codeblock language-java"><code>
public static JsonDocument getItem(String id) {
	JsonDocument response = null;
	try {
		response = bucket.get(id);
	} catch (NoSuchElementException e) {
		System.out.println("ERROR: No element with message: "
				+ e.getMessage());
		e.printStackTrace();
	}
	return response;
}</code></pre>


			<p class="p">When data is stored in Couchbase as JSON, it will be converted by the Java SDK into a
					<strong class="ph b">JsonDocument</strong> object. This allows you to use any JSON library, including the
				one built into the Couchbase SDK, to access, modify and re-save the data held in the
				document. This makes working with data with Couchbase very simple as you have direct
				access to the data as it is stored in the database, allowing for rapid operations from
				both the client and the server. Another important aspect of this code is the error
				checking, here we are catching the <samp class="ph codeph">NosuchElementException</samp> which is
				generated when the given key id is not valid for the current bucket, such as if the key
				simply does not exist or has been previously deleted. Although the SDK will
				automatically handle many error conditions, it is important to ensure that your
				application can handle the errors that the SDK will pass up to it.</p>


			<p class="p">Next is a method to update a JSON document stored in Couchbase, here is the full
				code:</p>

			<pre class="pre codeblock language-java"><code>
public static void updateItem(JsonDocument doc) {
	bucket.upsert(doc);
}</code></pre>

			<p class="p">The delete method is very similar to the get method, as you can see by the code below. It is
				important to note that we are providing both a key identifier to the
					<span class="keyword apiname">remove()</span> method for the bucket as well as a second parameter. The
				second parameter is a durability requirement, and is covered in more detail in the
				document-updating section of the documentation. Briefly though, it allows you to control
				the performance, persistence relationship. By default, the server will acknowledge the
				operation as soon as the document has reached its cache layer, this provides the best
				performance as the client can receive a response very quickly. However, in some
				situations you want or need greater assurances that an operation has completed and so
				you can specify at what point during the persistence process the server will respond
				that the operation has completed. In this case, although performance is not a big
				concern for us, we know that view operations only use data that has been persisted to
				disk. Therefore, if a user was to delete a beer and immediately load the list of beers
				again, it is possible that the delete command would not have been persisted to disk and
				that the deleted beer would still appear in the list. As this could be confusing to the
				user we are ensuring that the deletion has been persisted to disk before moving on.
				Secondly, it may be confusing that we are returning a value.</p>

			<pre class="pre codeblock language-java"><code>
public static void deleteItem(String id) {
	try {
		bucket.remove(id, PersistTo.MASTER);
	} catch (NoSuchElementException e){
		System.out.println("ERROR: No element with message: "
      + e.getMessage());
	}
}</code></pre>


			<p class="p">The next section of the <span class="keyword apiname">ConnectionManager</span> class is going to handle making a
				view query to the Couchbase cluster to allow us to display a list of both the beers and
				the breweries. This code will call upon many of the things we have used in previous
				methods. The first thing to consider when designing a view is the data requirement for
				the operation. Due to the increase in amount of data being sent a view query will be
				slower than a basic get operation. Therefore, we need to consider what data we need from
				the view so that we only <samp class="ph codeph">emit</samp> the values necessary. For our application
				we have written two view functions, one for beers and one for breweries. As described in
				the Creating Your Views section of this tutorial for the beers view we are emitting the
				name of the beer and the ID of its associated brewery. For the breweries we are only
				emitting the name of the brewery. As the view query is more complex than a get
				operation, it is advantageous to leverage the asynchronous API in the SDK. To achieve
				this, we use the <samp class="ph codeph">async()</samp> method on the bucket, this tells the SDK to
				use the underlying asynchronous operations and not to apply any blocking code to it.
				This allows us far greater control over the execution of the operation. Additionally, we
				will now be dealing with observables, which are named here as <samp class="ph codeph">Async</samp>
				objects. Here is the full code for the <span class="keyword apiname">getView()</span> method:</p>

			<pre class="pre codeblock language-java"><code>
public static ArrayList&lt;AsyncViewRow&gt; getView(String designDoc, String view) {
	ArrayList&lt;AsyncViewRow&gt; result = new ArrayList&lt;AsyncViewRow&gt;();
	final CountDownLatch latch = new CountDownLatch(1);
	System.out.println("METHOD START");

	bucket.async().query(
		ViewQuery.from(designDoc, view).limit(20).stale(Stale.FALSE))
		.doOnNext(new Action1&lt;AsyncViewResult&gt;() {
			@Override
			public void call(AsyncViewResult viewResult) {
				if (!viewResult.success()) {
					System.out.println(viewResult.error());
				} else {
					System.out.println("Query is running!");
				}
			}
		}).flatMap(new Func1&lt;AsyncViewResult, Observable&lt;AsyncViewRow&gt;&gt;() {
			@Override
			public Observable&lt;AsyncViewRow&gt; call(AsyncViewResult viewResult) {
				return viewResult.rows();
			}
		}).subscribe(new Subscriber&lt;AsyncViewRow&gt;() {
			@Override
			public void onCompleted() {
				latch.countDown();
			}
			@Override
			public void onError(Throwable throwable) {
				System.err.println("Whoops: " + throwable.getMessage());
			}
			@Override
			public void onNext(AsyncViewRow viewRow) {
				result.add(viewRow);
			}
		});
	try {
		latch.await();
	} catch (InterruptedException e) {
		e.printStackTrace();
	}
	return result;
}</code></pre>


			<p class="p">As you can see the method <span class="keyword apiname">getView()</span> is returning an <samp class="ph codeph">ArrayList</samp> of <samp class="ph codeph">ViewRow</samp> objects. A view query
			 returns an observable object called a <samp class="ph codeph">ViewResult</samp>, which includes information
				about the view and holds <samp class="ph codeph">ViewRow</samp> objects. These are very similar to rows in
				a table with the key and value emitted from the view function. By returning them in an
				iterable structure such as an array list, we are allowing the application easy access to
				the row data without any further interaction with the Couchbase client. The first
				section of the view query we are calling the <span class="keyword apiname">query()</span> method on the open asynchronous
				bucket, passing a ViewQuery object to it and both the design document and the view name
				to the query. In addition, we have added a limit of 20 results to the query so that we
				are not requesting more results from the view than we will be using on one page.
				Finally, we are calling the <span class="keyword apiname">stale()</span> method. This method allows us to control how
				Couchbase handles updating the view result. The default behavior is to return the view
				result and then update the index, this means that any documents that have not been fully
				propagated to disk will not be included in the view result. By providing the <samp class="ph codeph">Stale.FALSE</samp>
				parameter we are telling Couchbase to ensure that the index is fully up to date before
				returning the view, so that we can be sure that the result handed back to us has the
				latest data from the database.</p>

			<p class="p">At this point it is important to understand that the view operation is fully
				asynchronous until you explicitly synchronize the operation by using a blocking
				mechanism. We are yet to do that at this point in the code and so we are dealing with
				observables, as discussed in other areas of this documentation observables operate
				primarily on events. The <strong class="ph b">.doOnNext</strong> method leverages this and will be called
				whenever the onNext method of the observable is triggered, which in this case is
				whenever the query returns a ViewResult object, which is one of the first things the
				Couchbase client will pass onto the observable. As soon as the .doOnNext method is
				called we check the <strong class="ph b">.success()</strong> method of the ViewResult to ensure that the server
				is able to handle the request and there are no errors.</p>

			<p class="p">We can now start operating directly on the data that is being sent from the Couchbase server,
				we do this by running a function called <span class="keyword apiname">flatmap()</span> which takes an iterable object,
				applies a function to each entry in it and returns another iterable. In this case we are
				asking it to take the <samp class="ph codeph">ViewResult</samp> and return every <samp class="ph codeph">ViewRow</samp> from it.</p>

			<p class="p">The next step is to consume the observable by subscribing to it. We achieve this by
				calling the <span class="keyword apiname">subscribe()</span> method with a subscriber that reacts to every new ViewRow
				in the observable. We can then override the subscribers three methods such that they are
				called for every new row (.onNext), if there is an error (.onError) and when the final
				ViewRow has been received and the observable is completed (.onCompelted). In the
				<span class="keyword apiname">onNext()</span> method we are simply taking the viewRow that has been picked up by the
				subscriber and adding it to the ArrayList object that we created earlier, <span class="keyword apiname">onError()</span> is
				called if the observable encounters an issue that it cannot recover from, and in this
				case we simply print out a message to the error log. Finally, the <span class="keyword apiname">onCompleted()</span>
				method is called once at the very end of the operation when the observable has finished
				and there is no more data to be sent, after this method is called the observable will
				terminate and the code will continue. However, as discussed earlier the operation is
				asynchronous at this point and so the code execution will continue in the background
				while the observable is still running. To ensure that the page will not load before the
				view has been fully received and processed we need to block the execution on the thread.
				To achieve this we need to use a countdown lock which can be initialized to an integer
				and will block the thread until the lock has been counted down to 0. As we are only
				calling the latch to countdown in the <span class="keyword apiname">onComplete()</span> method of the subscriber we need to
				initialize the clock to 1, such that when it is counted down once it will have a value
				of 0 and therefore released. We have wrapped the release point (<span class="keyword apiname">latch.await()</span>) in a try
				catch to ensure that if the latch cannot complete for any reason it will be caught.</p>


		</section>

	</div>

<nav class="related-links"><h2>Related information</h2>
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="../../developer/java-2.0/getting-started.html">Getting started</a></div>
<div class="previouslink"><strong>Previous topic:</strong> <a class="link" href="../../developer/java-2.0/hello-couchbase.html">Hello Couchbase Example</a></div>
</div>
</nav></div><footer class="developer-portal-footer" role="contentinfo"><p class="legal"><span class="license">© 2011–2015 <b class="company-name">Couchbase</b>. All rights reserved.</span><a href="http://support.couchbase.com/">Customer Login</a><a href="http://www.couchbase.com/terms-of-service">Terms of Service</a><a href="http://www.couchbase.com/privacy-policy">Privacy Policy</a></p></footer></div></main><script src="../../assets/javascripts/vendor/prism.js"></script><script type="text/javascript">var BASEPATH='../../';</script><script src="../../assets/javascripts/init.js"></script><script type="text/javascript" src="https://issues.couchbase.com/s/en_US-pvmaib-418945332/845/131/1.2.9/_/download/batch/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector.js?collectorId=86389172"></script></body></html>